// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: amp/api.amp.proto

// package amp is an implementation-independent API for a pluggable client-server UI/UX system,
// featuring support and integration for files, media, and communication.

package amp

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_Defs Const = 0
	// TIDBinaryLen is the byte size of a Tx ID ("TID"), a hash with a leading big endian binary time index.
	//
	// This allows TIDs to be sorted chronologically, improving catalog (search) efficiency.
	// This facilitates Tx storage and Tx syndication (time-ordered Tx playback).
	// Importantly, a TxID (32 bytes) is has a UTC16 prefix, allowing efficient LSM storage to scale to billions of Txs.
	//
	// Byte layout is designed so that TIDs are sortable by their embedded timestamp:
	//    0:6   - Standard UTC timestamp in unix seconds (big endian)
	//    6:8   - Timestamp fraction (big endian)
	//    8:32  - Signature/hash suffix.
	Const_TIDBinaryLen Const = 32
	// TIDStringLen is the ASCII-compatible string length of a (binary) TID encoded into its base32 form.
	// The encoding used is the geo-hash base32 alphabet, so that even ascii ordinal string comparisons will correctly sort encoded TIDs by time.
	Const_TIDStringLen Const = 52
	// DefaultServicePort  is the default TCP port used to expose amp.Host service.
	Const_DefaultServicePort Const = 5192
	// Byte size and version of a TxMsg encoding -- sizes are little endian
	// A TxHeader has the following layout:
	//   Bytes  00:03 -- TxHeader marker ('amp')
	//          03:04 -- Const_TxHeader_Version
	//          04:08 -- TxMsg body size: header + serialized TxOp(s)
	//          08:12 -- TxMsg.DataStore size
	//          12:16 -- Reserved
	Const_TxHeader_Size Const = 16
	// Version of the TxHeader -- first byte
	Const_TxHeader_Version Const = 51
	// The first byte of the TxHeader is the header size and version and
	// the following 3 bytes of a serialized TxMsg ("amp")
	Const_TxHeader_Marker Const = 6385008
	// בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ
	// Oh Lord, please bless this project, those who fight for it, and those who lay their life on Your altar.
	Const_Invocation Const = 3773
)

var Const_name = map[int32]string{
	0:       "Const_Defs",
	32:      "Const_TIDBinaryLen",
	52:      "Const_TIDStringLen",
	5192:    "Const_DefaultServicePort",
	16:      "Const_TxHeader_Size",
	51:      "Const_TxHeader_Version",
	6385008: "Const_TxHeader_Marker",
	3773:    "Const_Invocation",
}

var Const_value = map[string]int32{
	"Const_Defs":               0,
	"Const_TIDBinaryLen":       32,
	"Const_TIDStringLen":       52,
	"Const_DefaultServicePort": 5192,
	"Const_TxHeader_Size":      16,
	"Const_TxHeader_Version":   51,
	"Const_TxHeader_Marker":    6385008,
	"Const_Invocation":         3773,
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{0}
}

// TxOpCode specifies a particular cell transaction operation.
type TxOpCode int32

const (
	TxOpCode_Nil        TxOpCode = 0
	TxOpCode_MetaAttr   TxOpCode = 1
	TxOpCode_UpsertAttr TxOpCode = 2
	TxOpCode_DeleteAttr TxOpCode = 4
	TxOpCode_DeleteCell TxOpCode = 5
	TxOpCode_UpsertLink TxOpCode = 7
	TxOpCode_DeleteLink TxOpCode = 8
)

var TxOpCode_name = map[int32]string{
	0: "TxOpCode_Nil",
	1: "TxOpCode_MetaAttr",
	2: "TxOpCode_UpsertAttr",
	4: "TxOpCode_DeleteAttr",
	5: "TxOpCode_DeleteCell",
	7: "TxOpCode_UpsertLink",
	8: "TxOpCode_DeleteLink",
}

var TxOpCode_value = map[string]int32{
	"TxOpCode_Nil":        0,
	"TxOpCode_MetaAttr":   1,
	"TxOpCode_UpsertAttr": 2,
	"TxOpCode_DeleteAttr": 4,
	"TxOpCode_DeleteCell": 5,
	"TxOpCode_UpsertLink": 7,
	"TxOpCode_DeleteLink": 8,
}

func (TxOpCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{1}
}

// TxBody contains a max number of uint64 fields usable for any purpose.
type TxField int32

const (
	TxField_0          TxField = 0
	TxField_FromID_0   TxField = 1
	TxField_FromID_1   TxField = 2
	TxField_FromID_2   TxField = 3
	TxField_TargetID_0 TxField = 4
	TxField_TargetID_1 TxField = 5
	TxField_TargetID_2 TxField = 6
	TxField_AttrID_0   TxField = 7
	TxField_AttrID_1   TxField = 8
	TxField_AttrID_2   TxField = 9
	TxField_SI_0       TxField = 10
	TxField_SI_1       TxField = 11
	TxField_SI_2       TxField = 12
	TxField_Hash       TxField = 13
	TxField_NumFields  TxField = 14
	TxField_MaxFields  TxField = 24
)

var TxField_name = map[int32]string{
	0:  "TxField_0",
	1:  "TxField_FromID_0",
	2:  "TxField_FromID_1",
	3:  "TxField_FromID_2",
	4:  "TxField_TargetID_0",
	5:  "TxField_TargetID_1",
	6:  "TxField_TargetID_2",
	7:  "TxField_AttrID_0",
	8:  "TxField_AttrID_1",
	9:  "TxField_AttrID_2",
	10: "TxField_SI_0",
	11: "TxField_SI_1",
	12: "TxField_SI_2",
	13: "TxField_Hash",
	14: "TxField_NumFields",
	24: "TxField_MaxFields",
}

var TxField_value = map[string]int32{
	"TxField_0":          0,
	"TxField_FromID_0":   1,
	"TxField_FromID_1":   2,
	"TxField_FromID_2":   3,
	"TxField_TargetID_0": 4,
	"TxField_TargetID_1": 5,
	"TxField_TargetID_2": 6,
	"TxField_AttrID_0":   7,
	"TxField_AttrID_1":   8,
	"TxField_AttrID_2":   9,
	"TxField_SI_0":       10,
	"TxField_SI_1":       11,
	"TxField_SI_2":       12,
	"TxField_Hash":       13,
	"TxField_NumFields":  14,
	"TxField_MaxFields":  24,
}

func (TxField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{2}
}

type SelectOp int32

const (
	SelectOp_Neutral SelectOp = 0
	SelectOp_Include SelectOp = 1
	SelectOp_Exclude SelectOp = 2
)

var SelectOp_name = map[int32]string{
	0: "SelectOp_Neutral",
	1: "SelectOp_Include",
	2: "SelectOp_Exclude",
}

var SelectOp_value = map[string]int32{
	"SelectOp_Neutral": 0,
	"SelectOp_Include": 1,
	"SelectOp_Exclude": 2,
}

func (SelectOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{3}
}

// OpStatus allows a sender to express the status of a request.
type OpStatus int32

const (
	// Op / request has not yet been submitted
	OpStatus_NotStarted OpStatus = 0
	// Op / request is in progress
	OpStatus_Syncing OpStatus = 1
	// Sent by the host to signal that the op up to date and the client state is stable / synchronized.
	// This typically drives UI updates or other dependencies requiring a stable state.
	OpStatus_Synced OpStatus = 2
	// From the client to host, this signals to close / cancel the op associated with ReqID.
	// From the host to client, this signals that the given request ID has been closed / discarded.
	OpStatus_Closed OpStatus = 3
)

var OpStatus_name = map[int32]string{
	0: "OpStatus_NotStarted",
	1: "OpStatus_Syncing",
	2: "OpStatus_Synced",
	3: "OpStatus_Closed",
}

var OpStatus_value = map[string]int32{
	"OpStatus_NotStarted": 0,
	"OpStatus_Syncing":    1,
	"OpStatus_Synced":     2,
	"OpStatus_Closed":     3,
}

func (OpStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{4}
}

type PinSync int32

const (
	// If set, a pin request will not send any state responses to the client.
	// This is useful when only writing to a cell and no state updates are needed.
	PinSync_None PinSync = 0
	// If set, a pin request will be automatically closed once state is pushed / synchronized.
	// This is useful when only a snapshot of the cell is needed.
	PinSync_CloseOnSync PinSync = 1
	// If set, a pin request will remain open even after state is synced.
	// In this mode, he client will receive any state updates until the request is explicitly closed.
	PinSync_Maintain PinSync = 2
)

var PinSync_name = map[int32]string{
	0: "PinSync_None",
	1: "PinSync_CloseOnSync",
	2: "PinSync_Maintain",
}

var PinSync_value = map[string]int32{
	"PinSync_None":        0,
	"PinSync_CloseOnSync": 1,
	"PinSync_Maintain":    2,
}

func (PinSync) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{5}
}

// CordType describes how to interpret coordinates contained in a Position.
type CordType int32

const (
	CordType_Unspecified     CordType = 0
	CordType_Ordered         CordType = 1
	CordType_Plane_Cartesian CordType = 5
	CordType_Plane_HexEvenR  CordType = 6
	CordType_Geoid_Sphere    CordType = 10
	CordType_Geoid_WGS84     CordType = 11
)

var CordType_name = map[int32]string{
	0:  "CordType_Unspecified",
	1:  "CordType_Ordered",
	5:  "CordType_Plane_Cartesian",
	6:  "CordType_Plane_HexEvenR",
	10: "CordType_Geoid_Sphere",
	11: "CordType_Geoid_WGS84",
}

var CordType_value = map[string]int32{
	"CordType_Unspecified":     0,
	"CordType_Ordered":         1,
	"CordType_Plane_Cartesian": 5,
	"CordType_Plane_HexEvenR":  6,
	"CordType_Geoid_Sphere":    10,
	"CordType_Geoid_WGS84":     11,
}

func (CordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{6}
}

type Enable int32

const (
	Enable_LatentOff Enable = 0
	Enable_LatentOn  Enable = 1
	Enable_ActiveOn  Enable = 2
	Enable_ActiveOff Enable = 3
)

var Enable_name = map[int32]string{
	0: "Enable_LatentOff",
	1: "Enable_LatentOn",
	2: "Enable_ActiveOn",
	3: "Enable_ActiveOff",
}

var Enable_value = map[string]int32{
	"Enable_LatentOff": 0,
	"Enable_LatentOn":  1,
	"Enable_ActiveOn":  2,
	"Enable_ActiveOff": 3,
}

func (Enable) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{7}
}

type UrlScheme int32

const (
	UrlScheme_Nil          UrlScheme = 0
	UrlScheme_Unrecognized UrlScheme = 1
	UrlScheme_Http         UrlScheme = 2
	UrlScheme_Data         UrlScheme = 3
	UrlScheme_File         UrlScheme = 4
	UrlScheme_Amp          UrlScheme = 7
	UrlScheme_Ipfs         UrlScheme = 17
	UrlScheme_Ipns         UrlScheme = 18
	UrlScheme_Magnet       UrlScheme = 19
	UrlScheme_Git          UrlScheme = 20
)

var UrlScheme_name = map[int32]string{
	0:  "UrlScheme_Nil",
	1:  "UrlScheme_Unrecognized",
	2:  "UrlScheme_Http",
	3:  "UrlScheme_Data",
	4:  "UrlScheme_File",
	7:  "UrlScheme_Amp",
	17: "UrlScheme_Ipfs",
	18: "UrlScheme_Ipns",
	19: "UrlScheme_Magnet",
	20: "UrlScheme_Git",
}

var UrlScheme_value = map[string]int32{
	"UrlScheme_Nil":          0,
	"UrlScheme_Unrecognized": 1,
	"UrlScheme_Http":         2,
	"UrlScheme_Data":         3,
	"UrlScheme_File":         4,
	"UrlScheme_Amp":          7,
	"UrlScheme_Ipfs":         17,
	"UrlScheme_Ipns":         18,
	"UrlScheme_Magnet":       19,
	"UrlScheme_Git":          20,
}

func (UrlScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{8}
}

type Metric int32

const (
	Metric_Nil                           Metric = 0
	Metric_OrthoPixel                    Metric = 1
	Metric_OrthoMillimeter               Metric = 2
	Metric_HexGridMillimeter             Metric = 3
	Metric_TrapezoDodecahedronMillimeter Metric = 4
)

var Metric_name = map[int32]string{
	0: "Metric_Nil",
	1: "Metric_OrthoPixel",
	2: "Metric_OrthoMillimeter",
	3: "Metric_HexGridMillimeter",
	4: "Metric_TrapezoDodecahedronMillimeter",
}

var Metric_value = map[string]int32{
	"Metric_Nil":                           0,
	"Metric_OrthoPixel":                    1,
	"Metric_OrthoMillimeter":               2,
	"Metric_HexGridMillimeter":             3,
	"Metric_TrapezoDodecahedronMillimeter": 4,
}

func (Metric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{9}
}

type TagUse int32

const (
	TagUse_Unspecified TagUse = 0
	TagUse_Pinnable    TagUse = 1
	TagUse_Glyph       TagUse = 2
	TagUse_Link        TagUse = 3
	TagUse_Stream      TagUse = 4
	TagUse_Content     TagUse = 5
)

var TagUse_name = map[int32]string{
	0: "TagUse_Unspecified",
	1: "TagUse_Pinnable",
	2: "TagUse_Glyph",
	3: "TagUse_Link",
	4: "TagUse_Stream",
	5: "TagUse_Content",
}

var TagUse_value = map[string]int32{
	"TagUse_Unspecified": 0,
	"TagUse_Pinnable":    1,
	"TagUse_Glyph":       2,
	"TagUse_Link":        3,
	"TagUse_Stream":      4,
	"TagUse_Content":     5,
}

func (TagUse) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{10}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKit_Nil             CryptoKitID = 0
	CryptoKit_SecretBox_NaCl  CryptoKitID = 100
	CryptoKit_AsymMsg_NaCl    CryptoKitID = 101
	CryptoKit_Signing_NaCl    CryptoKitID = 102
	CryptoKit_Signing_ED25519 CryptoKitID = 202
)

var CryptoKitID_name = map[int32]string{
	0:   "CryptoKit_Nil",
	100: "CryptoKit_SecretBox_NaCl",
	101: "CryptoKit_AsymMsg_NaCl",
	102: "CryptoKit_Signing_NaCl",
	202: "CryptoKit_Signing_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKit_Nil":             0,
	"CryptoKit_SecretBox_NaCl":  100,
	"CryptoKit_AsymMsg_NaCl":    101,
	"CryptoKit_Signing_NaCl":    102,
	"CryptoKit_Signing_ED25519": 202,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{11}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_InternalErr             ErrCode = 5001
	ErrCode_UnsupportedOp           ErrCode = 5002
	ErrCode_Unimplemented           ErrCode = 5003
	ErrCode_Timeout                 ErrCode = 5004
	ErrCode_ShuttingDown            ErrCode = 5005
	ErrCode_NotConnected            ErrCode = 5006
	ErrCode_AuthFailed              ErrCode = 5007
	ErrCode_LoginFailed             ErrCode = 5008
	ErrCode_SessionExpired          ErrCode = 5009
	ErrCode_RequestNotFound         ErrCode = 5010
	ErrCode_RequestClosed           ErrCode = 5011
	ErrCode_BadRequest              ErrCode = 5020
	ErrCode_InvalidURI              ErrCode = 5021
	ErrCode_BadValue                ErrCode = 5022
	ErrCode_InvalidTag              ErrCode = 5023
	ErrCode_InvalidTagSpec          ErrCode = 5024
	ErrCode_AttrNotFound            ErrCode = 5029
	ErrCode_NothingToCommit         ErrCode = 5030
	ErrCode_CommitFailed            ErrCode = 5031
	ErrCode_PlanetNotFound          ErrCode = 5032
	ErrCode_PlanetFailure           ErrCode = 5033
	ErrCode_AppNotFound             ErrCode = 5034
	ErrCode_MalformedTx             ErrCode = 5040
	ErrCode_BadSchema               ErrCode = 5052
	ErrCode_DataFailure             ErrCode = 5053
	ErrCode_ExportErr               ErrCode = 5054
	ErrCode_PinFailed               ErrCode = 5055
	ErrCode_CellNotFound            ErrCode = 5058
	ErrCode_ProviderErr             ErrCode = 5059
	ErrCode_ViolatesAppendOnly      ErrCode = 5100
	ErrCode_InsufficientPermissions ErrCode = 5101
)

var ErrCode_name = map[int32]string{
	0:    "ErrCode_NoErr",
	5000: "ErrCode_UnnamedErr",
	5001: "ErrCode_InternalErr",
	5002: "ErrCode_UnsupportedOp",
	5003: "ErrCode_Unimplemented",
	5004: "ErrCode_Timeout",
	5005: "ErrCode_ShuttingDown",
	5006: "ErrCode_NotConnected",
	5007: "ErrCode_AuthFailed",
	5008: "ErrCode_LoginFailed",
	5009: "ErrCode_SessionExpired",
	5010: "ErrCode_RequestNotFound",
	5011: "ErrCode_RequestClosed",
	5020: "ErrCode_BadRequest",
	5021: "ErrCode_InvalidURI",
	5022: "ErrCode_BadValue",
	5023: "ErrCode_InvalidTag",
	5024: "ErrCode_InvalidTagSpec",
	5029: "ErrCode_AttrNotFound",
	5030: "ErrCode_NothingToCommit",
	5031: "ErrCode_CommitFailed",
	5032: "ErrCode_PlanetNotFound",
	5033: "ErrCode_PlanetFailure",
	5034: "ErrCode_AppNotFound",
	5040: "ErrCode_MalformedTx",
	5052: "ErrCode_BadSchema",
	5053: "ErrCode_DataFailure",
	5054: "ErrCode_ExportErr",
	5055: "ErrCode_PinFailed",
	5058: "ErrCode_CellNotFound",
	5059: "ErrCode_ProviderErr",
	5100: "ErrCode_ViolatesAppendOnly",
	5101: "ErrCode_InsufficientPermissions",
}

var ErrCode_value = map[string]int32{
	"ErrCode_NoErr":                   0,
	"ErrCode_UnnamedErr":              5000,
	"ErrCode_InternalErr":             5001,
	"ErrCode_UnsupportedOp":           5002,
	"ErrCode_Unimplemented":           5003,
	"ErrCode_Timeout":                 5004,
	"ErrCode_ShuttingDown":            5005,
	"ErrCode_NotConnected":            5006,
	"ErrCode_AuthFailed":              5007,
	"ErrCode_LoginFailed":             5008,
	"ErrCode_SessionExpired":          5009,
	"ErrCode_RequestNotFound":         5010,
	"ErrCode_RequestClosed":           5011,
	"ErrCode_BadRequest":              5020,
	"ErrCode_InvalidURI":              5021,
	"ErrCode_BadValue":                5022,
	"ErrCode_InvalidTag":              5023,
	"ErrCode_InvalidTagSpec":          5024,
	"ErrCode_AttrNotFound":            5029,
	"ErrCode_NothingToCommit":         5030,
	"ErrCode_CommitFailed":            5031,
	"ErrCode_PlanetNotFound":          5032,
	"ErrCode_PlanetFailure":           5033,
	"ErrCode_AppNotFound":             5034,
	"ErrCode_MalformedTx":             5040,
	"ErrCode_BadSchema":               5052,
	"ErrCode_DataFailure":             5053,
	"ErrCode_ExportErr":               5054,
	"ErrCode_PinFailed":               5055,
	"ErrCode_CellNotFound":            5058,
	"ErrCode_ProviderErr":             5059,
	"ErrCode_ViolatesAppendOnly":      5100,
	"ErrCode_InsufficientPermissions": 5101,
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{12}
}

type LogLevel int32

const (
	LogLevel_Error LogLevel = 0
	LogLevel_Warn  LogLevel = 2
	LogLevel_Info  LogLevel = 4
)

var LogLevel_name = map[int32]string{
	0: "LogLevel_Error",
	2: "LogLevel_Warn",
	4: "LogLevel_Info",
}

var LogLevel_value = map[string]int32{
	"LogLevel_Error": 0,
	"LogLevel_Warn":  2,
	"LogLevel_Info":  4,
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{13}
}

type TRS_VisualScaleMode int32

const (
	AutoScale  TRS_VisualScaleMode = 0
	FixedScale TRS_VisualScaleMode = 1
)

var TRS_VisualScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var TRS_VisualScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (TRS_VisualScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{19, 0}
}

// TxInfo contains information for a TxMsg
type TxInfo struct {
	// communicates request status / completion.
	Status OpStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=amp.OpStatus" json:"Status,omitempty"`
	// The number of TxOps in this TxMsg.
	NumOps uint64 `protobuf:"varint,4,opt,name=NumOps,proto3" json:"NumOps,omitempty"`
	// A universally unique tag assigned when this Tx was created.
	// Used to identify this tx and also serves as context ID for subsequent responses.
	GenesisID_0 int64  `protobuf:"varint,5,opt,name=GenesisID_0,json=GenesisID0,proto3" json:"GenesisID_0,omitempty"`
	GenesisID_1 uint64 `protobuf:"fixed64,6,opt,name=GenesisID_1,json=GenesisID1,proto3" json:"GenesisID_1,omitempty"`
	GenesisID_2 uint64 `protobuf:"fixed64,7,opt,name=GenesisID_2,json=GenesisID2,proto3" json:"GenesisID_2,omitempty"`
	// This is the GenesisID of the initial request.
	// If 0, this denotes a context-free request and is not dependent on another tx.
	RequestID_0 int64  `protobuf:"varint,10,opt,name=RequestID_0,json=RequestID0,proto3" json:"RequestID_0,omitempty"`
	RequestID_1 uint64 `protobuf:"fixed64,11,opt,name=RequestID_1,json=RequestID1,proto3" json:"RequestID_1,omitempty"`
	RequestID_2 uint64 `protobuf:"fixed64,12,opt,name=RequestID_2,json=RequestID2,proto3" json:"RequestID_2,omitempty"`
	// Home "planet" or "cell" and allied trust chains
	RootElementID_0 int64  `protobuf:"varint,13,opt,name=RootElementID_0,json=RootElementID0,proto3" json:"RootElementID_0,omitempty"`
	RootElementID_1 uint64 `protobuf:"fixed64,14,opt,name=RootElementID_1,json=RootElementID1,proto3" json:"RootElementID_1,omitempty"`
	RootElementID_2 uint64 `protobuf:"fixed64,15,opt,name=RootElementID_2,json=RootElementID2,proto3" json:"RootElementID_2,omitempty"`
}

func (m *TxInfo) Reset()      { *m = TxInfo{} }
func (*TxInfo) ProtoMessage() {}
func (*TxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{0}
}
func (m *TxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInfo.Merge(m, src)
}
func (m *TxInfo) XXX_Size() int {
	return m.Size()
}
func (m *TxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TxInfo proto.InternalMessageInfo

func (m *TxInfo) GetStatus() OpStatus {
	if m != nil {
		return m.Status
	}
	return OpStatus_NotStarted
}

func (m *TxInfo) GetNumOps() uint64 {
	if m != nil {
		return m.NumOps
	}
	return 0
}

func (m *TxInfo) GetGenesisID_0() int64 {
	if m != nil {
		return m.GenesisID_0
	}
	return 0
}

func (m *TxInfo) GetGenesisID_1() uint64 {
	if m != nil {
		return m.GenesisID_1
	}
	return 0
}

func (m *TxInfo) GetGenesisID_2() uint64 {
	if m != nil {
		return m.GenesisID_2
	}
	return 0
}

func (m *TxInfo) GetRequestID_0() int64 {
	if m != nil {
		return m.RequestID_0
	}
	return 0
}

func (m *TxInfo) GetRequestID_1() uint64 {
	if m != nil {
		return m.RequestID_1
	}
	return 0
}

func (m *TxInfo) GetRequestID_2() uint64 {
	if m != nil {
		return m.RequestID_2
	}
	return 0
}

func (m *TxInfo) GetRootElementID_0() int64 {
	if m != nil {
		return m.RootElementID_0
	}
	return 0
}

func (m *TxInfo) GetRootElementID_1() uint64 {
	if m != nil {
		return m.RootElementID_1
	}
	return 0
}

func (m *TxInfo) GetRootElementID_2() uint64 {
	if m != nil {
		return m.RootElementID_2
	}
	return 0
}

// Login -- STEP 1: client -> host
type Login struct {
	// A byte string identifying user who is logging in (lot limited to UTF8)
	// This is typically a username or a persistent Tag issued by the device OS when the app is (re)installed.
	UserUID string `protobuf:"bytes,1,opt,name=UserUID,proto3" json:"UserUID,omitempty"`
	// HostAddr is network address of the server known to the client (e.g. IP address, localhost, domain name, etc)
	// archost uses this to as the host name when serving URLs for the client to consume.
	HostAddr    string `protobuf:"bytes,2,opt,name=HostAddr,proto3" json:"HostAddr,omitempty"`
	DeviceLabel string `protobuf:"bytes,8,opt,name=DeviceLabel,proto3" json:"DeviceLabel,omitempty"`
	DeviceUID   string `protobuf:"bytes,9,opt,name=DeviceUID,proto3" json:"DeviceUID,omitempty"`
	// Current or previous checkpoint -- optional
	Checkpoint *AuthCheckpoint `protobuf:"bytes,10,opt,name=Checkpoint,proto3" json:"Checkpoint,omitempty"`
}

func (m *Login) Reset()      { *m = Login{} }
func (*Login) ProtoMessage() {}
func (*Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{1}
}
func (m *Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Login.Merge(m, src)
}
func (m *Login) XXX_Size() int {
	return m.Size()
}
func (m *Login) XXX_DiscardUnknown() {
	xxx_messageInfo_Login.DiscardUnknown(m)
}

var xxx_messageInfo_Login proto.InternalMessageInfo

func (m *Login) GetUserUID() string {
	if m != nil {
		return m.UserUID
	}
	return ""
}

func (m *Login) GetHostAddr() string {
	if m != nil {
		return m.HostAddr
	}
	return ""
}

func (m *Login) GetDeviceLabel() string {
	if m != nil {
		return m.DeviceLabel
	}
	return ""
}

func (m *Login) GetDeviceUID() string {
	if m != nil {
		return m.DeviceUID
	}
	return ""
}

func (m *Login) GetCheckpoint() *AuthCheckpoint {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

// LoginChallenge -- STEP 2: host -> client
type LoginChallenge struct {
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *LoginChallenge) Reset()      { *m = LoginChallenge{} }
func (*LoginChallenge) ProtoMessage() {}
func (*LoginChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{2}
}
func (m *LoginChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginChallenge.Merge(m, src)
}
func (m *LoginChallenge) XXX_Size() int {
	return m.Size()
}
func (m *LoginChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_LoginChallenge proto.InternalMessageInfo

func (m *LoginChallenge) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// LoginResponse -- STEP 3: client -> host
type LoginResponse struct {
	HashResponse []byte `protobuf:"bytes,1,opt,name=HashResponse,proto3" json:"HashResponse,omitempty"`
}

func (m *LoginResponse) Reset()      { *m = LoginResponse{} }
func (*LoginResponse) ProtoMessage() {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{3}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetHashResponse() []byte {
	if m != nil {
		return m.HashResponse
	}
	return nil
}

// AuthCheckpoint  -- STEP 4: host -> client
type AuthCheckpoint struct {
	Token   string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
	Session *Tag   `protobuf:"bytes,10,opt,name=Session,proto3" json:"Session,omitempty"`
	Member  *Tag   `protobuf:"bytes,11,opt,name=Member,proto3" json:"Member,omitempty"`
	// List of available channel types that a host emits at runtime so a client knows what kind of channel types are available.
	HomeFeed *Tag `protobuf:"bytes,9,opt,name=HomeFeed,proto3" json:"HomeFeed,omitempty"`
}

func (m *AuthCheckpoint) Reset()      { *m = AuthCheckpoint{} }
func (*AuthCheckpoint) ProtoMessage() {}
func (*AuthCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{4}
}
func (m *AuthCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthCheckpoint.Merge(m, src)
}
func (m *AuthCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *AuthCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_AuthCheckpoint proto.InternalMessageInfo

func (m *AuthCheckpoint) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AuthCheckpoint) GetSession() *Tag {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *AuthCheckpoint) GetMember() *Tag {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *AuthCheckpoint) GetHomeFeed() *Tag {
	if m != nil {
		return m.HomeFeed
	}
	return nil
}

// PinRequest is a client request to "pin" a cell, meaning selected attrs and child cells will be pushed to the client.
type PinRequest struct {
	// Specifies a target URL or tag / cell ID to be pinned with the above available mint templates available.
	PinTarget *Tag `protobuf:"bytes,2,opt,name=PinTarget,proto3" json:"PinTarget,omitempty"`
	// Attributes to be pinned (synced) -- if nil, all attrs are pinned
	PinAttrs []*Tag `protobuf:"bytes,4,rep,name=PinAttrs,proto3" json:"PinAttrs,omitempty"`
	// Options for this request.
	PinSync PinSync `protobuf:"varint,6,opt,name=PinSync,proto3,enum=amp.PinSync" json:"PinSync,omitempty"`
}

func (m *PinRequest) Reset()      { *m = PinRequest{} }
func (*PinRequest) ProtoMessage() {}
func (*PinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{5}
}
func (m *PinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinRequest.Merge(m, src)
}
func (m *PinRequest) XXX_Size() int {
	return m.Size()
}
func (m *PinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PinRequest proto.InternalMessageInfo

func (m *PinRequest) GetPinTarget() *Tag {
	if m != nil {
		return m.PinTarget
	}
	return nil
}

func (m *PinRequest) GetPinAttrs() []*Tag {
	if m != nil {
		return m.PinAttrs
	}
	return nil
}

func (m *PinRequest) GetPinSync() PinSync {
	if m != nil {
		return m.PinSync
	}
	return PinSync_None
}

// LaunchURL is used as a meta attribute handle a URL, such as an oauth request (host to client) or an oauth response (client to host).
type LaunchURL struct {
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *LaunchURL) Reset()      { *m = LaunchURL{} }
func (*LaunchURL) ProtoMessage() {}
func (*LaunchURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{6}
}
func (m *LaunchURL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LaunchURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LaunchURL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LaunchURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LaunchURL.Merge(m, src)
}
func (m *LaunchURL) XXX_Size() int {
	return m.Size()
}
func (m *LaunchURL) XXX_DiscardUnknown() {
	xxx_messageInfo_LaunchURL.DiscardUnknown(m)
}

var xxx_messageInfo_LaunchURL proto.InternalMessageInfo

func (m *LaunchURL) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

// Position describes a position in space and/or time using a given coordinate system.
type Position struct {
	CordType CordType `protobuf:"varint,1,opt,name=CordType,proto3,enum=amp.CordType" json:"CordType,omitempty"`
	U        float64  `protobuf:"fixed64,3,opt,name=U,proto3" json:"U,omitempty"`
	V        float64  `protobuf:"fixed64,4,opt,name=V,proto3" json:"V,omitempty"`
	W        float64  `protobuf:"fixed64,5,opt,name=W,proto3" json:"W,omitempty"`
	ROU      float32  `protobuf:"fixed32,6,opt,name=ROU,proto3" json:"ROU,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{7}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetCordType() CordType {
	if m != nil {
		return m.CordType
	}
	return CordType_Unspecified
}

func (m *Position) GetU() float64 {
	if m != nil {
		return m.U
	}
	return 0
}

func (m *Position) GetV() float64 {
	if m != nil {
		return m.V
	}
	return 0
}

func (m *Position) GetW() float64 {
	if m != nil {
		return m.W
	}
	return 0
}

func (m *Position) GetROU() float32 {
	if m != nil {
		return m.ROU
	}
	return 0
}

// Tag is a multi-use workhorse. All fields are optional and whose meaning is contextual.
//
// Often used to reference an asset, a Link can reference any resource, a show, project, episode, or XR beacon.
// The tagging naming convention describes a semi-ordered list of UTF tags.
//      As tags first appear when going from left to right in the list, they are considered "more significant" or "higher priority" than tags that appear later.
//      It is up to amp-search-dev-tag-specification to order search results based on tag filters (case sensitive, time ranges, or any UTF8 enum identifier)
//      By convention, tags are case sensitive by default, however there are many filter presets -- This is how people "type or speak search"
//      "Two tag rule" -- if you can think of two or more other tags in an order ranking, then do that instead.
type Tag struct {
	Use TagUse `protobuf:"varint,1,opt,name=Use,proto3,enum=amp.TagUse" json:"Use,omitempty"`
	// Identifies a specific target tag ID this link points to.
	TagID_0     int64   `protobuf:"varint,2,opt,name=TagID_0,json=TagID0,proto3" json:"TagID_0,omitempty"`
	TagID_1     uint64  `protobuf:"fixed64,3,opt,name=TagID_1,json=TagID1,proto3" json:"TagID_1,omitempty"`
	TagID_2     uint64  `protobuf:"fixed64,4,opt,name=TagID_2,json=TagID2,proto3" json:"TagID_2,omitempty"`
	URL         string  `protobuf:"bytes,13,opt,name=URL,proto3" json:"URL,omitempty"`
	ContentType string  `protobuf:"bytes,14,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	Attachment  []byte  `protobuf:"bytes,15,opt,name=Attachment,proto3" json:"Attachment,omitempty"`
	Metric      Metric  `protobuf:"varint,26,opt,name=Metric,proto3,enum=amp.Metric" json:"Metric,omitempty"`
	Size_0      float32 `protobuf:"fixed32,27,opt,name=Size_0,json=Size0,proto3" json:"Size_0,omitempty"`
	Size_1      float32 `protobuf:"fixed32,28,opt,name=Size_1,json=Size1,proto3" json:"Size_1,omitempty"`
	Size_2      float32 `protobuf:"fixed32,29,opt,name=Size_2,json=Size2,proto3" json:"Size_2,omitempty"`
}

func (m *Tag) Reset()      { *m = Tag{} }
func (*Tag) ProtoMessage() {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{8}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetUse() TagUse {
	if m != nil {
		return m.Use
	}
	return TagUse_Unspecified
}

func (m *Tag) GetTagID_0() int64 {
	if m != nil {
		return m.TagID_0
	}
	return 0
}

func (m *Tag) GetTagID_1() uint64 {
	if m != nil {
		return m.TagID_1
	}
	return 0
}

func (m *Tag) GetTagID_2() uint64 {
	if m != nil {
		return m.TagID_2
	}
	return 0
}

func (m *Tag) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *Tag) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *Tag) GetAttachment() []byte {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *Tag) GetMetric() Metric {
	if m != nil {
		return m.Metric
	}
	return Metric_Nil
}

func (m *Tag) GetSize_0() float32 {
	if m != nil {
		return m.Size_0
	}
	return 0
}

func (m *Tag) GetSize_1() float32 {
	if m != nil {
		return m.Size_1
	}
	return 0
}

func (m *Tag) GetSize_2() float32 {
	if m != nil {
		return m.Size_2
	}
	return 0
}

// TagTab maps to a visual tab for a Tag -- complete with fields for user consumption.
type TagTab struct {
	Label      string `protobuf:"bytes,1,opt,name=Label,proto3" json:"Label,omitempty"`
	Caption    string `protobuf:"bytes,2,opt,name=Caption,proto3" json:"Caption,omitempty"`
	About      string `protobuf:"bytes,3,opt,name=About,proto3" json:"About,omitempty"`
	CreatedAt  int64  `protobuf:"varint,6,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	ModifiedAt int64  `protobuf:"varint,7,opt,name=ModifiedAt,proto3" json:"ModifiedAt,omitempty"`
	Tags       []*Tag `protobuf:"bytes,9,rep,name=Tags,proto3" json:"Tags,omitempty"`
}

func (m *TagTab) Reset()      { *m = TagTab{} }
func (*TagTab) ProtoMessage() {}
func (*TagTab) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{9}
}
func (m *TagTab) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagTab) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagTab.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagTab) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagTab.Merge(m, src)
}
func (m *TagTab) XXX_Size() int {
	return m.Size()
}
func (m *TagTab) XXX_DiscardUnknown() {
	xxx_messageInfo_TagTab.DiscardUnknown(m)
}

var xxx_messageInfo_TagTab proto.InternalMessageInfo

func (m *TagTab) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *TagTab) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *TagTab) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *TagTab) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TagTab) GetModifiedAt() int64 {
	if m != nil {
		return m.ModifiedAt
	}
	return 0
}

func (m *TagTab) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

//
//
//// ChannelSpec declares the presence of a particular set of attr series that, if pinned, have a particular format and intended usage.
////
//// In general, for incoming FeedInfo, a corresponding client pin op, UI tab, and UI sheet (though the sheet may often be hidden or obscured).
////
//// Most streams have 3-4 AttrFeeds:
////      amp.tag.feed.[item.ID]TagTab
////      amp.tag.feed.items.genesis.[]EpochDelta
//message ChannelSpec {  // AttrLayer, AttrSheet, AttrBundle, AttrSet
//
//// Specifies an attr element and/or sequence format.
////    e.g. "amp.app.attr.os.EpochDelta" -
////
//// This value implies an format and interpretation of the data elements in this series and their collective meaning,
//// and typically invokes particular UI elements that specifically handle or visualize the elements of this series.
////
//// Any particular format spec can imply the existence of any number of attr series (e.g. an attr that binds particular attr series as columns).
//string              FormatSpec = 2;
//
//// Specifies an attr usage and/or intention -- e.g. "index"
////
//// This can be considered a suffix to the SeriesSpec, and is used to refine UI presentation and behavior as appropriate.
//string              ContextSpec = 3;
//
//// Specifies a specific instance of this format and context spec.
////
//// This means the spec that is actually pinned is "{FormatSpec}.{ContextSpec}.{InstanceID}"
////Tag                 InstanceID = 4;
//
//// Optional sub collection of feeds also part of this feed - e.g. columns of a spreadsheet
////repeated Feed       Elements = 9;
//}
//
//
//
//// By convention, every cell carries a "amp.feed.genesis.EpochDelta" feed which in turn is a tag.Time series of []EpochDelta.
////    series expressing state for the cell's permissions and the channel catalog.
//message EpochDelta {
//
//// typically 1-4 ops that define default user and permission hive transactions, corresponding permissions tokens, and tag-wide public tokens
//// by convention, the first follows the "constitution rule" where you list things like organization or group mission and offer a purpose.Tag that goes into ore detail about purpose and mission.
////
//// These essentially sequential edits to a permissions key-value store
//// TagIDs (ops)
////      "text/amp.tag.epoch.entries.{clear|write}.{admin|commons|group}"
////      "text/amp.tag.epoch.entries.{clear|write}.{admin|commons|group}"
//repeated Tag        PermissionsOps = 2;
//
//repeated string     ChannelSpecs = 4;
//repeated FeedInfo   RemoveFeeds = 5;
//
//}
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//The U.S.C Social Experiment
//- people "vote" on what they want
//- we're making a voting os app -- invoke blockchains
//
//-- there were penned as  channels, but the actual pb declarations are update elements.
//-- suffix ideas: Rev, Delta, Op, Tx, Item, Entry, Edit
type Ballot struct {
}

func (m *Ballot) Reset()      { *m = Ballot{} }
func (*Ballot) ProtoMessage() {}
func (*Ballot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{10}
}
func (m *Ballot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ballot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ballot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ballot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ballot.Merge(m, src)
}
func (m *Ballot) XXX_Size() int {
	return m.Size()
}
func (m *Ballot) XXX_DiscardUnknown() {
	xxx_messageInfo_Ballot.DiscardUnknown(m)
}

var xxx_messageInfo_Ballot proto.InternalMessageInfo

type NotesEntry struct {
}

func (m *NotesEntry) Reset()      { *m = NotesEntry{} }
func (*NotesEntry) ProtoMessage() {}
func (*NotesEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{11}
}
func (m *NotesEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotesEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotesEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotesEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotesEntry.Merge(m, src)
}
func (m *NotesEntry) XXX_Size() int {
	return m.Size()
}
func (m *NotesEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_NotesEntry.DiscardUnknown(m)
}

var xxx_messageInfo_NotesEntry proto.InternalMessageInfo

//  "amp.tag.spec.talk.spec.message"
type ChatEntry struct {
}

func (m *ChatEntry) Reset()      { *m = ChatEntry{} }
func (*ChatEntry) ProtoMessage() {}
func (*ChatEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{12}
}
func (m *ChatEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatEntry.Merge(m, src)
}
func (m *ChatEntry) XXX_Size() int {
	return m.Size()
}
func (m *ChatEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ChatEntry proto.InternalMessageInfo

type SpreadsheetEntry struct {
}

func (m *SpreadsheetEntry) Reset()      { *m = SpreadsheetEntry{} }
func (*SpreadsheetEntry) ProtoMessage() {}
func (*SpreadsheetEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{13}
}
func (m *SpreadsheetEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadsheetEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadsheetEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadsheetEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadsheetEntry.Merge(m, src)
}
func (m *SpreadsheetEntry) XXX_Size() int {
	return m.Size()
}
func (m *SpreadsheetEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadsheetEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadsheetEntry proto.InternalMessageInfo

type SpatialPlacement struct {
	// Expresses the position of this placement in space.
	// The coordinate system is specified within (or implied) from the hosting attribute spec.
	// Here's to the 3 domains that reflect completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s) -- https://www.youtube.com/watch?v=SrU9YDoXE88
	Pos0 float64 `protobuf:"fixed64,1,opt,name=Pos0,proto3" json:"Pos0,omitempty"`
	Pos1 float64 `protobuf:"fixed64,2,opt,name=Pos1,proto3" json:"Pos1,omitempty"`
	Pos2 float64 `protobuf:"fixed64,3,opt,name=Pos2,proto3" json:"Pos2,omitempty"`
	// Expresses the scale of this Node.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then they are each implicitly Scale1.
	Scale0 float32 `protobuf:"fixed32,4,opt,name=Scale0,proto3" json:"Scale0,omitempty"`
	Scale1 float32 `protobuf:"fixed32,5,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,6,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	// Expresses the orientation of this placement using Euler angles.
	EulerX float32 `protobuf:"fixed32,7,opt,name=EulerX,proto3" json:"EulerX,omitempty"`
	EulerY float32 `protobuf:"fixed32,8,opt,name=EulerY,proto3" json:"EulerY,omitempty"`
	EulerZ float32 `protobuf:"fixed32,9,opt,name=EulerZ,proto3" json:"EulerZ,omitempty"`
}

func (m *SpatialPlacement) Reset()      { *m = SpatialPlacement{} }
func (*SpatialPlacement) ProtoMessage() {}
func (*SpatialPlacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{14}
}
func (m *SpatialPlacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpatialPlacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpatialPlacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpatialPlacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpatialPlacement.Merge(m, src)
}
func (m *SpatialPlacement) XXX_Size() int {
	return m.Size()
}
func (m *SpatialPlacement) XXX_DiscardUnknown() {
	xxx_messageInfo_SpatialPlacement.DiscardUnknown(m)
}

var xxx_messageInfo_SpatialPlacement proto.InternalMessageInfo

func (m *SpatialPlacement) GetPos0() float64 {
	if m != nil {
		return m.Pos0
	}
	return 0
}

func (m *SpatialPlacement) GetPos1() float64 {
	if m != nil {
		return m.Pos1
	}
	return 0
}

func (m *SpatialPlacement) GetPos2() float64 {
	if m != nil {
		return m.Pos2
	}
	return 0
}

func (m *SpatialPlacement) GetScale0() float32 {
	if m != nil {
		return m.Scale0
	}
	return 0
}

func (m *SpatialPlacement) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *SpatialPlacement) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *SpatialPlacement) GetEulerX() float32 {
	if m != nil {
		return m.EulerX
	}
	return 0
}

func (m *SpatialPlacement) GetEulerY() float32 {
	if m != nil {
		return m.EulerY
	}
	return 0
}

func (m *SpatialPlacement) GetEulerZ() float32 {
	if m != nil {
		return m.EulerZ
	}
	return 0
}

type TagPlayableMedia struct {
}

func (m *TagPlayableMedia) Reset()      { *m = TagPlayableMedia{} }
func (*TagPlayableMedia) ProtoMessage() {}
func (*TagPlayableMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{15}
}
func (m *TagPlayableMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagPlayableMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagPlayableMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagPlayableMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagPlayableMedia.Merge(m, src)
}
func (m *TagPlayableMedia) XXX_Size() int {
	return m.Size()
}
func (m *TagPlayableMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_TagPlayableMedia.DiscardUnknown(m)
}

var xxx_messageInfo_TagPlayableMedia proto.InternalMessageInfo

type TagPlaylist struct {
}

func (m *TagPlaylist) Reset()      { *m = TagPlaylist{} }
func (*TagPlaylist) ProtoMessage() {}
func (*TagPlaylist) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{16}
}
func (m *TagPlaylist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagPlaylist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagPlaylist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagPlaylist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagPlaylist.Merge(m, src)
}
func (m *TagPlaylist) XXX_Size() int {
	return m.Size()
}
func (m *TagPlaylist) XXX_DiscardUnknown() {
	xxx_messageInfo_TagPlaylist.DiscardUnknown(m)
}

var xxx_messageInfo_TagPlaylist proto.InternalMessageInfo

type CryptoKey struct {
	CryptoKitID CryptoKitID `protobuf:"varint,1,opt,name=CryptoKitID,proto3,enum=amp.CryptoKitID" json:"CryptoKitID,omitempty"`
	KeyBytes    []byte      `protobuf:"bytes,4,opt,name=KeyBytes,proto3" json:"KeyBytes,omitempty"`
}

func (m *CryptoKey) Reset()      { *m = CryptoKey{} }
func (*CryptoKey) ProtoMessage() {}
func (*CryptoKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{17}
}
func (m *CryptoKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoKey.Merge(m, src)
}
func (m *CryptoKey) XXX_Size() int {
	return m.Size()
}
func (m *CryptoKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoKey.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoKey proto.InternalMessageInfo

func (m *CryptoKey) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKit_Nil
}

func (m *CryptoKey) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

// AuthToken is an oauth token -- see oauth2.Token
type AuthToken struct {
	AccessToken  string `protobuf:"bytes,1,opt,name=AccessToken,proto3" json:"AccessToken,omitempty"`
	TokenType    string `protobuf:"bytes,2,opt,name=TokenType,proto3" json:"TokenType,omitempty"`
	RefreshToken string `protobuf:"bytes,3,opt,name=RefreshToken,proto3" json:"RefreshToken,omitempty"`
	Expiry       int64  `protobuf:"varint,4,opt,name=Expiry,proto3" json:"Expiry,omitempty"`
}

func (m *AuthToken) Reset()      { *m = AuthToken{} }
func (*AuthToken) ProtoMessage() {}
func (*AuthToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{18}
}
func (m *AuthToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthToken.Merge(m, src)
}
func (m *AuthToken) XXX_Size() int {
	return m.Size()
}
func (m *AuthToken) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthToken.DiscardUnknown(m)
}

var xxx_messageInfo_AuthToken proto.InternalMessageInfo

func (m *AuthToken) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *AuthToken) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *AuthToken) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *AuthToken) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type TRS struct {
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Specifies how scale dynamically changes based on observer position.
	ScaleMode TRS_VisualScaleMode `protobuf:"varint,50,opt,name=ScaleMode,proto3,enum=amp.TRS_VisualScaleMode" json:"ScaleMode,omitempty"`
	// Scale1..3 express the scale of this placement.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this placement using Euler angles.
	Rotate1 float32 `protobuf:"fixed32,61,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2 float32 `protobuf:"fixed32,62,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3 float32 `protobuf:"fixed32,63,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
}

func (m *TRS) Reset()      { *m = TRS{} }
func (*TRS) ProtoMessage() {}
func (*TRS) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{19}
}
func (m *TRS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TRS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TRS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TRS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TRS.Merge(m, src)
}
func (m *TRS) XXX_Size() int {
	return m.Size()
}
func (m *TRS) XXX_DiscardUnknown() {
	xxx_messageInfo_TRS.DiscardUnknown(m)
}

var xxx_messageInfo_TRS proto.InternalMessageInfo

func (m *TRS) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *TRS) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *TRS) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *TRS) GetScaleMode() TRS_VisualScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return AutoScale
}

func (m *TRS) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *TRS) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *TRS) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *TRS) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *TRS) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *TRS) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

type DataSegment struct {
	ByteOfs    uint64 `protobuf:"varint,5,opt,name=ByteOfs,proto3" json:"ByteOfs,omitempty"`
	ByteSz     uint64 `protobuf:"varint,6,opt,name=ByteSz,proto3" json:"ByteSz,omitempty"`
	InlineData []byte `protobuf:"bytes,7,opt,name=InlineData,proto3" json:"InlineData,omitempty"`
	StreamURI  string `protobuf:"bytes,9,opt,name=StreamURI,proto3" json:"StreamURI,omitempty"`
	BlobID     int64  `protobuf:"varint,10,opt,name=BlobID,proto3" json:"BlobID,omitempty"`
}

func (m *DataSegment) Reset()      { *m = DataSegment{} }
func (*DataSegment) ProtoMessage() {}
func (*DataSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{20}
}
func (m *DataSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSegment.Merge(m, src)
}
func (m *DataSegment) XXX_Size() int {
	return m.Size()
}
func (m *DataSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSegment.DiscardUnknown(m)
}

var xxx_messageInfo_DataSegment proto.InternalMessageInfo

func (m *DataSegment) GetByteOfs() uint64 {
	if m != nil {
		return m.ByteOfs
	}
	return 0
}

func (m *DataSegment) GetByteSz() uint64 {
	if m != nil {
		return m.ByteSz
	}
	return 0
}

func (m *DataSegment) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

func (m *DataSegment) GetStreamURI() string {
	if m != nil {
		return m.StreamURI
	}
	return ""
}

func (m *DataSegment) GetBlobID() int64 {
	if m != nil {
		return m.BlobID
	}
	return 0
}

// Err is a general purpose error / warning / log message.
type Err struct {
	// Identifies the type of error.
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=amp.ErrCode" json:"Code,omitempty"`
	// Severity level
	Level LogLevel `protobuf:"varint,2,opt,name=Level,proto3,enum=amp.LogLevel" json:"Level,omitempty"`
	// human-readable info
	Msg string `protobuf:"bytes,4,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *Err) Reset()      { *m = Err{} }
func (*Err) ProtoMessage() {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4505e0ac3ae98d9, []int{21}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *Err) GetLevel() LogLevel {
	if m != nil {
		return m.Level
	}
	return LogLevel_Error
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("amp.Const", Const_name, Const_value)
	proto.RegisterEnum("amp.TxOpCode", TxOpCode_name, TxOpCode_value)
	proto.RegisterEnum("amp.TxField", TxField_name, TxField_value)
	proto.RegisterEnum("amp.SelectOp", SelectOp_name, SelectOp_value)
	proto.RegisterEnum("amp.OpStatus", OpStatus_name, OpStatus_value)
	proto.RegisterEnum("amp.PinSync", PinSync_name, PinSync_value)
	proto.RegisterEnum("amp.CordType", CordType_name, CordType_value)
	proto.RegisterEnum("amp.Enable", Enable_name, Enable_value)
	proto.RegisterEnum("amp.UrlScheme", UrlScheme_name, UrlScheme_value)
	proto.RegisterEnum("amp.Metric", Metric_name, Metric_value)
	proto.RegisterEnum("amp.TagUse", TagUse_name, TagUse_value)
	proto.RegisterEnum("amp.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("amp.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("amp.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterEnum("amp.TRS_VisualScaleMode", TRS_VisualScaleMode_name, TRS_VisualScaleMode_value)
	proto.RegisterType((*TxInfo)(nil), "amp.TxInfo")
	proto.RegisterType((*Login)(nil), "amp.Login")
	proto.RegisterType((*LoginChallenge)(nil), "amp.LoginChallenge")
	proto.RegisterType((*LoginResponse)(nil), "amp.LoginResponse")
	proto.RegisterType((*AuthCheckpoint)(nil), "amp.AuthCheckpoint")
	proto.RegisterType((*PinRequest)(nil), "amp.PinRequest")
	proto.RegisterType((*LaunchURL)(nil), "amp.LaunchURL")
	proto.RegisterType((*Position)(nil), "amp.Position")
	proto.RegisterType((*Tag)(nil), "amp.Tag")
	proto.RegisterType((*TagTab)(nil), "amp.TagTab")
	proto.RegisterType((*Ballot)(nil), "amp.Ballot")
	proto.RegisterType((*NotesEntry)(nil), "amp.NotesEntry")
	proto.RegisterType((*ChatEntry)(nil), "amp.ChatEntry")
	proto.RegisterType((*SpreadsheetEntry)(nil), "amp.SpreadsheetEntry")
	proto.RegisterType((*SpatialPlacement)(nil), "amp.SpatialPlacement")
	proto.RegisterType((*TagPlayableMedia)(nil), "amp.TagPlayableMedia")
	proto.RegisterType((*TagPlaylist)(nil), "amp.TagPlaylist")
	proto.RegisterType((*CryptoKey)(nil), "amp.CryptoKey")
	proto.RegisterType((*AuthToken)(nil), "amp.AuthToken")
	proto.RegisterType((*TRS)(nil), "amp.TRS")
	proto.RegisterType((*DataSegment)(nil), "amp.DataSegment")
	proto.RegisterType((*Err)(nil), "amp.Err")
}

func init() { proto.RegisterFile("amp/api.amp.proto", fileDescriptor_f4505e0ac3ae98d9) }

var fileDescriptor_f4505e0ac3ae98d9 = []byte{
	// 2640 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x98, 0x4f, 0x6c, 0x1b, 0xc7,
	0xf5, 0xc7, 0xb5, 0xa4, 0x44, 0x89, 0xa3, 0x3f, 0x1e, 0x8f, 0xff, 0x6d, 0x1c, 0x9b, 0x11, 0x18,
	0xff, 0x22, 0x85, 0x3f, 0xc4, 0x11, 0xa9, 0xa4, 0x68, 0x0f, 0x6d, 0x21, 0x53, 0xb2, 0xcd, 0x46,
	0x94, 0x88, 0x25, 0x69, 0x27, 0x69, 0x11, 0x62, 0xc4, 0x7d, 0x24, 0x07, 0x5e, 0xce, 0x6c, 0x76,
	0x87, 0x2e, 0xe5, 0x4b, 0x8b, 0x02, 0x45, 0xd3, 0xff, 0x69, 0x82, 0xf6, 0xd4, 0x7f, 0x97, 0xb6,
	0xa9, 0x81, 0x02, 0x41, 0x81, 0xde, 0x9a, 0x16, 0x68, 0x2f, 0x41, 0x4f, 0x3e, 0x06, 0x39, 0x14,
	0x8d, 0x73, 0xe9, 0xa1, 0x05, 0x72, 0xef, 0xa5, 0x98, 0xd9, 0xd9, 0xe5, 0xae, 0xa2, 0x9e, 0x34,
	0xef, 0xf3, 0x7d, 0x33, 0x3b, 0xf3, 0xe6, 0xcd, 0x9b, 0x11, 0xd1, 0x59, 0x3a, 0xf6, 0x9f, 0xa7,
	0x3e, 0xbb, 0x4e, 0xc7, 0xfe, 0x75, 0x3f, 0x10, 0x52, 0x90, 0x3c, 0x1d, 0xfb, 0xe5, 0x37, 0xf2,
	0xa8, 0xd0, 0x99, 0x36, 0xf8, 0x40, 0x90, 0xff, 0x43, 0x85, 0xb6, 0xa4, 0x72, 0x12, 0xda, 0xb9,
	0x75, 0x6b, 0x73, 0xad, 0xb6, 0xaa, 0x7d, 0x0f, 0xfd, 0x08, 0x3a, 0x46, 0x24, 0x17, 0x51, 0xe1,
	0x60, 0x32, 0x3e, 0xf4, 0x43, 0x7b, 0x7e, 0xdd, 0xda, 0x9c, 0x77, 0x8c, 0x45, 0x9e, 0x42, 0xcb,
	0xb7, 0x80, 0x43, 0xc8, 0xc2, 0xc6, 0x6e, 0x6f, 0xcb, 0x5e, 0x58, 0xb7, 0x36, 0xf3, 0x0e, 0x4a,
	0xd0, 0x56, 0xd6, 0xa1, 0x6a, 0x17, 0xd6, 0xad, 0xcd, 0x42, 0xca, 0xa1, 0x9a, 0x75, 0xa8, 0xd9,
	0x8b, 0x27, 0x1c, 0x6a, 0xca, 0xc1, 0x81, 0xd7, 0x27, 0x10, 0x4a, 0xfd, 0x09, 0x14, 0x7d, 0x22,
	0x41, 0x5b, 0x59, 0x87, 0xaa, 0xbd, 0x1c, 0x8d, 0x90, 0xa0, 0x6a, 0xd6, 0xa1, 0x66, 0xaf, 0x9c,
	0x70, 0xa8, 0x91, 0x0d, 0x74, 0xc6, 0x11, 0x42, 0xee, 0x79, 0x30, 0x06, 0x1e, 0x7d, 0x66, 0x55,
	0x7f, 0x66, 0x2d, 0x83, 0xb7, 0x3e, 0xed, 0x58, 0xb5, 0xd7, 0xf4, 0x68, 0x59, 0xc7, 0xea, 0xa7,
	0x1d, 0x6b, 0xf6, 0x99, 0x53, 0x1c, 0x6b, 0xe5, 0xdf, 0x5b, 0x68, 0x61, 0x5f, 0x0c, 0x19, 0x27,
	0x36, 0x5a, 0xec, 0x86, 0x10, 0x74, 0x1b, 0xbb, 0xb6, 0xb5, 0x6e, 0x6d, 0x16, 0x9d, 0xd8, 0x24,
	0x97, 0xd1, 0xd2, 0x6d, 0x11, 0xca, 0x1d, 0xd7, 0x0d, 0xf4, 0x2e, 0x15, 0x9d, 0xc4, 0x26, 0xeb,
	0x68, 0x79, 0x17, 0xee, 0xb3, 0x3e, 0xec, 0xd3, 0x23, 0xf0, 0xec, 0x25, 0x2d, 0xa7, 0x11, 0xb9,
	0x82, 0x8a, 0x91, 0xa9, 0x46, 0x2e, 0x6a, 0x7d, 0x06, 0xc8, 0x36, 0x42, 0xf5, 0x11, 0xf4, 0xef,
	0xf9, 0x82, 0x71, 0xa9, 0x83, 0xbb, 0x5c, 0x3b, 0xa7, 0x73, 0x60, 0x67, 0x22, 0x47, 0x33, 0xc9,
	0x49, 0xb9, 0x95, 0xaf, 0xa1, 0x35, 0x3d, 0xe7, 0xfa, 0x88, 0x7a, 0x1e, 0xf0, 0x21, 0x10, 0x82,
	0xe6, 0x6f, 0xd3, 0x70, 0xa4, 0x67, 0xbe, 0xe2, 0xe8, 0x76, 0x79, 0x1b, 0xad, 0x6a, 0x2f, 0x07,
	0x42, 0x5f, 0xf0, 0x10, 0x48, 0x19, 0xad, 0x28, 0x21, 0xb6, 0x8d, 0x73, 0x86, 0x95, 0xdf, 0xb2,
	0xd0, 0x5a, 0xf6, 0xcb, 0xe4, 0x3c, 0x5a, 0xe8, 0x88, 0x7b, 0xc0, 0x4d, 0x58, 0x22, 0x83, 0x94,
	0xd1, 0x62, 0x1b, 0xc2, 0x90, 0x09, 0x6e, 0x66, 0xbd, 0xa4, 0x67, 0xdd, 0xa1, 0x43, 0x27, 0x16,
	0xc8, 0x3a, 0x2a, 0x34, 0x61, 0x7c, 0x04, 0x81, 0x4e, 0x8a, 0xb4, 0x8b, 0xe1, 0xe4, 0x9a, 0x0a,
	0xed, 0x18, 0x6e, 0x02, 0xb8, 0x3a, 0x36, 0x69, 0x9f, 0x44, 0x29, 0x7f, 0xc3, 0x42, 0xa8, 0xa5,
	0x16, 0xa2, 0x33, 0x86, 0x3c, 0x83, 0x8a, 0x2d, 0xc6, 0x3b, 0x34, 0x18, 0x82, 0xd4, 0x1b, 0x92,
	0xee, 0x35, 0x93, 0xd4, 0xe0, 0x2d, 0xc6, 0x77, 0xa4, 0x0c, 0xd4, 0xb1, 0xc9, 0x67, 0x07, 0x8f,
	0x15, 0xf2, 0x0c, 0x5a, 0x6c, 0x31, 0xde, 0x3e, 0xe6, 0x7d, 0x7d, 0x3a, 0xd6, 0x6a, 0x2b, 0xda,
	0xc9, 0x30, 0x27, 0x16, 0xcb, 0x57, 0x51, 0x71, 0x9f, 0x4e, 0x78, 0x7f, 0xd4, 0x75, 0xf6, 0x09,
	0x46, 0xf9, 0xae, 0xb3, 0x6f, 0x22, 0xa2, 0x9a, 0xe5, 0xd7, 0xd1, 0x52, 0x4b, 0x84, 0x4c, 0xaa,
	0x75, 0x3f, 0x8b, 0x96, 0xea, 0x22, 0x70, 0x3b, 0xc7, 0x7e, 0x14, 0xe4, 0xf8, 0x58, 0xc7, 0xd0,
	0x49, 0x64, 0xb2, 0x82, 0xac, 0xae, 0x9d, 0x5f, 0xb7, 0x36, 0x2d, 0xc7, 0xea, 0x2a, 0xeb, 0x8e,
	0x3e, 0xe1, 0x96, 0x63, 0xdd, 0x51, 0xd6, 0x5d, 0x7d, 0xa4, 0x2d, 0xc7, 0xba, 0xab, 0x3e, 0xe9,
	0x1c, 0x76, 0xf5, 0x1c, 0x73, 0x8e, 0x6a, 0x96, 0x7f, 0x97, 0x43, 0xf9, 0x0e, 0x1d, 0x92, 0xab,
	0x28, 0xdf, 0x0d, 0xe3, 0x2f, 0x2d, 0xc7, 0x4b, 0xec, 0x86, 0xe0, 0x28, 0x4e, 0x2e, 0xa1, 0xc5,
	0x0e, 0x1d, 0xea, 0x53, 0x95, 0xd3, 0xa7, 0xaa, 0xa0, 0xcd, 0xad, 0x99, 0x50, 0xd5, 0x33, 0x28,
	0x18, 0xa1, 0x3a, 0x13, 0x6a, 0x7a, 0x32, 0xb1, 0x50, 0x8b, 0x97, 0xbd, 0x9a, 0x2c, 0x5b, 0xe5,
	0x7f, 0x5d, 0x70, 0x09, 0x5c, 0xea, 0xd5, 0xae, 0x45, 0xf9, 0x9f, 0x42, 0xa4, 0x84, 0xd0, 0x8e,
	0x94, 0xb4, 0x3f, 0x52, 0x47, 0x4e, 0x9f, 0xc2, 0x15, 0x27, 0x45, 0xc8, 0xd3, 0x2a, 0x49, 0x64,
	0xc0, 0xfa, 0xf6, 0xe5, 0xd4, 0x02, 0x22, 0xe4, 0x18, 0x89, 0x5c, 0x40, 0x85, 0x36, 0x7b, 0x00,
	0xbd, 0x2d, 0xfb, 0x49, 0xbd, 0xfe, 0x05, 0x65, 0x6d, 0x25, 0xb8, 0x6a, 0x5f, 0x99, 0xe1, 0x6a,
	0x82, 0x6b, 0xf6, 0xd5, 0x19, 0xae, 0x95, 0x1f, 0x5a, 0x48, 0x2d, 0xa4, 0x43, 0x8f, 0x54, 0x4e,
	0x47, 0x07, 0xd6, 0xe4, 0x74, 0x74, 0x54, 0x6d, 0xb4, 0x58, 0xa7, 0xbe, 0xda, 0x42, 0x73, 0xce,
	0x63, 0x53, 0xf9, 0xef, 0x1c, 0x89, 0x89, 0xd4, 0x81, 0x2a, 0x3a, 0x91, 0xa1, 0x8e, 0x76, 0x3d,
	0x00, 0x2a, 0xc1, 0xdd, 0x91, 0x7a, 0x63, 0xf2, 0xce, 0x0c, 0xa8, 0x85, 0x37, 0x85, 0xcb, 0x06,
	0x4c, 0xcb, 0x8b, 0x51, 0xdd, 0x9c, 0x11, 0x72, 0x05, 0xcd, 0x77, 0xe8, 0x30, 0xb4, 0x8b, 0x27,
	0x52, 0x53, 0xd3, 0xf2, 0x12, 0x2a, 0xdc, 0xa0, 0x9e, 0x27, 0x64, 0x79, 0x05, 0xa1, 0x03, 0x21,
	0x21, 0xdc, 0xe3, 0x32, 0x38, 0x2e, 0x2f, 0xa3, 0x62, 0x7d, 0x44, 0x65, 0x64, 0x10, 0x84, 0xdb,
	0x7e, 0x00, 0xd4, 0x0d, 0x47, 0x00, 0x86, 0xfd, 0xdd, 0x52, 0x90, 0x4a, 0x46, 0xbd, 0x96, 0x47,
	0xfb, 0xba, 0xd2, 0xa9, 0xfa, 0xd0, 0x12, 0xe1, 0x96, 0x5e, 0xae, 0xe5, 0xe8, 0xb6, 0x61, 0x55,
	0xbd, 0xd4, 0x88, 0x55, 0x0d, 0xab, 0x99, 0x8c, 0xd4, 0x6d, 0x75, 0xf7, 0xb4, 0xfb, 0xd4, 0x83,
	0x2d, 0x9d, 0x0c, 0x39, 0xc7, 0x58, 0x09, 0xaf, 0xea, 0x1c, 0x8d, 0x79, 0x35, 0xe1, 0x35, 0x93,
	0xab, 0xc6, 0x52, 0x7c, 0x6f, 0xe2, 0x41, 0xf0, 0xb2, 0x8e, 0x45, 0xce, 0x31, 0x56, 0xc2, 0x5f,
	0xd1, 0xd5, 0x33, 0xe6, 0xaf, 0x24, 0xfc, 0x55, 0x5d, 0x19, 0x62, 0xfe, 0xaa, 0x5a, 0x74, 0x87,
	0x0e, 0x5b, 0x1e, 0x3d, 0xa6, 0x47, 0x1e, 0x34, 0xc1, 0x65, 0xb4, 0xbc, 0x8a, 0x96, 0x0d, 0xf3,
	0x58, 0x28, 0xcb, 0x5f, 0x56, 0x1b, 0x73, 0xec, 0x4b, 0xf1, 0x12, 0x1c, 0x93, 0x1a, 0x5a, 0x36,
	0x06, 0x93, 0xa6, 0xb8, 0xaf, 0xd5, 0x70, 0x74, 0x20, 0x67, 0xdc, 0x49, 0x3b, 0xa9, 0x92, 0xff,
	0x12, 0x1c, 0xdf, 0x38, 0x96, 0x10, 0xdd, 0xb8, 0x2b, 0x4e, 0x62, 0x97, 0xbf, 0x65, 0xa1, 0xa2,
	0x2a, 0x91, 0x51, 0x1d, 0x5c, 0x47, 0xcb, 0x3b, 0xfd, 0x3e, 0x84, 0x61, 0xba, 0x46, 0xa6, 0x91,
	0xca, 0x12, 0xdd, 0xd0, 0x07, 0x24, 0xca, 0xab, 0x19, 0x50, 0x45, 0xd9, 0x81, 0x41, 0x00, 0x61,
	0x34, 0x9e, 0x49, 0xb0, 0x0c, 0xd3, 0x91, 0x98, 0xfa, 0x2c, 0x38, 0xd6, 0x73, 0xc9, 0x3b, 0xc6,
	0x2a, 0xff, 0x41, 0x15, 0x00, 0xa7, 0x4d, 0xd6, 0x50, 0xee, 0xe5, 0xaa, 0xfd, 0xac, 0xde, 0xb3,
	0xdc, 0xcb, 0x55, 0x6d, 0xd7, 0xec, 0x8a, 0xb1, 0x6b, 0xda, 0xde, 0xb6, 0xff, 0xdf, 0xd8, 0xdb,
	0xe4, 0x33, 0xa8, 0xa8, 0xf7, 0xa4, 0x29, 0x5c, 0xb0, 0x6b, 0x3a, 0x1e, 0x76, 0x94, 0x7e, 0x4e,
	0xfb, 0xfa, 0x1d, 0x16, 0x4e, 0xa8, 0x97, 0xe8, 0xce, 0xcc, 0x35, 0xb5, 0xe3, 0xdb, 0xff, 0x63,
	0xc7, 0x5f, 0x38, 0xb9, 0xe3, 0xba, 0xb5, 0x6d, 0xbf, 0x98, 0xe2, 0xdb, 0xea, 0x9c, 0x39, 0x42,
	0x52, 0x09, 0x55, 0xfb, 0xf3, 0x5a, 0x88, 0xcd, 0x99, 0x52, 0xb3, 0xbf, 0x90, 0x56, 0x6a, 0x33,
	0x65, 0xdb, 0xfe, 0x62, 0x5a, 0xd9, 0x2e, 0x6f, 0xa1, 0x33, 0x27, 0xe6, 0x4c, 0x56, 0xf5, 0x0e,
	0x09, 0x0d, 0xf0, 0x1c, 0x59, 0x43, 0xe8, 0x26, 0x9b, 0x82, 0x1b, 0xd9, 0x56, 0xf9, 0xc7, 0x16,
	0x5a, 0xde, 0xa5, 0x92, 0xb6, 0x61, 0xa8, 0x4f, 0x87, 0x8d, 0x16, 0xd5, 0xd6, 0x1e, 0x0e, 0x42,
	0x9d, 0xca, 0xf3, 0x4e, 0x6c, 0xaa, 0x15, 0xa8, 0x66, 0xfb, 0x81, 0xce, 0xe5, 0x79, 0xc7, 0x58,
	0xea, 0x6c, 0x37, 0xb8, 0xc7, 0x38, 0xa8, 0x61, 0x74, 0x3e, 0xaf, 0x38, 0x29, 0xa2, 0xf6, 0xbc,
	0x2d, 0x03, 0xa0, 0xe3, 0xae, 0xd3, 0x88, 0x2f, 0xfd, 0x04, 0xe8, 0x51, 0x3d, 0x71, 0xd4, 0xd8,
	0x35, 0xaf, 0x29, 0x63, 0x95, 0x5f, 0x43, 0xf9, 0xbd, 0x40, 0xbd, 0x29, 0xe6, 0xeb, 0x6a, 0x67,
	0xac, 0xd4, 0x75, 0xb4, 0x17, 0x04, 0x8a, 0x39, 0x5a, 0x21, 0x4f, 0xa3, 0x85, 0x7d, 0xb8, 0x0f,
	0x5e, 0xe6, 0xd1, 0xb8, 0x2f, 0x86, 0x1a, 0x3a, 0x91, 0xa6, 0x8a, 0x75, 0x33, 0x1c, 0xea, 0x94,
	0x29, 0x3a, 0xaa, 0x59, 0x79, 0x64, 0xa1, 0x85, 0xba, 0xe0, 0xa1, 0x54, 0x11, 0xd1, 0x8d, 0xde,
	0x2e, 0x0c, 0x42, 0x3c, 0x47, 0x2e, 0x22, 0x12, 0xd9, 0x9d, 0xc6, 0xee, 0x0d, 0xc6, 0x69, 0x70,
	0xbc, 0x0f, 0x1c, 0xaf, 0x67, 0x78, 0x5b, 0x06, 0x8c, 0x0f, 0x15, 0x7f, 0x81, 0x5c, 0x45, 0x76,
	0xd2, 0x9f, 0x4e, 0x3c, 0xd9, 0x86, 0x40, 0xbd, 0x68, 0x5a, 0x22, 0x90, 0xf8, 0xfd, 0x4d, 0x72,
	0x09, 0x9d, 0x33, 0xdd, 0xa6, 0xb7, 0x81, 0xba, 0x10, 0xf4, 0x54, 0x05, 0xc6, 0x98, 0x5c, 0x46,
	0x17, 0x4f, 0x08, 0x77, 0x20, 0x50, 0x6f, 0x05, 0xbc, 0x4d, 0xae, 0xa0, 0x0b, 0x27, 0xb4, 0x26,
	0x0d, 0xee, 0x41, 0x80, 0x3f, 0xf9, 0xf0, 0x9b, 0x79, 0x72, 0x01, 0xe1, 0x48, 0x6d, 0xf0, 0xfb,
	0xa2, 0x4f, 0x55, 0x55, 0xc6, 0xef, 0x5d, 0xad, 0xbc, 0x6b, 0xa1, 0xa5, 0xce, 0xf4, 0xd0, 0xd7,
	0x61, 0xc1, 0x68, 0x25, 0x6e, 0xf7, 0x0e, 0x98, 0x87, 0xe7, 0xc8, 0x05, 0x74, 0x36, 0x21, 0x4d,
	0x90, 0x54, 0x5d, 0xf9, 0xd8, 0x52, 0xf3, 0x4b, 0x70, 0xd7, 0x0f, 0x21, 0x90, 0x5a, 0xc8, 0x65,
	0x84, 0x5d, 0xf0, 0x40, 0x82, 0x16, 0xe6, 0x4f, 0x11, 0xea, 0xe0, 0x79, 0x78, 0xe1, 0x94, 0xa1,
	0xf6, 0x19, 0xbf, 0x87, 0x17, 0x4f, 0xe9, 0xa1, 0x85, 0xa5, 0xca, 0x87, 0x39, 0xb4, 0xd8, 0x99,
	0xde, 0x64, 0xe0, 0xb9, 0x2a, 0x51, 0x4d, 0xb3, 0xb7, 0x85, 0xe7, 0xc8, 0x79, 0x84, 0x63, 0xf3,
	0x66, 0x20, 0xc6, 0xea, 0xce, 0xc6, 0xd6, 0x29, 0xb4, 0x8a, 0x73, 0xa7, 0xd0, 0x1a, 0xce, 0xab,
	0x0d, 0x8b, 0x69, 0xf4, 0x0a, 0xd2, 0x63, 0xcc, 0x9f, 0xca, 0xab, 0x78, 0xe1, 0x54, 0x5e, 0xc3,
	0x85, 0xf4, 0xe8, 0x2a, 0x02, 0x7a, 0x94, 0xc5, 0x53, 0x68, 0x15, 0x2f, 0x9d, 0x42, 0x6b, 0xb8,
	0x18, 0x6d, 0x46, 0x44, 0xdb, 0x8d, 0xde, 0x16, 0x46, 0x27, 0x48, 0x15, 0x2f, 0x9f, 0x20, 0x35,
	0xbc, 0x92, 0x26, 0xea, 0x5d, 0x8a, 0x57, 0xa3, 0x2d, 0x8c, 0xc8, 0xc1, 0x64, 0xac, 0x1b, 0x21,
	0x5e, 0x4b, 0xe3, 0x26, 0x9d, 0x1a, 0x6c, 0x57, 0xf6, 0xd1, 0x52, 0x1b, 0x3c, 0xe8, 0xcb, 0x43,
	0x5f, 0xcd, 0x2b, 0x6e, 0xf7, 0x0e, 0x60, 0x22, 0x03, 0xea, 0x45, 0x31, 0x4e, 0x68, 0x83, 0xf7,
	0xbd, 0x89, 0x0b, 0x51, 0x8c, 0x13, 0xba, 0x37, 0x8d, 0x68, 0xae, 0xd2, 0x47, 0x4b, 0xf1, 0xbf,
	0x62, 0x6a, 0x3f, 0xe3, 0x76, 0xef, 0x40, 0xc8, 0xb6, 0xa4, 0x81, 0x04, 0x37, 0x1a, 0x30, 0x11,
	0xd4, 0x4b, 0x91, 0xf1, 0x21, 0xb6, 0xc8, 0x39, 0x74, 0x26, 0x43, 0xc1, 0xc5, 0xb9, 0x0c, 0xac,
	0x7b, 0x22, 0x04, 0x17, 0xe7, 0x2b, 0x5f, 0x4a, 0x1e, 0xa0, 0x6a, 0xf5, 0xa6, 0xd9, 0x3b, 0x10,
	0x5c, 0x95, 0xae, 0x4b, 0xe8, 0x5c, 0x4c, 0x74, 0x87, 0x43, 0xdd, 0x8e, 0x26, 0x1c, 0x0b, 0x4d,
	0xca, 0xb8, 0xa4, 0x8c, 0xe3, 0x5c, 0xe5, 0xa1, 0x35, 0x7b, 0x7a, 0x12, 0x1b, 0x9d, 0x8f, 0xdb,
	0xbd, 0x2e, 0x0f, 0x7d, 0xe8, 0xeb, 0xa7, 0x47, 0x34, 0xe5, 0x44, 0x39, 0x0c, 0x5c, 0x08, 0xc0,
	0xc5, 0x16, 0xb9, 0xa2, 0x0e, 0xb5, 0xa1, 0x2d, 0x8f, 0x72, 0xe8, 0xd5, 0xd5, 0x1a, 0x43, 0x46,
	0x39, 0x5e, 0x20, 0x4f, 0xa2, 0x4b, 0x27, 0xd4, 0xdb, 0x30, 0xdd, 0xbb, 0x0f, 0xdc, 0xc1, 0x05,
	0xf2, 0x84, 0x3a, 0xbb, 0x46, 0xbc, 0x05, 0x82, 0xb9, 0xbd, 0xb6, 0x3f, 0x82, 0x00, 0x30, 0xca,
	0xcc, 0x22, 0x92, 0xee, 0xde, 0x6a, 0x7f, 0xf6, 0x05, 0xbc, 0x5c, 0x79, 0x0d, 0x15, 0xf6, 0xb8,
	0xba, 0xc3, 0xd5, 0x7c, 0xa2, 0x56, 0x6f, 0x9f, 0xaa, 0x87, 0xe3, 0xe1, 0x60, 0x80, 0xe7, 0x54,
	0xb4, 0xb2, 0x94, 0x47, 0x71, 0x35, 0x70, 0xa7, 0x2f, 0xd9, 0x7d, 0x38, 0xe4, 0xd1, 0x59, 0xc8,
	0xc2, 0xc1, 0x00, 0xe7, 0x2b, 0x1f, 0x5a, 0xa8, 0xd8, 0x0d, 0xbc, 0x76, 0x7f, 0x04, 0x63, 0x20,
	0x67, 0xd1, 0x6a, 0x62, 0x98, 0xea, 0x70, 0x19, 0x5d, 0x9c, 0xa1, 0x2e, 0x0f, 0xa0, 0x2f, 0x86,
	0x9c, 0x3d, 0xd0, 0xc1, 0x20, 0x68, 0x6d, 0xa6, 0xdd, 0x96, 0xd2, 0xc7, 0xb9, 0x2c, 0x53, 0x75,
	0x1e, 0xe7, 0xb3, 0xec, 0x26, 0xf3, 0x00, 0xcf, 0x67, 0x3f, 0xb5, 0x33, 0xf6, 0xf1, 0x62, 0xd6,
	0xad, 0xe1, 0x0f, 0x42, 0x7c, 0xf6, 0x24, 0xe3, 0x21, 0x26, 0x6a, 0x25, 0x33, 0xd6, 0xa4, 0x43,
	0x0e, 0x12, 0x9f, 0xcb, 0x0e, 0x78, 0x8b, 0x49, 0x7c, 0xbe, 0xf2, 0xb6, 0x15, 0xbf, 0x9b, 0x55,
	0x31, 0x8f, 0x5a, 0xb3, 0xa2, 0x67, 0xec, 0xc3, 0x40, 0x8e, 0x44, 0x8b, 0x4d, 0xc1, 0xc3, 0x96,
	0x5a, 0x6d, 0x1a, 0x37, 0x99, 0xe7, 0xb1, 0x31, 0x48, 0x50, 0x75, 0xef, 0x0a, 0xb2, 0x8d, 0x76,
	0x1b, 0xa6, 0xb7, 0x02, 0xe6, 0xa6, 0xd4, 0x3c, 0xd9, 0x44, 0xd7, 0x8c, 0xda, 0x09, 0xa8, 0x0f,
	0x0f, 0xc4, 0xae, 0x70, 0xa1, 0x4f, 0x47, 0xe0, 0x06, 0x82, 0xa7, 0x3c, 0xe7, 0x2b, 0x5f, 0xd3,
	0x2f, 0x6c, 0xf5, 0x5f, 0x87, 0x2a, 0x2c, 0xba, 0x75, 0x22, 0xf5, 0xce, 0xa1, 0x33, 0x86, 0xb7,
	0x18, 0xd7, 0x7b, 0x86, 0x2d, 0x7d, 0xea, 0x23, 0x78, 0xcb, 0x3b, 0xf6, 0x47, 0x38, 0x47, 0xce,
	0xe8, 0x07, 0x9d, 0x22, 0xba, 0x6a, 0xe6, 0x55, 0x08, 0x0c, 0x88, 0xee, 0x51, 0x3c, 0xaf, 0xe2,
	0x67, 0x90, 0xf9, 0x7f, 0x03, 0x2f, 0x54, 0x7e, 0x62, 0x65, 0x5e, 0x7b, 0xaa, 0x5b, 0x62, 0x9a,
	0xf0, 0xa8, 0x34, 0x4f, 0x50, 0x1b, 0xfa, 0x01, 0xc8, 0x1b, 0x62, 0xda, 0x3b, 0xa0, 0x75, 0x0f,
	0xbb, 0xfa, 0x86, 0x4a, 0xd4, 0x9d, 0xf0, 0x78, 0xdc, 0x0c, 0x87, 0x91, 0x06, 0x59, 0xad, 0xcd,
	0x86, 0x9c, 0x71, 0xa3, 0x0d, 0x48, 0x09, 0x3d, 0xf1, 0x69, 0x6d, 0x6f, 0xb7, 0xf6, 0xe2, 0x8b,
	0xd5, 0xcf, 0xe1, 0xbf, 0x59, 0x95, 0xff, 0x14, 0xd0, 0xa2, 0xb9, 0xc4, 0xd5, 0xa4, 0x4c, 0xb3,
	0x77, 0x20, 0xf6, 0x82, 0x40, 0x9f, 0x73, 0x12, 0xa3, 0x2e, 0xe7, 0x74, 0x0c, 0xae, 0xe2, 0x6f,
	0x6c, 0x10, 0x1b, 0x9d, 0x8b, 0x85, 0x06, 0x97, 0x10, 0x70, 0xea, 0x29, 0xe5, 0xdb, 0x1b, 0xe4,
	0x32, 0xba, 0x30, 0xeb, 0x12, 0x4e, 0x7c, 0x5f, 0xa8, 0x82, 0x74, 0xe8, 0xe3, 0xef, 0x9c, 0xd0,
	0xd8, 0xd8, 0x8f, 0x7e, 0xf0, 0x00, 0x17, 0x7f, 0x77, 0x83, 0x9c, 0x47, 0x67, 0x62, 0xad, 0xc3,
	0xc6, 0x20, 0x26, 0x12, 0x7f, 0x6f, 0x83, 0x3c, 0x81, 0xce, 0xc7, 0xb4, 0x3d, 0x9a, 0x48, 0xc9,
	0xf8, 0x70, 0x57, 0x7c, 0x95, 0xe3, 0xef, 0x67, 0xa4, 0x03, 0x21, 0xeb, 0x82, 0x73, 0xe8, 0xab,
	0xb1, 0x7e, 0xb0, 0x91, 0x9e, 0xb6, 0x7a, 0x12, 0xdf, 0xa4, 0xcc, 0x03, 0x17, 0xff, 0x30, 0x33,
	0x6d, 0xfd, 0x23, 0x84, 0x51, 0xde, 0xdc, 0x20, 0x4f, 0xa2, 0x8b, 0xc9, 0x87, 0xa2, 0xdf, 0x09,
	0xf4, 0x6b, 0x16, 0x5c, 0xfc, 0xa3, 0x0d, 0x72, 0x05, 0x5d, 0x8a, 0x45, 0xf3, 0xdf, 0xfe, 0x81,
	0x90, 0x37, 0xc5, 0x84, 0xbb, 0xf8, 0xad, 0xcc, 0xaa, 0x8c, 0x6a, 0x8a, 0xe8, 0xdb, 0x99, 0x99,
	0xdc, 0xa0, 0xae, 0x91, 0xf1, 0x4f, 0x33, 0x42, 0x83, 0xdf, 0xa7, 0x1e, 0x73, 0xbb, 0x4e, 0x03,
	0xff, 0x6c, 0x43, 0xbd, 0x28, 0x52, 0x3d, 0xee, 0x50, 0x6f, 0x02, 0xf8, 0xe7, 0xa7, 0xf9, 0x77,
	0xe8, 0x10, 0xff, 0x22, 0x33, 0xf1, 0x99, 0xd0, 0xf6, 0xa1, 0x8f, 0x7f, 0x99, 0x89, 0x91, 0xba,
	0x03, 0x93, 0x59, 0xff, 0x2a, 0xb3, 0xa6, 0x03, 0x21, 0x47, 0x8c, 0x0f, 0x3b, 0xa2, 0x2e, 0xc6,
	0x63, 0x26, 0xf1, 0xaf, 0x33, 0x1d, 0x23, 0x68, 0x22, 0xf5, 0x9b, 0xcc, 0x07, 0x75, 0xc1, 0x9d,
	0xc5, 0xe2, 0x9d, 0x4c, 0x2c, 0x22, 0x51, 0xf5, 0x9b, 0x04, 0x80, 0x7f, 0x9b, 0x09, 0xfe, 0x8e,
	0xef, 0x27, 0xbd, 0x1e, 0x66, 0x94, 0x26, 0xf5, 0x06, 0x22, 0x18, 0x83, 0xdb, 0x99, 0xe2, 0x77,
	0x37, 0xc8, 0x45, 0x74, 0x36, 0x15, 0x0d, 0x5d, 0x6a, 0x28, 0xfe, 0x63, 0xa6, 0x87, 0xaa, 0x78,
	0xf1, 0x57, 0xde, 0xcb, 0xf4, 0xd8, 0x9b, 0xaa, 0xe4, 0x53, 0x79, 0xf9, 0xa7, 0x0c, 0x6f, 0x25,
	0x1b, 0xff, 0xe7, 0xec, 0x4a, 0xc1, 0xf3, 0x92, 0x69, 0xfd, 0x25, 0xf3, 0x91, 0x56, 0x20, 0xee,
	0x33, 0x17, 0x02, 0x35, 0xd8, 0x5f, 0x37, 0xc8, 0x53, 0xe8, 0x72, 0xac, 0xdc, 0x61, 0xc2, 0xa3,
	0x12, 0xc2, 0x1d, 0xdf, 0x07, 0xee, 0x1e, 0x72, 0xef, 0x18, 0xff, 0x6b, 0x83, 0x5c, 0x43, 0x4f,
	0xcd, 0x76, 0x25, 0x9c, 0x0c, 0x06, 0xac, 0xcf, 0x80, 0xcb, 0x16, 0x04, 0x63, 0xa6, 0xb3, 0x2b,
	0xc4, 0xff, 0xde, 0xa8, 0xec, 0xa2, 0xa5, 0xf8, 0x79, 0xac, 0xca, 0x46, 0xdc, 0xee, 0xed, 0x05,
	0x81, 0x50, 0xc7, 0xef, 0xac, 0xfe, 0xad, 0x2c, 0x62, 0x77, 0x69, 0xa0, 0xee, 0x94, 0x34, 0x6a,
	0xf0, 0x81, 0xc0, 0xf3, 0x37, 0xbe, 0xf2, 0xe8, 0xa3, 0xd2, 0xdc, 0x07, 0x1f, 0x95, 0xe6, 0x3e,
	0xf9, 0xa8, 0x64, 0x7d, 0xfd, 0x71, 0xc9, 0x7a, 0xe7, 0x71, 0xc9, 0x7a, 0xff, 0x71, 0xc9, 0x7a,
	0xf4, 0xb8, 0x64, 0xfd, 0xe3, 0x71, 0xc9, 0xfa, 0xe7, 0xe3, 0xd2, 0xdc, 0x27, 0x8f, 0x4b, 0xd6,
	0x9b, 0x1f, 0x97, 0xe6, 0x1e, 0x7d, 0x5c, 0x9a, 0xfb, 0xe0, 0xe3, 0xd2, 0xdc, 0xab, 0xeb, 0x43,
	0x26, 0x47, 0x93, 0xa3, 0xeb, 0x7d, 0x31, 0x7e, 0x9e, 0x8e, 0xfd, 0xe7, 0xb6, 0x5d, 0xfd, 0x27,
	0x74, 0xef, 0x3d, 0x37, 0x14, 0xaa, 0xf9, 0x30, 0x97, 0xdf, 0x69, 0xb6, 0x8e, 0x0a, 0xfa, 0x17,
	0xe2, 0xed, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x34, 0xcc, 0xf9, 0xcb, 0x36, 0x16, 0x00, 0x00,
}

func (x Const) String() string {
	s, ok := Const_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TxOpCode) String() string {
	s, ok := TxOpCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TxField) String() string {
	s, ok := TxField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SelectOp) String() string {
	s, ok := SelectOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OpStatus) String() string {
	s, ok := OpStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PinSync) String() string {
	s, ok := PinSync_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CordType) String() string {
	s, ok := CordType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Enable) String() string {
	s, ok := Enable_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UrlScheme) String() string {
	s, ok := UrlScheme_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Metric) String() string {
	s, ok := Metric_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TagUse) String() string {
	s, ok := TagUse_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrCode) String() string {
	s, ok := ErrCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LogLevel) String() string {
	s, ok := LogLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TRS_VisualScaleMode) String() string {
	s, ok := TRS_VisualScaleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TxInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxInfo)
	if !ok {
		that2, ok := that.(TxInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.NumOps != that1.NumOps {
		return false
	}
	if this.GenesisID_0 != that1.GenesisID_0 {
		return false
	}
	if this.GenesisID_1 != that1.GenesisID_1 {
		return false
	}
	if this.GenesisID_2 != that1.GenesisID_2 {
		return false
	}
	if this.RequestID_0 != that1.RequestID_0 {
		return false
	}
	if this.RequestID_1 != that1.RequestID_1 {
		return false
	}
	if this.RequestID_2 != that1.RequestID_2 {
		return false
	}
	if this.RootElementID_0 != that1.RootElementID_0 {
		return false
	}
	if this.RootElementID_1 != that1.RootElementID_1 {
		return false
	}
	if this.RootElementID_2 != that1.RootElementID_2 {
		return false
	}
	return true
}
func (this *Login) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Login)
	if !ok {
		that2, ok := that.(Login)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserUID != that1.UserUID {
		return false
	}
	if this.HostAddr != that1.HostAddr {
		return false
	}
	if this.DeviceLabel != that1.DeviceLabel {
		return false
	}
	if this.DeviceUID != that1.DeviceUID {
		return false
	}
	if !this.Checkpoint.Equal(that1.Checkpoint) {
		return false
	}
	return true
}
func (this *LoginChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginChallenge)
	if !ok {
		that2, ok := that.(LoginChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *LoginResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginResponse)
	if !ok {
		that2, ok := that.(LoginResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashResponse, that1.HashResponse) {
		return false
	}
	return true
}
func (this *AuthCheckpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthCheckpoint)
	if !ok {
		that2, ok := that.(AuthCheckpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Session.Equal(that1.Session) {
		return false
	}
	if !this.Member.Equal(that1.Member) {
		return false
	}
	if !this.HomeFeed.Equal(that1.HomeFeed) {
		return false
	}
	return true
}
func (this *PinRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinRequest)
	if !ok {
		that2, ok := that.(PinRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PinTarget.Equal(that1.PinTarget) {
		return false
	}
	if len(this.PinAttrs) != len(that1.PinAttrs) {
		return false
	}
	for i := range this.PinAttrs {
		if !this.PinAttrs[i].Equal(that1.PinAttrs[i]) {
			return false
		}
	}
	if this.PinSync != that1.PinSync {
		return false
	}
	return true
}
func (this *LaunchURL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LaunchURL)
	if !ok {
		that2, ok := that.(LaunchURL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	return true
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CordType != that1.CordType {
		return false
	}
	if this.U != that1.U {
		return false
	}
	if this.V != that1.V {
		return false
	}
	if this.W != that1.W {
		return false
	}
	if this.ROU != that1.ROU {
		return false
	}
	return true
}
func (this *Tag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tag)
	if !ok {
		that2, ok := that.(Tag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Use != that1.Use {
		return false
	}
	if this.TagID_0 != that1.TagID_0 {
		return false
	}
	if this.TagID_1 != that1.TagID_1 {
		return false
	}
	if this.TagID_2 != that1.TagID_2 {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if !bytes.Equal(this.Attachment, that1.Attachment) {
		return false
	}
	if this.Metric != that1.Metric {
		return false
	}
	if this.Size_0 != that1.Size_0 {
		return false
	}
	if this.Size_1 != that1.Size_1 {
		return false
	}
	if this.Size_2 != that1.Size_2 {
		return false
	}
	return true
}
func (this *TagTab) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagTab)
	if !ok {
		that2, ok := that.(TagTab)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Caption != that1.Caption {
		return false
	}
	if this.About != that1.About {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.ModifiedAt != that1.ModifiedAt {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if !this.Tags[i].Equal(that1.Tags[i]) {
			return false
		}
	}
	return true
}
func (this *Ballot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ballot)
	if !ok {
		that2, ok := that.(Ballot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *NotesEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NotesEntry)
	if !ok {
		that2, ok := that.(NotesEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ChatEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChatEntry)
	if !ok {
		that2, ok := that.(ChatEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SpreadsheetEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpreadsheetEntry)
	if !ok {
		that2, ok := that.(SpreadsheetEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SpatialPlacement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpatialPlacement)
	if !ok {
		that2, ok := that.(SpatialPlacement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pos0 != that1.Pos0 {
		return false
	}
	if this.Pos1 != that1.Pos1 {
		return false
	}
	if this.Pos2 != that1.Pos2 {
		return false
	}
	if this.Scale0 != that1.Scale0 {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.EulerX != that1.EulerX {
		return false
	}
	if this.EulerY != that1.EulerY {
		return false
	}
	if this.EulerZ != that1.EulerZ {
		return false
	}
	return true
}
func (this *TagPlayableMedia) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagPlayableMedia)
	if !ok {
		that2, ok := that.(TagPlayableMedia)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *TagPlaylist) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagPlaylist)
	if !ok {
		that2, ok := that.(TagPlaylist)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CryptoKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptoKey)
	if !ok {
		that2, ok := that.(CryptoKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CryptoKitID != that1.CryptoKitID {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	return true
}
func (this *AuthToken) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthToken)
	if !ok {
		that2, ok := that.(AuthToken)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	if this.TokenType != that1.TokenType {
		return false
	}
	if this.RefreshToken != that1.RefreshToken {
		return false
	}
	if this.Expiry != that1.Expiry {
		return false
	}
	return true
}
func (this *TRS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TRS)
	if !ok {
		that2, ok := that.(TRS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.X3 != that1.X3 {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.Scale3 != that1.Scale3 {
		return false
	}
	if this.Rotate1 != that1.Rotate1 {
		return false
	}
	if this.Rotate2 != that1.Rotate2 {
		return false
	}
	if this.Rotate3 != that1.Rotate3 {
		return false
	}
	return true
}
func (this *DataSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSegment)
	if !ok {
		that2, ok := that.(DataSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByteOfs != that1.ByteOfs {
		return false
	}
	if this.ByteSz != that1.ByteSz {
		return false
	}
	if !bytes.Equal(this.InlineData, that1.InlineData) {
		return false
	}
	if this.StreamURI != that1.StreamURI {
		return false
	}
	if this.BlobID != that1.BlobID {
		return false
	}
	return true
}
func (this *Err) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Err)
	if !ok {
		that2, ok := that.(Err)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *TxInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&amp.TxInfo{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "NumOps: "+fmt.Sprintf("%#v", this.NumOps)+",\n")
	s = append(s, "GenesisID_0: "+fmt.Sprintf("%#v", this.GenesisID_0)+",\n")
	s = append(s, "GenesisID_1: "+fmt.Sprintf("%#v", this.GenesisID_1)+",\n")
	s = append(s, "GenesisID_2: "+fmt.Sprintf("%#v", this.GenesisID_2)+",\n")
	s = append(s, "RequestID_0: "+fmt.Sprintf("%#v", this.RequestID_0)+",\n")
	s = append(s, "RequestID_1: "+fmt.Sprintf("%#v", this.RequestID_1)+",\n")
	s = append(s, "RequestID_2: "+fmt.Sprintf("%#v", this.RequestID_2)+",\n")
	s = append(s, "RootElementID_0: "+fmt.Sprintf("%#v", this.RootElementID_0)+",\n")
	s = append(s, "RootElementID_1: "+fmt.Sprintf("%#v", this.RootElementID_1)+",\n")
	s = append(s, "RootElementID_2: "+fmt.Sprintf("%#v", this.RootElementID_2)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Login) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&amp.Login{")
	s = append(s, "UserUID: "+fmt.Sprintf("%#v", this.UserUID)+",\n")
	s = append(s, "HostAddr: "+fmt.Sprintf("%#v", this.HostAddr)+",\n")
	s = append(s, "DeviceLabel: "+fmt.Sprintf("%#v", this.DeviceLabel)+",\n")
	s = append(s, "DeviceUID: "+fmt.Sprintf("%#v", this.DeviceUID)+",\n")
	if this.Checkpoint != nil {
		s = append(s, "Checkpoint: "+fmt.Sprintf("%#v", this.Checkpoint)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.LoginChallenge{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.LoginResponse{")
	s = append(s, "HashResponse: "+fmt.Sprintf("%#v", this.HashResponse)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthCheckpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&amp.AuthCheckpoint{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Session != nil {
		s = append(s, "Session: "+fmt.Sprintf("%#v", this.Session)+",\n")
	}
	if this.Member != nil {
		s = append(s, "Member: "+fmt.Sprintf("%#v", this.Member)+",\n")
	}
	if this.HomeFeed != nil {
		s = append(s, "HomeFeed: "+fmt.Sprintf("%#v", this.HomeFeed)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&amp.PinRequest{")
	if this.PinTarget != nil {
		s = append(s, "PinTarget: "+fmt.Sprintf("%#v", this.PinTarget)+",\n")
	}
	if this.PinAttrs != nil {
		s = append(s, "PinAttrs: "+fmt.Sprintf("%#v", this.PinAttrs)+",\n")
	}
	s = append(s, "PinSync: "+fmt.Sprintf("%#v", this.PinSync)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LaunchURL) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&amp.LaunchURL{")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&amp.Position{")
	s = append(s, "CordType: "+fmt.Sprintf("%#v", this.CordType)+",\n")
	s = append(s, "U: "+fmt.Sprintf("%#v", this.U)+",\n")
	s = append(s, "V: "+fmt.Sprintf("%#v", this.V)+",\n")
	s = append(s, "W: "+fmt.Sprintf("%#v", this.W)+",\n")
	s = append(s, "ROU: "+fmt.Sprintf("%#v", this.ROU)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&amp.Tag{")
	s = append(s, "Use: "+fmt.Sprintf("%#v", this.Use)+",\n")
	s = append(s, "TagID_0: "+fmt.Sprintf("%#v", this.TagID_0)+",\n")
	s = append(s, "TagID_1: "+fmt.Sprintf("%#v", this.TagID_1)+",\n")
	s = append(s, "TagID_2: "+fmt.Sprintf("%#v", this.TagID_2)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "Attachment: "+fmt.Sprintf("%#v", this.Attachment)+",\n")
	s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	s = append(s, "Size_0: "+fmt.Sprintf("%#v", this.Size_0)+",\n")
	s = append(s, "Size_1: "+fmt.Sprintf("%#v", this.Size_1)+",\n")
	s = append(s, "Size_2: "+fmt.Sprintf("%#v", this.Size_2)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagTab) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&amp.TagTab{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Caption: "+fmt.Sprintf("%#v", this.Caption)+",\n")
	s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	s = append(s, "ModifiedAt: "+fmt.Sprintf("%#v", this.ModifiedAt)+",\n")
	if this.Tags != nil {
		s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ballot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.Ballot{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NotesEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.NotesEntry{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.ChatEntry{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpreadsheetEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.SpreadsheetEntry{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpatialPlacement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&amp.SpatialPlacement{")
	s = append(s, "Pos0: "+fmt.Sprintf("%#v", this.Pos0)+",\n")
	s = append(s, "Pos1: "+fmt.Sprintf("%#v", this.Pos1)+",\n")
	s = append(s, "Pos2: "+fmt.Sprintf("%#v", this.Pos2)+",\n")
	s = append(s, "Scale0: "+fmt.Sprintf("%#v", this.Scale0)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "EulerX: "+fmt.Sprintf("%#v", this.EulerX)+",\n")
	s = append(s, "EulerY: "+fmt.Sprintf("%#v", this.EulerY)+",\n")
	s = append(s, "EulerZ: "+fmt.Sprintf("%#v", this.EulerZ)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagPlayableMedia) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.TagPlayableMedia{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagPlaylist) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&amp.TagPlaylist{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CryptoKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&amp.CryptoKey{")
	s = append(s, "CryptoKitID: "+fmt.Sprintf("%#v", this.CryptoKitID)+",\n")
	s = append(s, "KeyBytes: "+fmt.Sprintf("%#v", this.KeyBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&amp.AuthToken{")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	s = append(s, "RefreshToken: "+fmt.Sprintf("%#v", this.RefreshToken)+",\n")
	s = append(s, "Expiry: "+fmt.Sprintf("%#v", this.Expiry)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TRS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&amp.TRS{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "X3: "+fmt.Sprintf("%#v", this.X3)+",\n")
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "Scale3: "+fmt.Sprintf("%#v", this.Scale3)+",\n")
	s = append(s, "Rotate1: "+fmt.Sprintf("%#v", this.Rotate1)+",\n")
	s = append(s, "Rotate2: "+fmt.Sprintf("%#v", this.Rotate2)+",\n")
	s = append(s, "Rotate3: "+fmt.Sprintf("%#v", this.Rotate3)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&amp.DataSegment{")
	s = append(s, "ByteOfs: "+fmt.Sprintf("%#v", this.ByteOfs)+",\n")
	s = append(s, "ByteSz: "+fmt.Sprintf("%#v", this.ByteSz)+",\n")
	s = append(s, "InlineData: "+fmt.Sprintf("%#v", this.InlineData)+",\n")
	s = append(s, "StreamURI: "+fmt.Sprintf("%#v", this.StreamURI)+",\n")
	s = append(s, "BlobID: "+fmt.Sprintf("%#v", this.BlobID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Err) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&amp.Err{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringApiAmp(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RootElementID_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RootElementID_2))
		i--
		dAtA[i] = 0x79
	}
	if m.RootElementID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RootElementID_1))
		i--
		dAtA[i] = 0x71
	}
	if m.RootElementID_0 != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.RootElementID_0))
		i--
		dAtA[i] = 0x68
	}
	if m.RequestID_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RequestID_2))
		i--
		dAtA[i] = 0x61
	}
	if m.RequestID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RequestID_1))
		i--
		dAtA[i] = 0x59
	}
	if m.RequestID_0 != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.RequestID_0))
		i--
		dAtA[i] = 0x50
	}
	if m.GenesisID_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GenesisID_2))
		i--
		dAtA[i] = 0x39
	}
	if m.GenesisID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GenesisID_1))
		i--
		dAtA[i] = 0x31
	}
	if m.GenesisID_0 != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.GenesisID_0))
		i--
		dAtA[i] = 0x28
	}
	if m.NumOps != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.NumOps))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApiAmp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeviceUID) > 0 {
		i -= len(m.DeviceUID)
		copy(dAtA[i:], m.DeviceUID)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.DeviceUID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DeviceLabel) > 0 {
		i -= len(m.DeviceLabel)
		copy(dAtA[i:], m.DeviceLabel)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.DeviceLabel)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.HostAddr) > 0 {
		i -= len(m.HostAddr)
		copy(dAtA[i:], m.HostAddr)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.HostAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserUID) > 0 {
		i -= len(m.UserUID)
		copy(dAtA[i:], m.UserUID)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.UserUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashResponse) > 0 {
		i -= len(m.HashResponse)
		copy(dAtA[i:], m.HashResponse)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.HashResponse)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApiAmp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApiAmp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.HomeFeed != nil {
		{
			size, err := m.HomeFeed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApiAmp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PinSync != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.PinSync))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PinAttrs) > 0 {
		for iNdEx := len(m.PinAttrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PinAttrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApiAmp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PinTarget != nil {
		{
			size, err := m.PinTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApiAmp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *LaunchURL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LaunchURL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LaunchURL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ROU))))
		i--
		dAtA[i] = 0x35
	}
	if m.W != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.W))))
		i--
		dAtA[i] = 0x29
	}
	if m.V != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.V))))
		i--
		dAtA[i] = 0x21
	}
	if m.U != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.U))))
		i--
		dAtA[i] = 0x19
	}
	if m.CordType != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.CordType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Size_2))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.Size_1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Size_1))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.Size_0 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Size_0))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.Metric != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Attachment) > 0 {
		i -= len(m.Attachment)
		copy(dAtA[i:], m.Attachment)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Attachment)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x6a
	}
	if m.TagID_2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TagID_2))
		i--
		dAtA[i] = 0x21
	}
	if m.TagID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TagID_1))
		i--
		dAtA[i] = 0x19
	}
	if m.TagID_0 != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.TagID_0))
		i--
		dAtA[i] = 0x10
	}
	if m.Use != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Use))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TagTab) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagTab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApiAmp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ModifiedAt != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.ModifiedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.CreatedAt != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.About) > 0 {
		i -= len(m.About)
		copy(dAtA[i:], m.About)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.About)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Caption) > 0 {
		i -= len(m.Caption)
		copy(dAtA[i:], m.Caption)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Caption)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ballot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ballot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ballot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NotesEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotesEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotesEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ChatEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SpreadsheetEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadsheetEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpreadsheetEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SpatialPlacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpatialPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpatialPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EulerZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerZ))))
		i--
		dAtA[i] = 0x4d
	}
	if m.EulerY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerY))))
		i--
		dAtA[i] = 0x45
	}
	if m.EulerX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EulerX))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x35
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Scale0 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale0))))
		i--
		dAtA[i] = 0x25
	}
	if m.Pos2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos2))))
		i--
		dAtA[i] = 0x19
	}
	if m.Pos1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos1))))
		i--
		dAtA[i] = 0x11
	}
	if m.Pos0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pos0))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TagPlayableMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagPlayableMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagPlayableMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TagPlaylist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagPlaylist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagPlaylist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CryptoKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiry != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TRS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TRS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TRS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfd
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.ScaleMode != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	return len(dAtA) - i, nil
}

func (m *DataSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobID != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.BlobID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StreamURI) > 0 {
		i -= len(m.StreamURI)
		copy(dAtA[i:], m.StreamURI)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.StreamURI)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ByteSz != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.ByteSz))
		i--
		dAtA[i] = 0x30
	}
	if m.ByteOfs != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.ByteOfs))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintApiAmp(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintApiAmp(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApiAmp(dAtA []byte, offset int, v uint64) int {
	offset -= sovApiAmp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovApiAmp(uint64(m.Status))
	}
	if m.NumOps != 0 {
		n += 1 + sovApiAmp(uint64(m.NumOps))
	}
	if m.GenesisID_0 != 0 {
		n += 1 + sovApiAmp(uint64(m.GenesisID_0))
	}
	if m.GenesisID_1 != 0 {
		n += 9
	}
	if m.GenesisID_2 != 0 {
		n += 9
	}
	if m.RequestID_0 != 0 {
		n += 1 + sovApiAmp(uint64(m.RequestID_0))
	}
	if m.RequestID_1 != 0 {
		n += 9
	}
	if m.RequestID_2 != 0 {
		n += 9
	}
	if m.RootElementID_0 != 0 {
		n += 1 + sovApiAmp(uint64(m.RootElementID_0))
	}
	if m.RootElementID_1 != 0 {
		n += 9
	}
	if m.RootElementID_2 != 0 {
		n += 9
	}
	return n
}

func (m *Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserUID)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.HostAddr)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.DeviceLabel)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.DeviceUID)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *LoginChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashResponse)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *AuthCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.HomeFeed != nil {
		l = m.HomeFeed.Size()
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *PinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PinTarget != nil {
		l = m.PinTarget.Size()
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if len(m.PinAttrs) > 0 {
		for _, e := range m.PinAttrs {
			l = e.Size()
			n += 1 + l + sovApiAmp(uint64(l))
		}
	}
	if m.PinSync != 0 {
		n += 1 + sovApiAmp(uint64(m.PinSync))
	}
	return n
}

func (m *LaunchURL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CordType != 0 {
		n += 1 + sovApiAmp(uint64(m.CordType))
	}
	if m.U != 0 {
		n += 9
	}
	if m.V != 0 {
		n += 9
	}
	if m.W != 0 {
		n += 9
	}
	if m.ROU != 0 {
		n += 5
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Use != 0 {
		n += 1 + sovApiAmp(uint64(m.Use))
	}
	if m.TagID_0 != 0 {
		n += 1 + sovApiAmp(uint64(m.TagID_0))
	}
	if m.TagID_1 != 0 {
		n += 9
	}
	if m.TagID_2 != 0 {
		n += 9
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.Attachment)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.Metric != 0 {
		n += 2 + sovApiAmp(uint64(m.Metric))
	}
	if m.Size_0 != 0 {
		n += 6
	}
	if m.Size_1 != 0 {
		n += 6
	}
	if m.Size_2 != 0 {
		n += 6
	}
	return n
}

func (m *TagTab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovApiAmp(uint64(m.CreatedAt))
	}
	if m.ModifiedAt != 0 {
		n += 1 + sovApiAmp(uint64(m.ModifiedAt))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovApiAmp(uint64(l))
		}
	}
	return n
}

func (m *Ballot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NotesEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChatEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SpreadsheetEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SpatialPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos0 != 0 {
		n += 9
	}
	if m.Pos1 != 0 {
		n += 9
	}
	if m.Pos2 != 0 {
		n += 9
	}
	if m.Scale0 != 0 {
		n += 5
	}
	if m.Scale1 != 0 {
		n += 5
	}
	if m.Scale2 != 0 {
		n += 5
	}
	if m.EulerX != 0 {
		n += 5
	}
	if m.EulerY != 0 {
		n += 5
	}
	if m.EulerZ != 0 {
		n += 5
	}
	return n
}

func (m *TagPlayableMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TagPlaylist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CryptoKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptoKitID != 0 {
		n += 1 + sovApiAmp(uint64(m.CryptoKitID))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func (m *AuthToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovApiAmp(uint64(m.Expiry))
	}
	return n
}

func (m *TRS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.ScaleMode != 0 {
		n += 2 + sovApiAmp(uint64(m.ScaleMode))
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	return n
}

func (m *DataSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteOfs != 0 {
		n += 1 + sovApiAmp(uint64(m.ByteOfs))
	}
	if m.ByteSz != 0 {
		n += 1 + sovApiAmp(uint64(m.ByteSz))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	l = len(m.StreamURI)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	if m.BlobID != 0 {
		n += 1 + sovApiAmp(uint64(m.BlobID))
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApiAmp(uint64(m.Code))
	}
	if m.Level != 0 {
		n += 1 + sovApiAmp(uint64(m.Level))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovApiAmp(uint64(l))
	}
	return n
}

func sovApiAmp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApiAmp(x uint64) (n int) {
	return sovApiAmp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TxInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TxInfo{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`NumOps:` + fmt.Sprintf("%v", this.NumOps) + `,`,
		`GenesisID_0:` + fmt.Sprintf("%v", this.GenesisID_0) + `,`,
		`GenesisID_1:` + fmt.Sprintf("%v", this.GenesisID_1) + `,`,
		`GenesisID_2:` + fmt.Sprintf("%v", this.GenesisID_2) + `,`,
		`RequestID_0:` + fmt.Sprintf("%v", this.RequestID_0) + `,`,
		`RequestID_1:` + fmt.Sprintf("%v", this.RequestID_1) + `,`,
		`RequestID_2:` + fmt.Sprintf("%v", this.RequestID_2) + `,`,
		`RootElementID_0:` + fmt.Sprintf("%v", this.RootElementID_0) + `,`,
		`RootElementID_1:` + fmt.Sprintf("%v", this.RootElementID_1) + `,`,
		`RootElementID_2:` + fmt.Sprintf("%v", this.RootElementID_2) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Login) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Login{`,
		`UserUID:` + fmt.Sprintf("%v", this.UserUID) + `,`,
		`HostAddr:` + fmt.Sprintf("%v", this.HostAddr) + `,`,
		`DeviceLabel:` + fmt.Sprintf("%v", this.DeviceLabel) + `,`,
		`DeviceUID:` + fmt.Sprintf("%v", this.DeviceUID) + `,`,
		`Checkpoint:` + strings.Replace(this.Checkpoint.String(), "AuthCheckpoint", "AuthCheckpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginChallenge{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginResponse{`,
		`HashResponse:` + fmt.Sprintf("%v", this.HashResponse) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthCheckpoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthCheckpoint{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`HomeFeed:` + strings.Replace(this.HomeFeed.String(), "Tag", "Tag", 1) + `,`,
		`Session:` + strings.Replace(this.Session.String(), "Tag", "Tag", 1) + `,`,
		`Member:` + strings.Replace(this.Member.String(), "Tag", "Tag", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPinAttrs := "[]*Tag{"
	for _, f := range this.PinAttrs {
		repeatedStringForPinAttrs += strings.Replace(f.String(), "Tag", "Tag", 1) + ","
	}
	repeatedStringForPinAttrs += "}"
	s := strings.Join([]string{`&PinRequest{`,
		`PinTarget:` + strings.Replace(this.PinTarget.String(), "Tag", "Tag", 1) + `,`,
		`PinAttrs:` + repeatedStringForPinAttrs + `,`,
		`PinSync:` + fmt.Sprintf("%v", this.PinSync) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LaunchURL) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LaunchURL{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`CordType:` + fmt.Sprintf("%v", this.CordType) + `,`,
		`U:` + fmt.Sprintf("%v", this.U) + `,`,
		`V:` + fmt.Sprintf("%v", this.V) + `,`,
		`W:` + fmt.Sprintf("%v", this.W) + `,`,
		`ROU:` + fmt.Sprintf("%v", this.ROU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tag{`,
		`Use:` + fmt.Sprintf("%v", this.Use) + `,`,
		`TagID_0:` + fmt.Sprintf("%v", this.TagID_0) + `,`,
		`TagID_1:` + fmt.Sprintf("%v", this.TagID_1) + `,`,
		`TagID_2:` + fmt.Sprintf("%v", this.TagID_2) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`Attachment:` + fmt.Sprintf("%v", this.Attachment) + `,`,
		`Metric:` + fmt.Sprintf("%v", this.Metric) + `,`,
		`Size_0:` + fmt.Sprintf("%v", this.Size_0) + `,`,
		`Size_1:` + fmt.Sprintf("%v", this.Size_1) + `,`,
		`Size_2:` + fmt.Sprintf("%v", this.Size_2) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagTab) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTags := "[]*Tag{"
	for _, f := range this.Tags {
		repeatedStringForTags += strings.Replace(f.String(), "Tag", "Tag", 1) + ","
	}
	repeatedStringForTags += "}"
	s := strings.Join([]string{`&TagTab{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Caption:` + fmt.Sprintf("%v", this.Caption) + `,`,
		`About:` + fmt.Sprintf("%v", this.About) + `,`,
		`CreatedAt:` + fmt.Sprintf("%v", this.CreatedAt) + `,`,
		`ModifiedAt:` + fmt.Sprintf("%v", this.ModifiedAt) + `,`,
		`Tags:` + repeatedStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ballot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ballot{`,
		`}`,
	}, "")
	return s
}
func (this *NotesEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotesEntry{`,
		`}`,
	}, "")
	return s
}
func (this *ChatEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChatEntry{`,
		`}`,
	}, "")
	return s
}
func (this *SpreadsheetEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpreadsheetEntry{`,
		`}`,
	}, "")
	return s
}
func (this *SpatialPlacement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpatialPlacement{`,
		`Pos0:` + fmt.Sprintf("%v", this.Pos0) + `,`,
		`Pos1:` + fmt.Sprintf("%v", this.Pos1) + `,`,
		`Pos2:` + fmt.Sprintf("%v", this.Pos2) + `,`,
		`Scale0:` + fmt.Sprintf("%v", this.Scale0) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`EulerX:` + fmt.Sprintf("%v", this.EulerX) + `,`,
		`EulerY:` + fmt.Sprintf("%v", this.EulerY) + `,`,
		`EulerZ:` + fmt.Sprintf("%v", this.EulerZ) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagPlayableMedia) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagPlayableMedia{`,
		`}`,
	}, "")
	return s
}
func (this *TagPlaylist) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagPlaylist{`,
		`}`,
	}, "")
	return s
}
func (this *CryptoKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptoKey{`,
		`CryptoKitID:` + fmt.Sprintf("%v", this.CryptoKitID) + `,`,
		`KeyBytes:` + fmt.Sprintf("%v", this.KeyBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthToken{`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`TokenType:` + fmt.Sprintf("%v", this.TokenType) + `,`,
		`RefreshToken:` + fmt.Sprintf("%v", this.RefreshToken) + `,`,
		`Expiry:` + fmt.Sprintf("%v", this.Expiry) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TRS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TRS{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`X3:` + fmt.Sprintf("%v", this.X3) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`Scale3:` + fmt.Sprintf("%v", this.Scale3) + `,`,
		`Rotate1:` + fmt.Sprintf("%v", this.Rotate1) + `,`,
		`Rotate2:` + fmt.Sprintf("%v", this.Rotate2) + `,`,
		`Rotate3:` + fmt.Sprintf("%v", this.Rotate3) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSegment{`,
		`ByteOfs:` + fmt.Sprintf("%v", this.ByteOfs) + `,`,
		`ByteSz:` + fmt.Sprintf("%v", this.ByteSz) + `,`,
		`InlineData:` + fmt.Sprintf("%v", this.InlineData) + `,`,
		`StreamURI:` + fmt.Sprintf("%v", this.StreamURI) + `,`,
		`BlobID:` + fmt.Sprintf("%v", this.BlobID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Err) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Err{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApiAmp(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OpStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOps", wireType)
			}
			m.NumOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisID_0", wireType)
			}
			m.GenesisID_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisID_0 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisID_1", wireType)
			}
			m.GenesisID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisID_2", wireType)
			}
			m.GenesisID_2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisID_2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID_0", wireType)
			}
			m.RequestID_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID_0 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID_1", wireType)
			}
			m.RequestID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID_2", wireType)
			}
			m.RequestID_2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID_2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootElementID_0", wireType)
			}
			m.RootElementID_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootElementID_0 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootElementID_1", wireType)
			}
			m.RootElementID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RootElementID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootElementID_2", wireType)
			}
			m.RootElementID_2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RootElementID_2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &AuthCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashResponse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashResponse = append(m.HashResponse[:0], dAtA[iNdEx:postIndex]...)
			if m.HashResponse == nil {
				m.HashResponse = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeFeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomeFeed == nil {
				m.HomeFeed = &Tag{}
			}
			if err := m.HomeFeed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Tag{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Tag{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinTarget == nil {
				m.PinTarget = &Tag{}
			}
			if err := m.PinTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinAttrs = append(m.PinAttrs, &Tag{})
			if err := m.PinAttrs[len(m.PinAttrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinSync", wireType)
			}
			m.PinSync = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinSync |= PinSync(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LaunchURL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LaunchURL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LaunchURL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CordType", wireType)
			}
			m.CordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CordType |= CordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.U = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.V = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.W = float64(math.Float64frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ROU = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			m.Use = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Use |= TagUse(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID_0", wireType)
			}
			m.TagID_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagID_0 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID_1", wireType)
			}
			m.TagID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TagID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID_2", wireType)
			}
			m.TagID_2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TagID_2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachment = append(m.Attachment[:0], dAtA[iNdEx:postIndex]...)
			if m.Attachment == nil {
				m.Attachment = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= Metric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Size_0 = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Size_1 = float32(math.Float32frombits(v))
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Size_2 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagTab) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagTab: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagTab: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			m.ModifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ballot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ballot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ballot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotesEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotesEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotesEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadsheetEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadsheetEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadsheetEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpatialPlacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpatialPlacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpatialPlacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos0", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos0 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos1 = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pos2 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale0 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerX = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerY = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EulerZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EulerZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagPlayableMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagPlayableMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagPlayableMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagPlaylist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagPlaylist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagPlaylist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TRS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TRS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TRS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= TRS_VisualScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 63:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOfs", wireType)
			}
			m.ByteOfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteOfs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSz", wireType)
			}
			m.ByteSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobID", wireType)
			}
			m.BlobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiAmp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiAmp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiAmp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApiAmp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApiAmp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApiAmp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiAmp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApiAmp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApiAmp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApiAmp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApiAmp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApiAmp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApiAmp = fmt.Errorf("proto: unexpected end of group")
)

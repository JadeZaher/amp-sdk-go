// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: apis/arc/arc.proto

// package arc is an implementation-independent API and support for a distributed
// files, media, and communication system running a realtime 2D/3D/XR client.

package arc

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_Defs Const = 0
	// TIDBinaryLen is the byte size of a Tx ID ("TID"), a hash with a leading big endian binary time index.
	//
	// This allows TIDs to be naturally sorted chronologically naturally.
	// This facilitates Tx storage and Tx syndication (time-ordered Tx playback).  This also improves performance.
	// since most operations tend to be in the same time neighborhood, leveraging the db's cache.
	//
	// Byte layout is designed so that TIDs are sortable by their embedded timestamp:
	//    0:6   - Standard UTC timestamp in unix seconds (big endian)
	//    6:8   - Timestamp fraction (big endian)
	//    8:32  - Signature/hash
	Const_TIDBinaryLen Const = 32
	// TIDStringLen is the ASCII-compatible string length of a (binary) TID encoded into its base32 form.
	// The encoding used is the geohash base32 alphabet, so that even ascii ordinal string comparisons will correctly sort encoded TIDs by time.
	Const_TIDStringLen Const = 52
	// TIDTimestampSz is the number of left-hand bytes in a TID reserved for a time index value.
	Const_TIDTimestampSz Const = 8
	// DefaultGrpcServicePort is the TCP port the service HostGrpc should run on by default.
	Const_DefaultGrpcServicePort Const = 5192
)

var Const_name = map[int32]string{
	0:    "Const_Defs",
	32:   "Const_TIDBinaryLen",
	52:   "Const_TIDStringLen",
	8:    "Const_TIDTimestampSz",
	5192: "Const_DefaultGrpcServicePort",
}

var Const_value = map[string]int32{
	"Const_Defs":                   0,
	"Const_TIDBinaryLen":           32,
	"Const_TIDStringLen":           52,
	"Const_TIDTimestampSz":         8,
	"Const_DefaultGrpcServicePort": 5192,
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{0}
}

// These are hard-wired symbol IDs are required to bootstrap a new connection.
// After bootstrapping, the client uses RegisterDefs to register its symbols.
type ConstSymbol int32

const (
	ConstSymbol_nil            ConstSymbol = 0
	ConstSymbol_Err            ConstSymbol = 6
	ConstSymbol_RegisterDefs   ConstSymbol = 10
	ConstSymbol_HandleURI      ConstSymbol = 11
	ConstSymbol_Login          ConstSymbol = 20
	ConstSymbol_LoginChallenge ConstSymbol = 21
	ConstSymbol_LoginResponse  ConstSymbol = 22
	// Minimum symbol ID that a client is allowed to issue
	// This value sets a ceiling for the above hard-wired symbol IDs.
	ConstSymbol_IssuerInitsAt ConstSymbol = 256
)

var ConstSymbol_name = map[int32]string{
	0:   "ConstSymbol_nil",
	6:   "ConstSymbol_Err",
	10:  "ConstSymbol_RegisterDefs",
	11:  "ConstSymbol_HandleURI",
	20:  "ConstSymbol_Login",
	21:  "ConstSymbol_LoginChallenge",
	22:  "ConstSymbol_LoginResponse",
	256: "ConstSymbol_IssuerInitsAt",
}

var ConstSymbol_value = map[string]int32{
	"ConstSymbol_nil":            0,
	"ConstSymbol_Err":            6,
	"ConstSymbol_RegisterDefs":   10,
	"ConstSymbol_HandleURI":      11,
	"ConstSymbol_Login":          20,
	"ConstSymbol_LoginChallenge": 21,
	"ConstSymbol_LoginResponse":  22,
	"ConstSymbol_IssuerInitsAt":  256,
}

func (ConstSymbol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{1}
}

// MsgOp tells a holder of a Msg how to interpret its purpose and fields.
type MsgOp int32

const (
	MsgOp_NoOp MsgOp = 0
	// MsgOp_MetaAttr posts a high-level event to the receiver, serving as a mechanism to send app-specific events.
	//
	// Params:
	//      Msg.ReqID:      originating request ID
	//      Msg.ValBuf:     IAW with AttrID
	MsgOp_MetaAttr MsgOp = 4
	// From client to host, this requests a given cell be pinned.
	//
	// Params:
	//      Msg.ReqID:      client-generated (unique) request ID
	//      Msg.CellID:     CellID being pinned     (host to client, otherwise 0)
	//      Msg.ValBuf:     PinReq                  (client to host, otherwise nil)
	MsgOp_PinCell MsgOp = 6
	// Used to push attr element values.
	//
	// Params:
	//      Msg.ReqID:      originating MsgOp_PinCell request ID
	//      Msg.CellID:     which cell is being updated
	//      Msg.AttrID:     which attr is being updated
	//      Msg.ValBuf:     IAW with AttrID
	MsgOp_PushAttrElem MsgOp = 10
	// Used by the sender to signal that the given cell's state push is up to date and can be processed by the recipient.
	// This msg is typically used to drive UI updates or other aggregate cell dependencies.
	//
	// Params:
	//      Msg.ReqID:      originating request ID
	//      Msg.CellID:     which cell is an an updated state
	MsgOp_Checkpoint MsgOp = 24
	// From the client to host, this signals to cancel the operation(s) associated with the given request ID (PinID).
	// From the host to client, this signals that the given request ID has been canceled / discarded (and is now closed).
	// if len(Msg.ValBuf) > 0, then an Err is serialized, offering amplifying info on why the request was closed.
	//
	// Params:
	//      Msg.ReqID:      parent request ID
	MsgOp_Close MsgOp = 127
)

var MsgOp_name = map[int32]string{
	0:   "MsgOp_NoOp",
	4:   "MsgOp_MetaAttr",
	6:   "MsgOp_PinCell",
	10:  "MsgOp_PushAttrElem",
	24:  "MsgOp_Checkpoint",
	127: "MsgOp_Close",
}

var MsgOp_value = map[string]int32{
	"MsgOp_NoOp":         0,
	"MsgOp_MetaAttr":     4,
	"MsgOp_PinCell":      6,
	"MsgOp_PushAttrElem": 10,
	"MsgOp_Checkpoint":   24,
	"MsgOp_Close":        127,
}

func (MsgOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{2}
}

type MsgFlags int32

const (
	MsgFlags_None MsgFlags = 0
	// Used to signal that Msg.CelID has been deleted
	MsgFlags_CellDeleted MsgFlags = 2
	// ValBufShared signals that this Msg's ValBuf referenced elsewhere and is therefore READ ONLY.
	// This used internally to support Msg pooling / recycling.
	// When marshaling, this flag is always cleared!
	MsgFlags_ValBufShared MsgFlags = 256
)

var MsgFlags_name = map[int32]string{
	0:   "MsgFlags_None",
	2:   "MsgFlags_CellDeleted",
	256: "MsgFlags_ValBufShared",
}

var MsgFlags_value = map[string]int32{
	"MsgFlags_None":         0,
	"MsgFlags_CellDeleted":  2,
	"MsgFlags_ValBufShared": 256,
}

func (MsgFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{3}
}

type GeoModel int32

const (
	GeoModel_Sphere GeoModel = 0
)

var GeoModel_name = map[int32]string{
	0: "GeoModel_Sphere",
}

var GeoModel_value = map[string]int32{
	"GeoModel_Sphere": 0,
}

func (GeoModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{4}
}

// URIScheme is used to accompany a URI to specify a URI scheme without it being being a prefix of the URI .
type URIScheme int32

const (
	URIScheme_Any        URIScheme = 0
	URIScheme_Data       URIScheme = 1
	URIScheme_HTTP       URIScheme = 2
	URIScheme_File       URIScheme = 5
	URIScheme_Arc        URIScheme = 6
	URIScheme_CrateAsset URIScheme = 2701
	URIScheme_CellSchema URIScheme = 2702
)

var URIScheme_name = map[int32]string{
	0:    "URIScheme_Any",
	1:    "URIScheme_Data",
	2:    "URIScheme_HTTP",
	5:    "URIScheme_File",
	6:    "URIScheme_Arc",
	2701: "URIScheme_CrateAsset",
	2702: "URIScheme_CellSchema",
}

var URIScheme_value = map[string]int32{
	"URIScheme_Any":        0,
	"URIScheme_Data":       1,
	"URIScheme_HTTP":       2,
	"URIScheme_File":       5,
	"URIScheme_Arc":        6,
	"URIScheme_CrateAsset": 2701,
	"URIScheme_CellSchema": 2702,
}

func (URIScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{5}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKit_Nil             CryptoKitID = 0
	CryptoKit_SecretBox_NaCl  CryptoKitID = 100
	CryptoKit_AsymMsg_NaCl    CryptoKitID = 101
	CryptoKit_Signing_NaCl    CryptoKitID = 102
	CryptoKit_Signing_ED25519 CryptoKitID = 202
)

var CryptoKitID_name = map[int32]string{
	0:   "CryptoKit_Nil",
	100: "CryptoKit_SecretBox_NaCl",
	101: "CryptoKit_AsymMsg_NaCl",
	102: "CryptoKit_Signing_NaCl",
	202: "CryptoKit_Signing_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKit_Nil":             0,
	"CryptoKit_SecretBox_NaCl":  100,
	"CryptoKit_AsymMsg_NaCl":    101,
	"CryptoKit_Signing_NaCl":    102,
	"CryptoKit_Signing_ED25519": 202,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{6}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_InternalErr             ErrCode = 5001
	ErrCode_UnsupportedOp           ErrCode = 5002
	ErrCode_Unimplemented           ErrCode = 5003
	ErrCode_Timeout                 ErrCode = 5004
	ErrCode_ShuttingDown            ErrCode = 5005
	ErrCode_NotConnected            ErrCode = 5006
	ErrCode_AuthFailed              ErrCode = 5007
	ErrCode_LoginFailed             ErrCode = 5008
	ErrCode_SessionExpired          ErrCode = 5009
	ErrCode_ReqNotFound             ErrCode = 5010
	ErrCode_InvalidReq              ErrCode = 5020
	ErrCode_InvalidURI              ErrCode = 5021
	ErrCode_BadValue                ErrCode = 5022
	ErrCode_NothingToCommit         ErrCode = 5030
	ErrCode_CommitFailed            ErrCode = 5031
	ErrCode_PlanetNotFound          ErrCode = 5032
	ErrCode_PlanetFailure           ErrCode = 5033
	ErrCode_AppNotFound             ErrCode = 5034
	ErrCode_DefNotFound             ErrCode = 5036
	ErrCode_MalformedTx             ErrCode = 5040
	ErrCode_TypeNotFound            ErrCode = 5050
	ErrCode_TypeNotRegistered       ErrCode = 5051
	ErrCode_BadSchema               ErrCode = 5052
	ErrCode_DataFailure             ErrCode = 5053
	ErrCode_ExportErr               ErrCode = 5054
	ErrCode_PinFailed               ErrCode = 5055
	ErrCode_PinContextClosed        ErrCode = 5056
	ErrCode_CellNotFound            ErrCode = 5058
	ErrCode_ProviderErr             ErrCode = 5059
	ErrCode_ViolatesAppendOnly      ErrCode = 5100
	ErrCode_InsufficientPermissions ErrCode = 5101
)

var ErrCode_name = map[int32]string{
	0:    "ErrCode_NoErr",
	5000: "ErrCode_UnnamedErr",
	5001: "ErrCode_InternalErr",
	5002: "ErrCode_UnsupportedOp",
	5003: "ErrCode_Unimplemented",
	5004: "ErrCode_Timeout",
	5005: "ErrCode_ShuttingDown",
	5006: "ErrCode_NotConnected",
	5007: "ErrCode_AuthFailed",
	5008: "ErrCode_LoginFailed",
	5009: "ErrCode_SessionExpired",
	5010: "ErrCode_ReqNotFound",
	5020: "ErrCode_InvalidReq",
	5021: "ErrCode_InvalidURI",
	5022: "ErrCode_BadValue",
	5030: "ErrCode_NothingToCommit",
	5031: "ErrCode_CommitFailed",
	5032: "ErrCode_PlanetNotFound",
	5033: "ErrCode_PlanetFailure",
	5034: "ErrCode_AppNotFound",
	5036: "ErrCode_DefNotFound",
	5040: "ErrCode_MalformedTx",
	5050: "ErrCode_TypeNotFound",
	5051: "ErrCode_TypeNotRegistered",
	5052: "ErrCode_BadSchema",
	5053: "ErrCode_DataFailure",
	5054: "ErrCode_ExportErr",
	5055: "ErrCode_PinFailed",
	5056: "ErrCode_PinContextClosed",
	5058: "ErrCode_CellNotFound",
	5059: "ErrCode_ProviderErr",
	5100: "ErrCode_ViolatesAppendOnly",
	5101: "ErrCode_InsufficientPermissions",
}

var ErrCode_value = map[string]int32{
	"ErrCode_NoErr":                   0,
	"ErrCode_UnnamedErr":              5000,
	"ErrCode_InternalErr":             5001,
	"ErrCode_UnsupportedOp":           5002,
	"ErrCode_Unimplemented":           5003,
	"ErrCode_Timeout":                 5004,
	"ErrCode_ShuttingDown":            5005,
	"ErrCode_NotConnected":            5006,
	"ErrCode_AuthFailed":              5007,
	"ErrCode_LoginFailed":             5008,
	"ErrCode_SessionExpired":          5009,
	"ErrCode_ReqNotFound":             5010,
	"ErrCode_InvalidReq":              5020,
	"ErrCode_InvalidURI":              5021,
	"ErrCode_BadValue":                5022,
	"ErrCode_NothingToCommit":         5030,
	"ErrCode_CommitFailed":            5031,
	"ErrCode_PlanetNotFound":          5032,
	"ErrCode_PlanetFailure":           5033,
	"ErrCode_AppNotFound":             5034,
	"ErrCode_DefNotFound":             5036,
	"ErrCode_MalformedTx":             5040,
	"ErrCode_TypeNotFound":            5050,
	"ErrCode_TypeNotRegistered":       5051,
	"ErrCode_BadSchema":               5052,
	"ErrCode_DataFailure":             5053,
	"ErrCode_ExportErr":               5054,
	"ErrCode_PinFailed":               5055,
	"ErrCode_PinContextClosed":        5056,
	"ErrCode_CellNotFound":            5058,
	"ErrCode_ProviderErr":             5059,
	"ErrCode_ViolatesAppendOnly":      5100,
	"ErrCode_InsufficientPermissions": 5101,
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{7}
}

type TRS_VisualScaleMode int32

const (
	AutoScale  TRS_VisualScaleMode = 0
	FixedScale TRS_VisualScaleMode = 1
)

var TRS_VisualScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var TRS_VisualScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (TRS_VisualScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{20, 0}
}

type Msg struct {
	// Describes how this Msg should be interpreted
	Op MsgOp `protobuf:"varint,1,opt,name=Op,proto3,enum=arc.MsgOp" json:"Op,omitempty"`
	// ReqID specifies a request context.
	//
	// When a client issues request-side MsgOp (e.g. PinCell, RegisterDefs), ReqID specifies a new and uniquely generated ID that is used in subsequent Msgs.
	// If this msg is a reply to a request, ReqID identifies the originating request op.
	ReqID uint64 `protobuf:"varint,2,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// CellID identifies the cell associated with Msg.Op.
	CellID int64 `protobuf:"varint,4,opt,name=CellID,proto3" json:"CellID,omitempty"`
	// AttrID names the attribute associated with this Msg (used for MsgOp_PushAttr).
	// This value corresponds to AttrSpec.DefID
	AttrID uint32 `protobuf:"varint,6,opt,name=AttrID,proto3" json:"AttrID,omitempty"`
	// SI ("Series Index") specifies how an int64 is interpreted as an attr element index value.
	// See AttrSpec.SeriesType
	SI int64 `protobuf:"varint,8,opt,name=SI,proto3" json:"SI,omitempty"`
	// ValBuf is interpreted according to AttrID
	ValBuf []byte `protobuf:"bytes,10,opt,name=ValBuf,proto3" json:"ValBuf,omitempty"`
	// Flags contains MsgFlags
	Flags MsgFlags `protobuf:"varint,12,opt,name=Flags,proto3,enum=arc.MsgFlags" json:"Flags,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetOp() MsgOp {
	if m != nil {
		return m.Op
	}
	return MsgOp_NoOp
}

func (m *Msg) GetReqID() uint64 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *Msg) GetCellID() int64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *Msg) GetAttrID() uint32 {
	if m != nil {
		return m.AttrID
	}
	return 0
}

func (m *Msg) GetSI() int64 {
	if m != nil {
		return m.SI
	}
	return 0
}

func (m *Msg) GetValBuf() []byte {
	if m != nil {
		return m.ValBuf
	}
	return nil
}

func (m *Msg) GetFlags() MsgFlags {
	if m != nil {
		return m.Flags
	}
	return MsgFlags_None
}

type PlanetEpoch struct {
	// EpochTID is the genesis Tx ID and is only known after this PlanetEpoch is sealed.
	EpochTID []byte `protobuf:"bytes,1,opt,name=EpochTID,proto3" json:"EpochTID,omitempty"`
	// EpochEntries contains the entries that bootstrap this epoch
	EpochEntries []*Msg `protobuf:"bytes,2,rep,name=EpochEntries,proto3" json:"EpochEntries,omitempty"`
	// CommonName is the commonly used name for this planet
	CommonName string `protobuf:"bytes,3,opt,name=CommonName,proto3" json:"CommonName,omitempty"`
}

func (m *PlanetEpoch) Reset()      { *m = PlanetEpoch{} }
func (*PlanetEpoch) ProtoMessage() {}
func (*PlanetEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{1}
}
func (m *PlanetEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanetEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanetEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanetEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanetEpoch.Merge(m, src)
}
func (m *PlanetEpoch) XXX_Size() int {
	return m.Size()
}
func (m *PlanetEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanetEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_PlanetEpoch proto.InternalMessageInfo

func (m *PlanetEpoch) GetEpochTID() []byte {
	if m != nil {
		return m.EpochTID
	}
	return nil
}

func (m *PlanetEpoch) GetEpochEntries() []*Msg {
	if m != nil {
		return m.EpochEntries
	}
	return nil
}

func (m *PlanetEpoch) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

type Login struct {
	// A byte string identifying user who is logging in (lot limited to UTF8)
	// This is typically a username or a persistent UID issued by the device OS when the app is (re)installed.
	UserUID string `protobuf:"bytes,1,opt,name=UserUID,proto3" json:"UserUID,omitempty"`
	// HostAddr is network address of the server known to the client (e.g. IP address, localhost, domain name, etc)
	// Archost uses this to as the host name when serving URLs for the client to consume.
	HostAddr    string `protobuf:"bytes,2,opt,name=HostAddr,proto3" json:"HostAddr,omitempty"`
	DeviceLabel string `protobuf:"bytes,8,opt,name=DeviceLabel,proto3" json:"DeviceLabel,omitempty"`
	DeviceUID   string `protobuf:"bytes,9,opt,name=DeviceUID,proto3" json:"DeviceUID,omitempty"`
}

func (m *Login) Reset()      { *m = Login{} }
func (*Login) ProtoMessage() {}
func (*Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{2}
}
func (m *Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Login.Merge(m, src)
}
func (m *Login) XXX_Size() int {
	return m.Size()
}
func (m *Login) XXX_DiscardUnknown() {
	xxx_messageInfo_Login.DiscardUnknown(m)
}

var xxx_messageInfo_Login proto.InternalMessageInfo

func (m *Login) GetUserUID() string {
	if m != nil {
		return m.UserUID
	}
	return ""
}

func (m *Login) GetHostAddr() string {
	if m != nil {
		return m.HostAddr
	}
	return ""
}

func (m *Login) GetDeviceLabel() string {
	if m != nil {
		return m.DeviceLabel
	}
	return ""
}

func (m *Login) GetDeviceUID() string {
	if m != nil {
		return m.DeviceUID
	}
	return ""
}

// LoginChallenge is sent from host to client in response to a Login message
type LoginChallenge struct {
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *LoginChallenge) Reset()      { *m = LoginChallenge{} }
func (*LoginChallenge) ProtoMessage() {}
func (*LoginChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{3}
}
func (m *LoginChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginChallenge.Merge(m, src)
}
func (m *LoginChallenge) XXX_Size() int {
	return m.Size()
}
func (m *LoginChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_LoginChallenge proto.InternalMessageInfo

func (m *LoginChallenge) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// LoginChallenge is sent from client to host in response to a LoginChallenge message
type LoginResponse struct {
	HashResp []byte `protobuf:"bytes,1,opt,name=HashResp,proto3" json:"HashResp,omitempty"`
}

func (m *LoginResponse) Reset()      { *m = LoginResponse{} }
func (*LoginResponse) ProtoMessage() {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{4}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetHashResp() []byte {
	if m != nil {
		return m.HashResp
	}
	return nil
}

type Symbol struct {
	// A symbol ID is 32 bits and corresponds to a real-world const byte strings.
	ID   uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name []byte `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *Symbol) Reset()      { *m = Symbol{} }
func (*Symbol) ProtoMessage() {}
func (*Symbol) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{5}
}
func (m *Symbol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Symbol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Symbol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Symbol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Symbol.Merge(m, src)
}
func (m *Symbol) XXX_Size() int {
	return m.Size()
}
func (m *Symbol) XXX_DiscardUnknown() {
	xxx_messageInfo_Symbol.DiscardUnknown(m)
}

var xxx_messageInfo_Symbol proto.InternalMessageInfo

func (m *Symbol) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Symbol) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

type RegisterDefs struct {
	Symbols   []*Symbol       `protobuf:"bytes,1,rep,name=Symbols,proto3" json:"Symbols,omitempty"`
	Attrs     []*AttrSpec     `protobuf:"bytes,2,rep,name=Attrs,proto3" json:"Attrs,omitempty"`
	Cells     []*CellSpec     `protobuf:"bytes,3,rep,name=Cells,proto3" json:"Cells,omitempty"`
	Selectors []*ItemSelector `protobuf:"bytes,4,rep,name=Selectors,proto3" json:"Selectors,omitempty"`
}

func (m *RegisterDefs) Reset()      { *m = RegisterDefs{} }
func (*RegisterDefs) ProtoMessage() {}
func (*RegisterDefs) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{6}
}
func (m *RegisterDefs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterDefs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterDefs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterDefs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterDefs.Merge(m, src)
}
func (m *RegisterDefs) XXX_Size() int {
	return m.Size()
}
func (m *RegisterDefs) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterDefs.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterDefs proto.InternalMessageInfo

func (m *RegisterDefs) GetSymbols() []*Symbol {
	if m != nil {
		return m.Symbols
	}
	return nil
}

func (m *RegisterDefs) GetAttrs() []*AttrSpec {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *RegisterDefs) GetCells() []*CellSpec {
	if m != nil {
		return m.Cells
	}
	return nil
}

func (m *RegisterDefs) GetSelectors() []*ItemSelector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

// AttrSpec fully describes a cell attribute, specifying a name, element type, and series element type.
type AttrSpec struct {
	// Composite expression / invocation of this AttrSpec in the form:
	//      "[{SeriesType}]{ElemType}:{AttrName}"
	//
	// This the value is used for Msg.AttrID -- it references an AttrSpec.
	// e.g. "AssetRef", "AssetRef:promo", "[GeoFix]AssetRef:promo-shoots",
	DefID uint32 `protobuf:"varint,1,opt,name=DefID,proto3" json:"DefID,omitempty"`
	// ElemType identifies this attr's element type and has a form like a subdomain:
	//    "({subTypeName}.)*<typeName>"
	//
	// A particular ElemType corresponds to a serializable data type (typically a protobuf or capnp message)
	// Valid chars are [A-Za-z0-9_-] in addition to '.' that separates identifiers..
	//
	// e.g.
	//    "AssetRef",
	//    "GreetingAttr.tutorial_06.hello-world.learn.arcspace.systems",
	ElemType uint32 `protobuf:"varint,3,opt,name=ElemType,proto3" json:"ElemType,omitempty"`
	// SeriesType specifies how to interpret an attr's SeriesIndex ("SI") int64 value associated with each attr element value.
	// If "", this attr is a scalar value (and SI is 0 and ignored).
	//
	// UTC16 and Secs16 are 48.16 fixed signed fractional seconds (one second == 0x10000 ticks), naming a time duration or timestamp.
	// When naming an absolute timestamp, unix UTC is assumed (0x10000 corresponds to 00:00:01, Jan 1 1970 GMT)
	//
	// e.g. "", "UTC16", "Secs16", "Int64", "GeoHash", "NodeID", "TID"
	SeriesType uint32 `protobuf:"varint,5,opt,name=SeriesType,proto3" json:"SeriesType,omitempty"`
	// AttrLabel?  Label?
	//
	// AttrName identifies this attribute, consisting of [A-Za-z0-9_-]
	// Unnamed attrs are common and typically are used to denote a characterizing cell attribute.
	//
	// e.g. "", "en-us", "es-co", "mini", "1440p"
	AttrName uint32 `protobuf:"varint,6,opt,name=AttrName,proto3" json:"AttrName,omitempty"`
}

func (m *AttrSpec) Reset()      { *m = AttrSpec{} }
func (*AttrSpec) ProtoMessage() {}
func (*AttrSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{7}
}
func (m *AttrSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrSpec.Merge(m, src)
}
func (m *AttrSpec) XXX_Size() int {
	return m.Size()
}
func (m *AttrSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AttrSpec proto.InternalMessageInfo

func (m *AttrSpec) GetDefID() uint32 {
	if m != nil {
		return m.DefID
	}
	return 0
}

func (m *AttrSpec) GetElemType() uint32 {
	if m != nil {
		return m.ElemType
	}
	return 0
}

func (m *AttrSpec) GetSeriesType() uint32 {
	if m != nil {
		return m.SeriesType
	}
	return 0
}

func (m *AttrSpec) GetAttrName() uint32 {
	if m != nil {
		return m.AttrName
	}
	return 0
}

// A CellSpec describes this cell's attrs as a child and when this cell is pinned.
// Two cells with matching CellSpec descriptor are the same "type" of cell.
type CellSpec struct {
	// Composite expression / invocation of this CellSpec in the form:
	//      "(CommonAttrs[0],CommonAttrs[1],..)(PinnedAttrs[0],PinnedAttrs[1],..)"
	//
	// e.g. "(CellInfo,ArtistTour)(AssetRef:promoVideo,[UTC16]TourStop:locations)"
	DefID uint32 `protobuf:"varint,1,opt,name=DefID,proto3" json:"DefID,omitempty"`
	// A sequence of attr IDs (attr descriptors) that are this Cell has as both a child and parent.
	CommonAttrs []uint32 `protobuf:"varint,4,rep,packed,name=CommonAttrs,proto3" json:"CommonAttrs,omitempty"`
	// A sequence of attr IDs cells specifying *additional* attrs this Cell has when pinned.
	PinnedAttrs []uint32 `protobuf:"varint,5,rep,packed,name=PinnedAttrs,proto3" json:"PinnedAttrs,omitempty"`
}

func (m *CellSpec) Reset()      { *m = CellSpec{} }
func (*CellSpec) ProtoMessage() {}
func (*CellSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{8}
}
func (m *CellSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellSpec.Merge(m, src)
}
func (m *CellSpec) XXX_Size() int {
	return m.Size()
}
func (m *CellSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CellSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CellSpec proto.InternalMessageInfo

func (m *CellSpec) GetDefID() uint32 {
	if m != nil {
		return m.DefID
	}
	return 0
}

func (m *CellSpec) GetCommonAttrs() []uint32 {
	if m != nil {
		return m.CommonAttrs
	}
	return nil
}

func (m *CellSpec) GetPinnedAttrs() []uint32 {
	if m != nil {
		return m.PinnedAttrs
	}
	return nil
}

// ItemSelector selects / filters a srt of items (e.g. CellSpec or AttrSpec descriptors)
type ItemSelector struct {
	// Composite expression of this ItemSelector in the form:
	//      "(Include[0],Include[1],..)~(Exclude[0],Exclude[1],..)"
	//
	DefID uint32 `protobuf:"varint,1,opt,name=DefID,proto3" json:"DefID,omitempty"`
	// A set of descriptor IDs explicitly included
	Include []uint32 `protobuf:"varint,4,rep,packed,name=Include,proto3" json:"Include,omitempty"`
	// A set of descriptor IDs explicitly excluded
	Exclude []uint32 `protobuf:"varint,5,rep,packed,name=Exclude,proto3" json:"Exclude,omitempty"`
}

func (m *ItemSelector) Reset()      { *m = ItemSelector{} }
func (*ItemSelector) ProtoMessage() {}
func (*ItemSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{9}
}
func (m *ItemSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemSelector.Merge(m, src)
}
func (m *ItemSelector) XXX_Size() int {
	return m.Size()
}
func (m *ItemSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemSelector.DiscardUnknown(m)
}

var xxx_messageInfo_ItemSelector proto.InternalMessageInfo

func (m *ItemSelector) GetDefID() uint32 {
	if m != nil {
		return m.DefID
	}
	return 0
}

func (m *ItemSelector) GetInclude() []uint32 {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *ItemSelector) GetExclude() []uint32 {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type KwArg struct {
	Key    string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Val    string `protobuf:"bytes,5,opt,name=Val,proto3" json:"Val,omitempty"`
	ValBuf []byte `protobuf:"bytes,6,opt,name=ValBuf,proto3" json:"ValBuf,omitempty"`
}

func (m *KwArg) Reset()      { *m = KwArg{} }
func (*KwArg) ProtoMessage() {}
func (*KwArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{10}
}
func (m *KwArg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KwArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KwArg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KwArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KwArg.Merge(m, src)
}
func (m *KwArg) XXX_Size() int {
	return m.Size()
}
func (m *KwArg) XXX_DiscardUnknown() {
	xxx_messageInfo_KwArg.DiscardUnknown(m)
}

var xxx_messageInfo_KwArg proto.InternalMessageInfo

func (m *KwArg) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KwArg) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *KwArg) GetValBuf() []byte {
	if m != nil {
		return m.ValBuf
	}
	return nil
}

type HandleURI struct {
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
}

func (m *HandleURI) Reset()      { *m = HandleURI{} }
func (*HandleURI) ProtoMessage() {}
func (*HandleURI) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{11}
}
func (m *HandleURI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleURI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleURI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleURI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleURI.Merge(m, src)
}
func (m *HandleURI) XXX_Size() int {
	return m.Size()
}
func (m *HandleURI) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleURI.DiscardUnknown(m)
}

var xxx_messageInfo_HandleURI proto.InternalMessageInfo

func (m *HandleURI) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// PinReq is a client request to "pin" a cell, meaning selected attrs and child cells will be pushed to the client.
type PinReq struct {
	// ParentReqID specifies the request ID that pushed PinCell (as a child), providing context.
	// Set to 0 if PinCell and/or PinURI implies that no parent req exists.
	ParentReqID uint64 `protobuf:"varint,1,opt,name=ParentReqID,proto3" json:"ParentReqID,omitempty"`
	// URI specifying the cell to be pinned and whose child cells are to be pushed.
	// Typically: [[arc://]arc-app-uri/]cell-uri..
	PinURI string `protobuf:"bytes,2,opt,name=PinURI,proto3" json:"PinURI,omitempty"`
	// Cell ID to be pinned (or 0 if PinURI does not require a cell ID)
	PinCell int64 `protobuf:"varint,3,opt,name=PinCell,proto3" json:"PinCell,omitempty"`
	// If set, specifies an ItemSelector that filters which attrs of the pinned cell are pushed to the client.
	ParentAttrSelector uint32 `protobuf:"varint,5,opt,name=ParentAttrSelector,proto3" json:"ParentAttrSelector,omitempty"`
	// If set, specifies an ItemSelector that filters which child cells are pushed to the client.
	ChildCellSelector uint32 `protobuf:"varint,6,opt,name=ChildCellSelector,proto3" json:"ChildCellSelector,omitempty"`
	// MaintainSync is set if the request should remain open after initial state is pushed so as to receive state updates.
	MaintainSync bool `protobuf:"varint,8,opt,name=MaintainSync,proto3" json:"MaintainSync,omitempty"`
}

func (m *PinReq) Reset()      { *m = PinReq{} }
func (*PinReq) ProtoMessage() {}
func (*PinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{12}
}
func (m *PinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinReq.Merge(m, src)
}
func (m *PinReq) XXX_Size() int {
	return m.Size()
}
func (m *PinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PinReq.DiscardUnknown(m)
}

var xxx_messageInfo_PinReq proto.InternalMessageInfo

func (m *PinReq) GetParentReqID() uint64 {
	if m != nil {
		return m.ParentReqID
	}
	return 0
}

func (m *PinReq) GetPinURI() string {
	if m != nil {
		return m.PinURI
	}
	return ""
}

func (m *PinReq) GetPinCell() int64 {
	if m != nil {
		return m.PinCell
	}
	return 0
}

func (m *PinReq) GetParentAttrSelector() uint32 {
	if m != nil {
		return m.ParentAttrSelector
	}
	return 0
}

func (m *PinReq) GetChildCellSelector() uint32 {
	if m != nil {
		return m.ChildCellSelector
	}
	return 0
}

func (m *PinReq) GetMaintainSync() bool {
	if m != nil {
		return m.MaintainSync
	}
	return false
}

type AttrRange struct {
	// Specifies what time series index to start and stop reading at (inclusive).
	SI_SeekTo uint64 `protobuf:"varint,24,opt,name=SI_SeekTo,json=SISeekTo,proto3" json:"SI_SeekTo,omitempty"`
	SI_StopAt uint64 `protobuf:"varint,25,opt,name=SI_StopAt,json=SIStopAt,proto3" json:"SI_StopAt,omitempty"`
	// If set, this limits the number of entries returned for each unique from.cell.attr.  (0 denotes unlimited)
	SI_BatchLimit uint64 `protobuf:"varint,27,opt,name=SI_BatchLimit,json=SIBatchLimit,proto3" json:"SI_BatchLimit,omitempty"`
}

func (m *AttrRange) Reset()      { *m = AttrRange{} }
func (*AttrRange) ProtoMessage() {}
func (*AttrRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{13}
}
func (m *AttrRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrRange.Merge(m, src)
}
func (m *AttrRange) XXX_Size() int {
	return m.Size()
}
func (m *AttrRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrRange.DiscardUnknown(m)
}

var xxx_messageInfo_AttrRange proto.InternalMessageInfo

func (m *AttrRange) GetSI_SeekTo() uint64 {
	if m != nil {
		return m.SI_SeekTo
	}
	return 0
}

func (m *AttrRange) GetSI_StopAt() uint64 {
	if m != nil {
		return m.SI_StopAt
	}
	return 0
}

func (m *AttrRange) GetSI_BatchLimit() uint64 {
	if m != nil {
		return m.SI_BatchLimit
	}
	return 0
}

// This is a work in progress
type Txn struct {
	Msgs []*Msg `protobuf:"bytes,1,rep,name=Msgs,proto3" json:"Msgs,omitempty"`
}

func (m *Txn) Reset()      { *m = Txn{} }
func (*Txn) ProtoMessage() {}
func (*Txn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{14}
}
func (m *Txn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Txn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Txn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Txn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Txn.Merge(m, src)
}
func (m *Txn) XXX_Size() int {
	return m.Size()
}
func (m *Txn) XXX_DiscardUnknown() {
	xxx_messageInfo_Txn.DiscardUnknown(m)
}

var xxx_messageInfo_Txn proto.InternalMessageInfo

func (m *Txn) GetMsgs() []*Msg {
	if m != nil {
		return m.Msgs
	}
	return nil
}

type GeoFix struct {
	Model  GeoModel `protobuf:"varint,1,opt,name=Model,proto3,enum=arc.GeoModel" json:"Model,omitempty"`
	Lat    float64  `protobuf:"fixed64,4,opt,name=Lat,proto3" json:"Lat,omitempty"`
	Lng    float64  `protobuf:"fixed64,5,opt,name=Lng,proto3" json:"Lng,omitempty"`
	Alt    float64  `protobuf:"fixed64,6,opt,name=Alt,proto3" json:"Alt,omitempty"`
	AltROU float32  `protobuf:"fixed32,10,opt,name=AltROU,proto3" json:"AltROU,omitempty"`
	PosROU float32  `protobuf:"fixed32,11,opt,name=PosROU,proto3" json:"PosROU,omitempty"`
}

func (m *GeoFix) Reset()      { *m = GeoFix{} }
func (*GeoFix) ProtoMessage() {}
func (*GeoFix) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{15}
}
func (m *GeoFix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoFix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoFix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoFix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoFix.Merge(m, src)
}
func (m *GeoFix) XXX_Size() int {
	return m.Size()
}
func (m *GeoFix) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoFix.DiscardUnknown(m)
}

var xxx_messageInfo_GeoFix proto.InternalMessageInfo

func (m *GeoFix) GetModel() GeoModel {
	if m != nil {
		return m.Model
	}
	return GeoModel_Sphere
}

func (m *GeoFix) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoFix) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *GeoFix) GetAlt() float64 {
	if m != nil {
		return m.Alt
	}
	return 0
}

func (m *GeoFix) GetAltROU() float32 {
	if m != nil {
		return m.AltROU
	}
	return 0
}

func (m *GeoFix) GetPosROU() float32 {
	if m != nil {
		return m.PosROU
	}
	return 0
}

type AssetRef struct {
	Label      string    `protobuf:"bytes,1,opt,name=Label,proto3" json:"Label,omitempty"`
	MediaType  string    `protobuf:"bytes,3,opt,name=MediaType,proto3" json:"MediaType,omitempty"`
	Scheme     URIScheme `protobuf:"varint,5,opt,name=Scheme,proto3,enum=arc.URIScheme" json:"Scheme,omitempty"`
	URI        string    `protobuf:"bytes,6,opt,name=URI,proto3" json:"URI,omitempty"`
	PixWidth   int32     `protobuf:"varint,10,opt,name=PixWidth,proto3" json:"PixWidth,omitempty"`
	PixHeight  int32     `protobuf:"varint,11,opt,name=PixHeight,proto3" json:"PixHeight,omitempty"`
	PhysWidth  float32   `protobuf:"fixed32,12,opt,name=PhysWidth,proto3" json:"PhysWidth,omitempty"`
	PhysHeight float32   `protobuf:"fixed32,13,opt,name=PhysHeight,proto3" json:"PhysHeight,omitempty"`
}

func (m *AssetRef) Reset()      { *m = AssetRef{} }
func (*AssetRef) ProtoMessage() {}
func (*AssetRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{16}
}
func (m *AssetRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetRef.Merge(m, src)
}
func (m *AssetRef) XXX_Size() int {
	return m.Size()
}
func (m *AssetRef) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetRef.DiscardUnknown(m)
}

var xxx_messageInfo_AssetRef proto.InternalMessageInfo

func (m *AssetRef) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *AssetRef) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

func (m *AssetRef) GetScheme() URIScheme {
	if m != nil {
		return m.Scheme
	}
	return URIScheme_Any
}

func (m *AssetRef) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *AssetRef) GetPixWidth() int32 {
	if m != nil {
		return m.PixWidth
	}
	return 0
}

func (m *AssetRef) GetPixHeight() int32 {
	if m != nil {
		return m.PixHeight
	}
	return 0
}

func (m *AssetRef) GetPhysWidth() float32 {
	if m != nil {
		return m.PhysWidth
	}
	return 0
}

func (m *AssetRef) GetPhysHeight() float32 {
	if m != nil {
		return m.PhysHeight
	}
	return 0
}

// Content is an extensible content wrapper, offering an optional accompanying MIME type.
type Content struct {
	ContentData   []byte  `protobuf:"bytes,3,opt,name=ContentData,proto3" json:"ContentData,omitempty"`
	ContentType   string  `protobuf:"bytes,4,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	ContentTypeID int64   `protobuf:"varint,5,opt,name=ContentTypeID,proto3" json:"ContentTypeID,omitempty"`
	LinksCellID   int64   `protobuf:"varint,10,opt,name=LinksCellID,proto3" json:"LinksCellID,omitempty"`
	Location      *GeoFix `protobuf:"bytes,11,opt,name=Location,proto3" json:"Location,omitempty"`
}

func (m *Content) Reset()      { *m = Content{} }
func (*Content) ProtoMessage() {}
func (*Content) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{17}
}
func (m *Content) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Content) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Content.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Content) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Content.Merge(m, src)
}
func (m *Content) XXX_Size() int {
	return m.Size()
}
func (m *Content) XXX_DiscardUnknown() {
	xxx_messageInfo_Content.DiscardUnknown(m)
}

var xxx_messageInfo_Content proto.InternalMessageInfo

func (m *Content) GetContentData() []byte {
	if m != nil {
		return m.ContentData
	}
	return nil
}

func (m *Content) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *Content) GetContentTypeID() int64 {
	if m != nil {
		return m.ContentTypeID
	}
	return 0
}

func (m *Content) GetLinksCellID() int64 {
	if m != nil {
		return m.LinksCellID
	}
	return 0
}

func (m *Content) GetLocation() *GeoFix {
	if m != nil {
		return m.Location
	}
	return nil
}

type CryptoKey struct {
	CryptoKitID CryptoKitID `protobuf:"varint,1,opt,name=CryptoKitID,proto3,enum=arc.CryptoKitID" json:"CryptoKitID,omitempty"`
	KeyBytes    []byte      `protobuf:"bytes,4,opt,name=KeyBytes,proto3" json:"KeyBytes,omitempty"`
}

func (m *CryptoKey) Reset()      { *m = CryptoKey{} }
func (*CryptoKey) ProtoMessage() {}
func (*CryptoKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{18}
}
func (m *CryptoKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoKey.Merge(m, src)
}
func (m *CryptoKey) XXX_Size() int {
	return m.Size()
}
func (m *CryptoKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoKey.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoKey proto.InternalMessageInfo

func (m *CryptoKey) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKit_Nil
}

func (m *CryptoKey) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

// CellInfo is the standard attribute for a cell that can be listed or otherwise presented in a UI to the user.
type CellInfo struct {
	// CellDefID references a CellSpec definition, fully describing this cell's common and pinned attrs.
	// This typically corresponds 1:1 to a cell's purpose / function.
	// See message CellSpec
	CellDefID  uint32    `protobuf:"varint,1,opt,name=CellDefID,proto3" json:"CellDefID,omitempty"`
	Title      string    `protobuf:"bytes,4,opt,name=Title,proto3" json:"Title,omitempty"`
	Subtitle   string    `protobuf:"bytes,5,opt,name=Subtitle,proto3" json:"Subtitle,omitempty"`
	About      string    `protobuf:"bytes,6,opt,name=About,proto3" json:"About,omitempty"`
	Glyph      *AssetRef `protobuf:"bytes,10,opt,name=Glyph,proto3" json:"Glyph,omitempty"`
	GlyphLarge *AssetRef `protobuf:"bytes,12,opt,name=GlyphLarge,proto3" json:"GlyphLarge,omitempty"`
	Link       *AssetRef `protobuf:"bytes,14,opt,name=Link,proto3" json:"Link,omitempty"`
	Created    int64     `protobuf:"varint,20,opt,name=Created,proto3" json:"Created,omitempty"`
	Modified   int64     `protobuf:"varint,21,opt,name=Modified,proto3" json:"Modified,omitempty"`
}

func (m *CellInfo) Reset()      { *m = CellInfo{} }
func (*CellInfo) ProtoMessage() {}
func (*CellInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{19}
}
func (m *CellInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellInfo.Merge(m, src)
}
func (m *CellInfo) XXX_Size() int {
	return m.Size()
}
func (m *CellInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CellInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CellInfo proto.InternalMessageInfo

func (m *CellInfo) GetCellDefID() uint32 {
	if m != nil {
		return m.CellDefID
	}
	return 0
}

func (m *CellInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CellInfo) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *CellInfo) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *CellInfo) GetGlyph() *AssetRef {
	if m != nil {
		return m.Glyph
	}
	return nil
}

func (m *CellInfo) GetGlyphLarge() *AssetRef {
	if m != nil {
		return m.GlyphLarge
	}
	return nil
}

func (m *CellInfo) GetLink() *AssetRef {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *CellInfo) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CellInfo) GetModified() int64 {
	if m != nil {
		return m.Modified
	}
	return 0
}

type TRS struct {
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Specifies how scale dynamically changes based on observer position.
	ScaleMode TRS_VisualScaleMode `protobuf:"varint,50,opt,name=ScaleMode,proto3,enum=arc.TRS_VisualScaleMode" json:"ScaleMode,omitempty"`
	// Scale1..3 express the scale of this placement.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this placement using Euler angles.
	Rotate1 float32 `protobuf:"fixed32,61,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2 float32 `protobuf:"fixed32,62,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3 float32 `protobuf:"fixed32,63,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
}

func (m *TRS) Reset()      { *m = TRS{} }
func (*TRS) ProtoMessage() {}
func (*TRS) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{20}
}
func (m *TRS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TRS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TRS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TRS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TRS.Merge(m, src)
}
func (m *TRS) XXX_Size() int {
	return m.Size()
}
func (m *TRS) XXX_DiscardUnknown() {
	xxx_messageInfo_TRS.DiscardUnknown(m)
}

var xxx_messageInfo_TRS proto.InternalMessageInfo

func (m *TRS) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *TRS) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *TRS) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *TRS) GetScaleMode() TRS_VisualScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return AutoScale
}

func (m *TRS) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *TRS) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *TRS) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *TRS) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *TRS) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *TRS) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

type FeedParams struct {
	UpdateIntervalMin float32 `protobuf:"fixed32,2,opt,name=UpdateIntervalMin,proto3" json:"UpdateIntervalMin,omitempty"`
	UpdateIntervalMax float32 `protobuf:"fixed32,3,opt,name=UpdateIntervalMax,proto3" json:"UpdateIntervalMax,omitempty"`
}

func (m *FeedParams) Reset()      { *m = FeedParams{} }
func (*FeedParams) ProtoMessage() {}
func (*FeedParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{21}
}
func (m *FeedParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedParams.Merge(m, src)
}
func (m *FeedParams) XXX_Size() int {
	return m.Size()
}
func (m *FeedParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedParams.DiscardUnknown(m)
}

var xxx_messageInfo_FeedParams proto.InternalMessageInfo

func (m *FeedParams) GetUpdateIntervalMin() float32 {
	if m != nil {
		return m.UpdateIntervalMin
	}
	return 0
}

func (m *FeedParams) GetUpdateIntervalMax() float32 {
	if m != nil {
		return m.UpdateIntervalMax
	}
	return 0
}

type DataSegment struct {
	ByteOfs    uint64 `protobuf:"varint,5,opt,name=ByteOfs,proto3" json:"ByteOfs,omitempty"`
	ByteSz     uint64 `protobuf:"varint,6,opt,name=ByteSz,proto3" json:"ByteSz,omitempty"`
	InlineData []byte `protobuf:"bytes,7,opt,name=InlineData,proto3" json:"InlineData,omitempty"`
	StreamURI  string `protobuf:"bytes,9,opt,name=StreamURI,proto3" json:"StreamURI,omitempty"`
	BlobID     int64  `protobuf:"varint,10,opt,name=BlobID,proto3" json:"BlobID,omitempty"`
}

func (m *DataSegment) Reset()      { *m = DataSegment{} }
func (*DataSegment) ProtoMessage() {}
func (*DataSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{22}
}
func (m *DataSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSegment.Merge(m, src)
}
func (m *DataSegment) XXX_Size() int {
	return m.Size()
}
func (m *DataSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSegment.DiscardUnknown(m)
}

var xxx_messageInfo_DataSegment proto.InternalMessageInfo

func (m *DataSegment) GetByteOfs() uint64 {
	if m != nil {
		return m.ByteOfs
	}
	return 0
}

func (m *DataSegment) GetByteSz() uint64 {
	if m != nil {
		return m.ByteSz
	}
	return 0
}

func (m *DataSegment) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

func (m *DataSegment) GetStreamURI() string {
	if m != nil {
		return m.StreamURI
	}
	return ""
}

func (m *DataSegment) GetBlobID() int64 {
	if m != nil {
		return m.BlobID
	}
	return 0
}

// Err wraps errors and is typically used in conjunction with MsgOps.ReqCancel
type Err struct {
	// ErrCode specifying how/why the request was canceled.
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=arc.ErrCode" json:"Code,omitempty"`
	// Msg is a human-readable info string that offers amplifying info about the given error.
	Msg string `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *Err) Reset()      { *m = Err{} }
func (*Err) ProtoMessage() {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{23}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("arc.Const", Const_name, Const_value)
	proto.RegisterEnum("arc.ConstSymbol", ConstSymbol_name, ConstSymbol_value)
	proto.RegisterEnum("arc.MsgOp", MsgOp_name, MsgOp_value)
	proto.RegisterEnum("arc.MsgFlags", MsgFlags_name, MsgFlags_value)
	proto.RegisterEnum("arc.GeoModel", GeoModel_name, GeoModel_value)
	proto.RegisterEnum("arc.URIScheme", URIScheme_name, URIScheme_value)
	proto.RegisterEnum("arc.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("arc.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("arc.TRS_VisualScaleMode", TRS_VisualScaleMode_name, TRS_VisualScaleMode_value)
	proto.RegisterType((*Msg)(nil), "arc.Msg")
	proto.RegisterType((*PlanetEpoch)(nil), "arc.PlanetEpoch")
	proto.RegisterType((*Login)(nil), "arc.Login")
	proto.RegisterType((*LoginChallenge)(nil), "arc.LoginChallenge")
	proto.RegisterType((*LoginResponse)(nil), "arc.LoginResponse")
	proto.RegisterType((*Symbol)(nil), "arc.Symbol")
	proto.RegisterType((*RegisterDefs)(nil), "arc.RegisterDefs")
	proto.RegisterType((*AttrSpec)(nil), "arc.AttrSpec")
	proto.RegisterType((*CellSpec)(nil), "arc.CellSpec")
	proto.RegisterType((*ItemSelector)(nil), "arc.ItemSelector")
	proto.RegisterType((*KwArg)(nil), "arc.KwArg")
	proto.RegisterType((*HandleURI)(nil), "arc.HandleURI")
	proto.RegisterType((*PinReq)(nil), "arc.PinReq")
	proto.RegisterType((*AttrRange)(nil), "arc.AttrRange")
	proto.RegisterType((*Txn)(nil), "arc.Txn")
	proto.RegisterType((*GeoFix)(nil), "arc.GeoFix")
	proto.RegisterType((*AssetRef)(nil), "arc.AssetRef")
	proto.RegisterType((*Content)(nil), "arc.Content")
	proto.RegisterType((*CryptoKey)(nil), "arc.CryptoKey")
	proto.RegisterType((*CellInfo)(nil), "arc.CellInfo")
	proto.RegisterType((*TRS)(nil), "arc.TRS")
	proto.RegisterType((*FeedParams)(nil), "arc.FeedParams")
	proto.RegisterType((*DataSegment)(nil), "arc.DataSegment")
	proto.RegisterType((*Err)(nil), "arc.Err")
}

func init() { proto.RegisterFile("apis/arc/arc.proto", fileDescriptor_e4a0eb974cf54c93) }

var fileDescriptor_e4a0eb974cf54c93 = []byte{
	// 2419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x58, 0xcd, 0x8f, 0x23, 0x47,
	0x15, 0x9f, 0xf6, 0x7c, 0xd9, 0x6f, 0x3e, 0xb6, 0xb7, 0x32, 0xb3, 0xe9, 0xdd, 0x6c, 0x9c, 0x89,
	0x93, 0xe0, 0x61, 0x12, 0x36, 0x59, 0x4f, 0x82, 0x94, 0x03, 0x44, 0x1e, 0x7b, 0x66, 0xd7, 0xca,
	0x7c, 0x58, 0xd5, 0x9e, 0x25, 0x12, 0x87, 0x51, 0xad, 0xbb, 0xc6, 0x2e, 0xd2, 0xae, 0xee, 0xed,
	0x2e, 0x6f, 0xec, 0x48, 0x11, 0x39, 0x70, 0xe0, 0x2b, 0x21, 0x80, 0xe0, 0x44, 0xb8, 0x20, 0x41,
	0x88, 0x38, 0xe4, 0x00, 0x17, 0x3e, 0x02, 0x82, 0x4b, 0xc4, 0x29, 0xc7, 0x9c, 0x10, 0x99, 0x48,
	0x88, 0x03, 0x48, 0xfb, 0x17, 0x20, 0xf4, 0xaa, 0xba, 0xdb, 0xed, 0x9d, 0xcd, 0x61, 0xa4, 0xfa,
	0xfd, 0x7e, 0xaf, 0x3e, 0xde, 0xab, 0xf7, 0x5e, 0x97, 0x07, 0x08, 0x0b, 0x45, 0xfc, 0x2c, 0x8b,
	0xba, 0xf8, 0x77, 0x2d, 0x8c, 0x02, 0x15, 0x90, 0x59, 0x16, 0x75, 0x2b, 0xbf, 0xb5, 0x60, 0xf6,
	0x20, 0xee, 0x91, 0x2b, 0x50, 0x38, 0x0a, 0x1d, 0x6b, 0xc3, 0xda, 0x5c, 0xad, 0xc1, 0x35, 0x34,
	0x3a, 0x88, 0x7b, 0x47, 0x21, 0x2d, 0x1c, 0x85, 0x64, 0x0d, 0xe6, 0x29, 0xbf, 0xd3, 0x6a, 0x3a,
	0x85, 0x0d, 0x6b, 0x73, 0x8e, 0x1a, 0x40, 0x2e, 0xc1, 0x42, 0x83, 0xfb, 0x7e, 0xab, 0xe9, 0xcc,
	0x6d, 0x58, 0x9b, 0xb3, 0x34, 0x41, 0xc8, 0xd7, 0x95, 0x8a, 0x5a, 0x4d, 0x67, 0x61, 0xc3, 0xda,
	0x5c, 0xa1, 0x09, 0x22, 0xab, 0x50, 0x70, 0x5b, 0x4e, 0x51, 0xdb, 0x16, 0xdc, 0x16, 0xda, 0xdd,
	0x62, 0xfe, 0xce, 0xf0, 0xd4, 0x81, 0x0d, 0x6b, 0x73, 0x99, 0x26, 0x88, 0x3c, 0x01, 0xf3, 0x7b,
	0x3e, 0xeb, 0xc5, 0xce, 0xb2, 0x3e, 0xcc, 0x4a, 0x7a, 0x18, 0x4d, 0x52, 0xa3, 0x55, 0x5e, 0x83,
	0xa5, 0xb6, 0xcf, 0x24, 0x57, 0xbb, 0x61, 0xd0, 0xed, 0x93, 0x2b, 0x50, 0xd4, 0x83, 0x4e, 0xab,
	0xa9, 0x7d, 0x58, 0xa6, 0x19, 0x26, 0xcf, 0xc0, 0xb2, 0x1e, 0xef, 0x4a, 0x15, 0x09, 0x1e, 0x3b,
	0x85, 0x8d, 0xd9, 0xcd, 0xa5, 0x5a, 0x31, 0x5d, 0x96, 0x4e, 0xa9, 0xa4, 0x0c, 0xd0, 0x08, 0x06,
	0x83, 0x40, 0x1e, 0xb2, 0x01, 0x77, 0x66, 0x37, 0xac, 0xcd, 0x12, 0xcd, 0x31, 0x95, 0x37, 0x60,
	0x7e, 0x3f, 0xe8, 0x09, 0x49, 0x1c, 0x58, 0x3c, 0x8e, 0x79, 0x74, 0x9c, 0xec, 0x58, 0xa2, 0x29,
	0xc4, 0xc3, 0xdc, 0x0c, 0x62, 0x55, 0xf7, 0xbc, 0x48, 0x47, 0xac, 0x44, 0x33, 0x4c, 0x36, 0x60,
	0xa9, 0xc9, 0xef, 0x8a, 0x2e, 0xdf, 0x67, 0xb7, 0xb9, 0xaf, 0xa3, 0x51, 0xa2, 0x79, 0x8a, 0x5c,
	0x85, 0x92, 0x81, 0xb8, 0x72, 0x49, 0xeb, 0x13, 0xa2, 0xf2, 0x24, 0xac, 0xea, 0xed, 0x1b, 0x7d,
	0xe6, 0xfb, 0x5c, 0xf6, 0x38, 0x21, 0x30, 0x77, 0x93, 0xc5, 0xfd, 0xc4, 0x6d, 0x3d, 0xae, 0x3c,
	0x0d, 0x2b, 0xda, 0x8a, 0xf2, 0x38, 0x0c, 0x64, 0xcc, 0xf5, 0x91, 0x58, 0xdc, 0x47, 0x9c, 0xc6,
	0x27, 0xc5, 0x95, 0x67, 0x60, 0xc1, 0x1d, 0x0f, 0x6e, 0x07, 0x3e, 0xde, 0x50, 0xe2, 0xcd, 0x0a,
	0x2d, 0xb4, 0x9a, 0xb8, 0xb4, 0x8e, 0x42, 0xc1, 0x2c, 0xad, 0xfd, 0xff, 0xc0, 0x82, 0x65, 0xca,
	0x7b, 0x22, 0x56, 0x3c, 0x6a, 0xf2, 0xd3, 0x98, 0x3c, 0x05, 0x8b, 0x66, 0x7a, 0xec, 0x58, 0x3a,
	0xb2, 0x4b, 0x3a, 0xb2, 0x86, 0xa3, 0xa9, 0x86, 0xb7, 0x8a, 0x79, 0x90, 0x86, 0xdf, 0xdc, 0x2a,
	0x32, 0x6e, 0xc8, 0xbb, 0xd4, 0x68, 0x68, 0x84, 0x49, 0x14, 0x3b, 0xb3, 0x39, 0x23, 0x64, 0x8c,
	0x91, 0xd6, 0xc8, 0xb3, 0x50, 0x72, 0xb9, 0xcf, 0xbb, 0x2a, 0x88, 0x62, 0x67, 0x4e, 0x1b, 0x5e,
	0xd4, 0x86, 0x2d, 0xc5, 0x07, 0xa9, 0x42, 0x27, 0x36, 0x95, 0x11, 0x14, 0xd3, 0x8d, 0x30, 0x95,
	0x9b, 0xfc, 0x34, 0xf3, 0xd2, 0x00, 0x9d, 0x3e, 0x3e, 0x1f, 0x74, 0xc6, 0xa1, 0xb9, 0xf2, 0x15,
	0x9a, 0x61, 0x4c, 0x08, 0x97, 0x63, 0x6a, 0x68, 0x75, 0x5e, 0xab, 0x39, 0x06, 0xe7, 0xe2, 0xea,
	0x3a, 0x50, 0x26, 0xe1, 0x33, 0x5c, 0xf1, 0xa0, 0x98, 0x9e, 0xfe, 0x73, 0x76, 0xde, 0x80, 0x25,
	0x93, 0x5c, 0x26, 0x38, 0xe8, 0xce, 0x0a, 0xcd, 0x53, 0x68, 0xd1, 0x16, 0x52, 0x72, 0xcf, 0x58,
	0xcc, 0x1b, 0x8b, 0x1c, 0x55, 0x79, 0x05, 0x96, 0xf3, 0xae, 0x7f, 0xce, 0x4e, 0x0e, 0x2c, 0xb6,
	0x64, 0xd7, 0x1f, 0x7a, 0x3c, 0xd9, 0x25, 0x85, 0xa8, 0xec, 0x8e, 0x8c, 0x62, 0x56, 0x4f, 0x61,
	0xa5, 0x01, 0xf3, 0x2f, 0xbf, 0x56, 0x8f, 0x7a, 0xc4, 0x86, 0xd9, 0x97, 0xf9, 0x38, 0x49, 0x74,
	0x1c, 0x22, 0x73, 0x8b, 0xf9, 0x3a, 0x1e, 0x25, 0x8a, 0xc3, 0x5c, 0x3d, 0x2f, 0xe4, 0xeb, 0xb9,
	0xf2, 0x28, 0x94, 0x6e, 0x32, 0xe9, 0xf9, 0xfc, 0x98, 0xb6, 0x70, 0xda, 0x31, 0x6d, 0xa5, 0x0b,
	0x1d, 0xd3, 0x56, 0xe5, 0x1f, 0x16, 0x2c, 0xb4, 0x31, 0x55, 0xef, 0x68, 0x57, 0x59, 0xc4, 0xa5,
	0x32, 0xdd, 0xc6, 0xd2, 0xdd, 0x26, 0x4f, 0xe1, 0x1e, 0x6d, 0x21, 0x71, 0x05, 0x53, 0x58, 0x09,
	0x42, 0x17, 0xda, 0x42, 0x62, 0xac, 0xf5, 0xfd, 0xcd, 0xd2, 0x14, 0x92, 0x6b, 0x40, 0xcc, 0x02,
	0x3a, 0x05, 0x92, 0x10, 0x25, 0xd7, 0xf8, 0x00, 0x85, 0x3c, 0x03, 0x17, 0x1b, 0x7d, 0xe1, 0x7b,
	0xfa, 0xde, 0x52, 0x73, 0x73, 0xaf, 0xe7, 0x05, 0x52, 0x81, 0xe5, 0x03, 0x26, 0xa4, 0x62, 0x42,
	0xba, 0x63, 0xd9, 0xd5, 0xf5, 0x5c, 0xa4, 0x53, 0x5c, 0xe5, 0x1b, 0x50, 0xc2, 0x1d, 0x28, 0xc3,
	0x6a, 0x7d, 0x04, 0x4a, 0x6e, 0xeb, 0xc4, 0xe5, 0xfc, 0xd5, 0x4e, 0xe0, 0x38, 0xda, 0xc1, 0xa2,
	0xdb, 0x32, 0x38, 0x15, 0x55, 0x10, 0xd6, 0x95, 0x73, 0x39, 0x13, 0x35, 0x26, 0x4f, 0xc0, 0x8a,
	0xdb, 0x3a, 0xd9, 0x61, 0xaa, 0xdb, 0xdf, 0x17, 0x03, 0xa1, 0x9c, 0x47, 0xb4, 0xc1, 0xb2, 0xdb,
	0x9a, 0x70, 0x95, 0x27, 0x60, 0xb6, 0x33, 0x92, 0xe4, 0x2a, 0xcc, 0x1d, 0xc4, 0xbd, 0xb4, 0x20,
	0x27, 0xad, 0x4e, 0xb3, 0x95, 0x1f, 0x5b, 0xb0, 0x70, 0x83, 0x07, 0x7b, 0x62, 0x84, 0x05, 0x77,
	0x10, 0x78, 0xdc, 0x4f, 0x1a, 0xbf, 0x29, 0xb8, 0x1b, 0x3c, 0xd0, 0x24, 0x35, 0x1a, 0xde, 0xd9,
	0x3e, 0x53, 0xba, 0xcb, 0x5b, 0x14, 0x87, 0x9a, 0x91, 0x3d, 0x1d, 0x45, 0x64, 0xa4, 0x4e, 0x90,
	0xba, 0xaf, 0x74, 0xa0, 0x2c, 0x8a, 0x43, 0xfd, 0x19, 0xf0, 0x15, 0x3d, 0x3a, 0xd6, 0xed, 0xbd,
	0x40, 0x13, 0xa4, 0xaf, 0x30, 0x88, 0x91, 0x5f, 0x32, 0xbc, 0x41, 0x95, 0x7b, 0x16, 0x14, 0xeb,
	0x71, 0xcc, 0x15, 0xe5, 0xa7, 0x98, 0xc2, 0xa6, 0x41, 0x9a, 0x44, 0x99, 0xcf, 0x5a, 0xe3, 0x01,
	0xf7, 0x04, 0xcb, 0xea, 0xb4, 0x44, 0x27, 0x04, 0xf9, 0x02, 0x2c, 0xb8, 0xdd, 0x3e, 0x1f, 0x98,
	0x22, 0x5d, 0xad, 0xad, 0x6a, 0x67, 0x8e, 0x69, 0xcb, 0xb0, 0x34, 0x51, 0xd3, 0x14, 0x5c, 0xc8,
	0x52, 0x10, 0x4b, 0xb8, 0x2d, 0x46, 0x5f, 0x13, 0x9e, 0xea, 0xeb, 0xc3, 0xce, 0xd3, 0x0c, 0xe3,
	0x9e, 0x6d, 0x31, 0xba, 0xc9, 0x45, 0xaf, 0xaf, 0xf4, 0x89, 0xe7, 0xe9, 0x84, 0xd0, 0x6a, 0x7f,
	0x1c, 0x9b, 0xa9, 0xcb, 0xda, 0x9f, 0x09, 0x81, 0xad, 0x03, 0x41, 0x32, 0x79, 0x45, 0xcb, 0x39,
	0xa6, 0xf2, 0xa1, 0x05, 0x8b, 0x8d, 0x40, 0x2a, 0x2e, 0x95, 0x69, 0x04, 0x7a, 0xd8, 0x64, 0x8a,
	0x69, 0xef, 0x96, 0x69, 0x9e, 0xca, 0x59, 0x68, 0xff, 0xe7, 0xcc, 0xa7, 0x23, 0x47, 0x91, 0x27,
	0x61, 0x25, 0x07, 0x5b, 0x4d, 0x1d, 0x88, 0x59, 0x3a, 0x4d, 0xe2, 0x3a, 0xfb, 0x42, 0xbe, 0x1a,
	0x27, 0x1f, 0x6f, 0xd0, 0x36, 0x79, 0x8a, 0x54, 0xa1, 0xb8, 0x1f, 0x74, 0x99, 0x12, 0x81, 0xd4,
	0x2e, 0xa7, 0x3d, 0xdd, 0x24, 0x0d, 0xcd, 0xc4, 0xca, 0xd7, 0xa1, 0xd4, 0x88, 0xc6, 0xa1, 0x0a,
	0xb0, 0x23, 0xd4, 0x60, 0x29, 0x01, 0x42, 0x25, 0xd5, 0xbb, 0x5a, 0xb3, 0x4d, 0x0b, 0x9f, 0xf0,
	0x34, 0x6f, 0x84, 0x91, 0x7f, 0x99, 0x8f, 0x77, 0xc6, 0x8a, 0xc7, 0xda, 0xa1, 0x65, 0x9a, 0xe1,
	0xca, 0xbb, 0x05, 0xd3, 0x3d, 0x5b, 0xf2, 0x34, 0xc0, 0x40, 0xe3, 0x38, 0xdf, 0xd7, 0x26, 0x04,
	0xa6, 0x4b, 0x47, 0x28, 0x3f, 0x0d, 0x8a, 0x01, 0xb8, 0xb8, 0x3b, 0xbc, 0xad, 0xb4, 0x60, 0xfa,
	0x54, 0x86, 0x71, 0x46, 0xfd, 0x76, 0x30, 0x54, 0x49, 0x1a, 0x18, 0x80, 0xe5, 0x70, 0xc3, 0x1f,
	0x87, 0x26, 0x0b, 0xb2, 0x8f, 0x54, 0x92, 0x94, 0xd4, 0x68, 0xe4, 0x4b, 0x00, 0x7a, 0xb0, 0xcf,
	0xa2, 0x1e, 0xd7, 0x97, 0x7e, 0xce, 0x32, 0x67, 0x40, 0x1e, 0x87, 0x39, 0x8c, 0xad, 0xb3, 0xfa,
	0x20, 0x43, 0x2d, 0x61, 0xf7, 0x6a, 0x44, 0x9c, 0x29, 0xee, 0x39, 0x6b, 0xa6, 0x7b, 0x25, 0x10,
	0x5d, 0x38, 0x08, 0x3c, 0x71, 0x2a, 0xb8, 0xe7, 0xac, 0x6b, 0x29, 0xc3, 0x95, 0xdf, 0x15, 0x60,
	0xb6, 0x43, 0x5d, 0xfc, 0x6a, 0xbf, 0x72, 0xdd, 0xf9, 0xa2, 0xae, 0xbc, 0xc2, 0x2b, 0xd7, 0x35,
	0xae, 0x39, 0x5b, 0x09, 0xae, 0x69, 0xbc, 0xed, 0x3c, 0x9d, 0xe0, 0x6d, 0xf2, 0x65, 0x28, 0xb9,
	0x5d, 0xe6, 0x73, 0x2c, 0x6e, 0xa7, 0xa6, 0x6f, 0xc9, 0xd1, 0xa7, 0xea, 0x50, 0xf7, 0xda, 0x2d,
	0x11, 0x0f, 0x99, 0x9f, 0xe9, 0x74, 0x62, 0x8a, 0x85, 0xab, 0xc1, 0x75, 0x67, 0xdb, 0x14, 0xae,
	0x41, 0x19, 0x5f, 0x73, 0x9e, 0xcf, 0xf1, 0xb5, 0x8c, 0xdf, 0x76, 0x5e, 0xc8, 0xf1, 0xdb, 0xe8,
	0x2d, 0x0d, 0x14, 0x53, 0xfc, 0xba, 0xf3, 0x15, 0x2d, 0xa4, 0x70, 0xa2, 0xd4, 0x9c, 0xaf, 0xe6,
	0x95, 0xda, 0x44, 0xd9, 0x76, 0x5e, 0xca, 0x2b, 0xdb, 0x95, 0xe7, 0xe0, 0xc2, 0x7d, 0x67, 0x26,
	0x2b, 0x50, 0xaa, 0x0f, 0x55, 0xa0, 0x09, 0x7b, 0x86, 0xac, 0x02, 0xec, 0x89, 0x11, 0xf7, 0x0c,
	0xb6, 0x2a, 0x7d, 0x80, 0x3d, 0xce, 0xbd, 0x36, 0x8b, 0xd8, 0x20, 0xc6, 0x7e, 0x7f, 0x1c, 0x7a,
	0x4c, 0xf1, 0x96, 0x54, 0x3c, 0xba, 0xcb, 0xfc, 0x03, 0x21, 0xf5, 0xc7, 0xa5, 0x40, 0xcf, 0x0b,
	0x0f, 0xb0, 0x66, 0x23, 0x5d, 0xab, 0xe7, 0xad, 0xd9, 0xa8, 0xf2, 0x13, 0x0b, 0x96, 0xb0, 0x74,
	0x5d, 0xde, 0x1b, 0x60, 0x8d, 0x3b, 0xb0, 0x88, 0xa9, 0x7d, 0x74, 0x1a, 0xeb, 0x7c, 0x9c, 0xa3,
	0x29, 0xc4, 0x58, 0xe1, 0xd0, 0x7d, 0x5d, 0xe7, 0xe3, 0x1c, 0x4d, 0x10, 0x76, 0x90, 0x96, 0xf4,
	0x85, 0xe4, 0xba, 0x29, 0x2c, 0xea, 0x0a, 0xc9, 0x31, 0x58, 0x16, 0xae, 0x8a, 0x38, 0x1b, 0x60,
	0x47, 0x4b, 0x1e, 0x8b, 0x19, 0xa1, 0x57, 0xf5, 0x83, 0xdb, 0x59, 0x91, 0x27, 0xa8, 0xf2, 0x22,
	0xcc, 0xee, 0x46, 0xf8, 0x16, 0x9d, 0x6b, 0x60, 0x0e, 0x98, 0x4a, 0x5d, 0xd6, 0x39, 0xb0, 0x1b,
	0x45, 0xc8, 0x51, 0xad, 0x60, 0xab, 0x3c, 0x88, 0x7b, 0xc9, 0xb7, 0x16, 0x87, 0x5b, 0xdf, 0xb2,
	0x60, 0xbe, 0x11, 0xc8, 0x58, 0x61, 0x58, 0xf5, 0xe0, 0x04, 0x5f, 0x81, 0xf6, 0x0c, 0xb9, 0x04,
	0xc4, 0xe0, 0x4e, 0xab, 0xb9, 0x23, 0x24, 0x8b, 0xc6, 0xfb, 0x5c, 0xda, 0x1b, 0x53, 0xbc, 0xab,
	0x22, 0x21, 0x7b, 0xc8, 0x3f, 0x4f, 0x1c, 0x58, 0xcb, 0xf8, 0x8e, 0x18, 0xf0, 0x58, 0xb1, 0x41,
	0xe8, 0xbe, 0x6e, 0x17, 0xc9, 0xe3, 0x70, 0x35, 0x5b, 0x99, 0x0d, 0x7d, 0x75, 0x23, 0x0a, 0xbb,
	0x2e, 0x8f, 0xf0, 0x09, 0xdc, 0x0e, 0x22, 0x65, 0x7f, 0xb4, 0xb9, 0xf5, 0x2f, 0x4b, 0x37, 0xc3,
	0x58, 0x25, 0x2f, 0xd7, 0x87, 0xe0, 0x42, 0x0e, 0x9e, 0x48, 0xe1, 0xdb, 0x33, 0xf7, 0x93, 0xbb,
	0x51, 0x64, 0x2f, 0x90, 0xab, 0xe0, 0xe4, 0xc9, 0xfc, 0x53, 0xd6, 0x06, 0x72, 0x19, 0xd6, 0xf3,
	0x6a, 0xf6, 0x6e, 0xb1, 0x97, 0xc8, 0x3a, 0x5c, 0xcc, 0x4b, 0xfa, 0x7d, 0x6d, 0xaf, 0x91, 0x32,
	0x5c, 0x39, 0x47, 0x67, 0x8f, 0x73, 0x7b, 0x9d, 0x3c, 0x0a, 0x97, 0xcf, 0xe9, 0xe9, 0xb3, 0xdc,
	0xbe, 0x44, 0xca, 0xd3, 0x72, 0x2b, 0x8e, 0x87, 0x3c, 0x6a, 0x49, 0xa1, 0xe2, 0xba, 0xb2, 0xdf,
	0x2c, 0x6c, 0xbd, 0x01, 0xf3, 0xfa, 0x77, 0x18, 0x86, 0x5b, 0x0f, 0x4e, 0x0e, 0x83, 0xa3, 0xd0,
	0x9e, 0x21, 0x04, 0x56, 0x0d, 0x3e, 0xe0, 0x8a, 0xe1, 0xfb, 0xc2, 0x9e, 0x23, 0x17, 0x61, 0xc5,
	0x70, 0xc9, 0xe3, 0xc7, 0x5e, 0xc0, 0xe8, 0x27, 0xd4, 0x30, 0xee, 0xa3, 0x19, 0xbe, 0x6b, 0x6d,
	0x20, 0x6b, 0x60, 0x1b, 0xbe, 0xd1, 0xe7, 0xdd, 0x57, 0xc3, 0x40, 0x48, 0x65, 0x3b, 0xe4, 0x02,
	0x2c, 0x25, 0xac, 0x1f, 0xc4, 0xdc, 0xfe, 0xe6, 0x96, 0x0b, 0xc5, 0xf4, 0x97, 0x57, 0xb2, 0xba,
	0x1e, 0x9f, 0x1c, 0x06, 0x12, 0x4b, 0xcb, 0x81, 0xb5, 0x8c, 0x32, 0xdd, 0xd8, 0xe7, 0x8a, 0x7b,
	0x76, 0x81, 0x5c, 0x81, 0xf5, 0x4c, 0x31, 0xef, 0x40, 0xb7, 0xcf, 0x22, 0xee, 0xa1, 0x4f, 0x8f,
	0x41, 0x31, 0x7d, 0x62, 0xe0, 0x1d, 0xa5, 0xe3, 0x13, 0x37, 0xec, 0xf3, 0x88, 0xdb, 0x33, 0x5b,
	0xbf, 0xb0, 0xa0, 0x94, 0x7d, 0xb7, 0x71, 0xdf, 0x0c, 0x9c, 0xd4, 0xe5, 0xd8, 0x38, 0x3f, 0xa1,
	0xb0, 0x10, 0x6c, 0x6b, 0x9a, 0xbb, 0xd9, 0xe9, 0xb4, 0xed, 0xc2, 0x34, 0xb7, 0x27, 0x7c, 0x6e,
	0xcf, 0xdf, 0xb7, 0x5c, 0xd4, 0xb5, 0x17, 0xc8, 0x65, 0x58, 0x9b, 0x50, 0x8d, 0x88, 0x29, 0xae,
	0x1b, 0xb4, 0xfd, 0xd6, 0xfa, 0x7d, 0x12, 0x3e, 0xfd, 0x70, 0xc8, 0xec, 0xb7, 0xd7, 0xb7, 0x7e,
	0x6a, 0x4d, 0x7d, 0xf0, 0x70, 0xe1, 0x0c, 0x9e, 0x1c, 0xea, 0x0c, 0xc4, 0x64, 0xcb, 0x28, 0x97,
	0x77, 0x23, 0xae, 0x76, 0x82, 0xd1, 0xc9, 0x21, 0x6b, 0xf8, 0x36, 0x36, 0xf7, 0x4b, 0x13, 0xb5,
	0x1e, 0x8f, 0x07, 0x07, 0x71, 0xcf, 0x68, 0x7c, 0x5a, 0x73, 0x45, 0x4f, 0x0a, 0x99, 0x68, 0xa7,
	0x3a, 0x67, 0xce, 0x69, 0xbb, 0xcd, 0xda, 0x0b, 0x2f, 0x5c, 0x7f, 0xd1, 0xfe, 0xbb, 0xb5, 0xf5,
	0xbf, 0x05, 0x58, 0x4c, 0xea, 0x18, 0x0f, 0x95, 0x0c, 0x4f, 0x0e, 0x03, 0xac, 0x80, 0x19, 0xf2,
	0x30, 0x90, 0x94, 0x3a, 0x96, 0x92, 0x0d, 0xb8, 0x87, 0xfc, 0xb7, 0xab, 0xc4, 0x81, 0x87, 0x52,
	0x41, 0x77, 0x31, 0xc9, 0x7c, 0x54, 0xbe, 0x53, 0xc5, 0xdb, 0x9c, 0x4c, 0x89, 0x87, 0x61, 0x18,
	0x44, 0x8a, 0x7b, 0x47, 0xa1, 0xfd, 0xdd, 0xfb, 0x34, 0x31, 0x08, 0x7d, 0x8e, 0xbd, 0x8e, 0x7b,
	0xf6, 0xf7, 0xaa, 0x64, 0x0d, 0x2e, 0xa4, 0x1a, 0x96, 0x78, 0x30, 0x54, 0xf6, 0xf7, 0xab, 0x18,
	0xd3, 0x94, 0x75, 0xfb, 0x43, 0xa5, 0x84, 0xec, 0x35, 0x83, 0xd7, 0xa4, 0xfd, 0xd6, 0x94, 0x74,
	0x18, 0xa8, 0x46, 0x20, 0x25, 0xef, 0xe2, 0x5a, 0x6f, 0x57, 0xf3, 0xc7, 0xae, 0x0f, 0x55, 0x7f,
	0x8f, 0x09, 0x9f, 0x7b, 0xf6, 0x0f, 0xa6, 0x8e, 0xad, 0xab, 0x2b, 0x51, 0xde, 0xa9, 0x92, 0x47,
	0xe0, 0x52, 0xb6, 0x11, 0x8f, 0x63, 0x11, 0xc8, 0xdd, 0x51, 0x28, 0x30, 0x0b, 0x7f, 0x38, 0x35,
	0x8d, 0xf2, 0x3b, 0x87, 0x81, 0xda, 0x0b, 0x86, 0xd2, 0xb3, 0x7f, 0x34, 0xb5, 0x53, 0x4b, 0xde,
	0x65, 0xbe, 0xf0, 0x28, 0xbf, 0x63, 0xff, 0xec, 0x41, 0x02, 0xb6, 0x86, 0x77, 0xab, 0x64, 0x1d,
	0xec, 0x54, 0xd8, 0x61, 0xde, 0x2d, 0xe6, 0x0f, 0xb9, 0xfd, 0xf3, 0x2a, 0xb9, 0x0a, 0x0f, 0xe7,
	0xbc, 0xe9, 0x0b, 0xd9, 0xeb, 0x04, 0xf8, 0xd3, 0x4e, 0x28, 0xfb, 0x97, 0x53, 0xbe, 0x1a, 0x32,
	0x39, 0xf8, 0xaf, 0xa6, 0x0e, 0x6e, 0xfe, 0xcb, 0x91, 0x1d, 0xef, 0xbd, 0xa9, 0x80, 0x1b, 0x11,
	0xe7, 0x0d, 0x23, 0x6e, 0xff, 0x7a, 0xca, 0xa9, 0x7a, 0x18, 0x66, 0xb3, 0xde, 0x9f, 0x52, 0x9a,
	0xfc, 0x34, 0x53, 0x7e, 0x33, 0xa5, 0x1c, 0x30, 0xff, 0x34, 0x88, 0x06, 0xdc, 0xeb, 0x8c, 0xec,
	0x0f, 0xa6, 0x4e, 0x88, 0x6f, 0xc7, 0x6c, 0xd2, 0xef, 0xab, 0x98, 0x83, 0xf7, 0x49, 0x69, 0x27,
	0xe5, 0x9e, 0xfd, 0x87, 0x2a, 0xb9, 0x04, 0x17, 0x73, 0x11, 0x49, 0x8a, 0xe6, 0x8f, 0xd3, 0xc7,
	0x60, 0x8a, 0xa5, 0x47, 0xff, 0xd3, 0xd4, 0x8c, 0xdd, 0x11, 0x26, 0x18, 0xe6, 0xde, 0x87, 0x53,
	0x7c, 0x3b, 0xbb, 0xdc, 0x3f, 0x57, 0xc9, 0xa3, 0xe0, 0xe4, 0x78, 0xfd, 0xc4, 0x1d, 0x29, 0xdd,
	0xb7, 0x3c, 0xfb, 0x2f, 0xd3, 0xd1, 0xe5, 0xbe, 0x9f, 0x9d, 0xfd, 0xaf, 0x53, 0x67, 0x68, 0x47,
	0xc1, 0x5d, 0xe1, 0xf1, 0x08, 0xf7, 0xfa, 0x5b, 0x95, 0x3c, 0x06, 0x57, 0x52, 0xe5, 0x96, 0x08,
	0x7c, 0xa6, 0x78, 0x5c, 0x0f, 0x43, 0x2e, 0xbd, 0x23, 0xe9, 0x8f, 0xed, 0xff, 0x54, 0xc9, 0x93,
	0xf0, 0xd8, 0x24, 0x03, 0xe2, 0xe1, 0xe9, 0xa9, 0xe8, 0x0a, 0x2e, 0x55, 0x9b, 0x47, 0x03, 0xa1,
	0x13, 0x2c, 0xb6, 0xff, 0x5b, 0xad, 0x5d, 0x37, 0xff, 0x00, 0xc2, 0xef, 0x16, 0x79, 0x0a, 0x96,
	0x70, 0x9c, 0xe4, 0x1f, 0xc9, 0x7e, 0x8b, 0x5d, 0xc9, 0x46, 0x9b, 0xd6, 0x73, 0xd6, 0xce, 0x4b,
	0x1f, 0x7f, 0x5a, 0x9e, 0xf9, 0xe4, 0xd3, 0xf2, 0xcc, 0xbd, 0x4f, 0xcb, 0xd6, 0x9b, 0x67, 0x65,
	0xeb, 0xbd, 0xb3, 0xb2, 0xf5, 0xd1, 0x59, 0xd9, 0xfa, 0xf8, 0xac, 0x6c, 0xfd, 0xf3, 0xac, 0x6c,
	0xfd, 0xfb, 0xac, 0x3c, 0x73, 0xef, 0xac, 0x6c, 0xbd, 0xf3, 0x59, 0x79, 0xe6, 0xe3, 0xcf, 0xca,
	0x33, 0x9f, 0x7c, 0x56, 0x9e, 0x79, 0xbf, 0x50, 0xac, 0x47, 0xdd, 0x38, 0x64, 0x5d, 0x7e, 0x7b,
	0x41, 0xff, 0x4f, 0x6f, 0xfb, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xad, 0x3b, 0x90, 0x71, 0xe9,
	0x13, 0x00, 0x00,
}

func (x Const) String() string {
	s, ok := Const_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ConstSymbol) String() string {
	s, ok := ConstSymbol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgOp) String() string {
	s, ok := MsgOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgFlags) String() string {
	s, ok := MsgFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x GeoModel) String() string {
	s, ok := GeoModel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x URIScheme) String() string {
	s, ok := URIScheme_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrCode) String() string {
	s, ok := ErrCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TRS_VisualScaleMode) String() string {
	s, ok := TRS_VisualScaleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.ReqID != that1.ReqID {
		return false
	}
	if this.CellID != that1.CellID {
		return false
	}
	if this.AttrID != that1.AttrID {
		return false
	}
	if this.SI != that1.SI {
		return false
	}
	if !bytes.Equal(this.ValBuf, that1.ValBuf) {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	return true
}
func (this *PlanetEpoch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanetEpoch)
	if !ok {
		that2, ok := that.(PlanetEpoch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.EpochTID, that1.EpochTID) {
		return false
	}
	if len(this.EpochEntries) != len(that1.EpochEntries) {
		return false
	}
	for i := range this.EpochEntries {
		if !this.EpochEntries[i].Equal(that1.EpochEntries[i]) {
			return false
		}
	}
	if this.CommonName != that1.CommonName {
		return false
	}
	return true
}
func (this *Login) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Login)
	if !ok {
		that2, ok := that.(Login)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserUID != that1.UserUID {
		return false
	}
	if this.HostAddr != that1.HostAddr {
		return false
	}
	if this.DeviceLabel != that1.DeviceLabel {
		return false
	}
	if this.DeviceUID != that1.DeviceUID {
		return false
	}
	return true
}
func (this *LoginChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginChallenge)
	if !ok {
		that2, ok := that.(LoginChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *LoginResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginResponse)
	if !ok {
		that2, ok := that.(LoginResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashResp, that1.HashResp) {
		return false
	}
	return true
}
func (this *Symbol) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Symbol)
	if !ok {
		that2, ok := that.(Symbol)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !bytes.Equal(this.Name, that1.Name) {
		return false
	}
	return true
}
func (this *RegisterDefs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegisterDefs)
	if !ok {
		that2, ok := that.(RegisterDefs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Symbols) != len(that1.Symbols) {
		return false
	}
	for i := range this.Symbols {
		if !this.Symbols[i].Equal(that1.Symbols[i]) {
			return false
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !this.Attrs[i].Equal(that1.Attrs[i]) {
			return false
		}
	}
	if len(this.Cells) != len(that1.Cells) {
		return false
	}
	for i := range this.Cells {
		if !this.Cells[i].Equal(that1.Cells[i]) {
			return false
		}
	}
	if len(this.Selectors) != len(that1.Selectors) {
		return false
	}
	for i := range this.Selectors {
		if !this.Selectors[i].Equal(that1.Selectors[i]) {
			return false
		}
	}
	return true
}
func (this *AttrSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrSpec)
	if !ok {
		that2, ok := that.(AttrSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefID != that1.DefID {
		return false
	}
	if this.ElemType != that1.ElemType {
		return false
	}
	if this.SeriesType != that1.SeriesType {
		return false
	}
	if this.AttrName != that1.AttrName {
		return false
	}
	return true
}
func (this *CellSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellSpec)
	if !ok {
		that2, ok := that.(CellSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefID != that1.DefID {
		return false
	}
	if len(this.CommonAttrs) != len(that1.CommonAttrs) {
		return false
	}
	for i := range this.CommonAttrs {
		if this.CommonAttrs[i] != that1.CommonAttrs[i] {
			return false
		}
	}
	if len(this.PinnedAttrs) != len(that1.PinnedAttrs) {
		return false
	}
	for i := range this.PinnedAttrs {
		if this.PinnedAttrs[i] != that1.PinnedAttrs[i] {
			return false
		}
	}
	return true
}
func (this *ItemSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemSelector)
	if !ok {
		that2, ok := that.(ItemSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefID != that1.DefID {
		return false
	}
	if len(this.Include) != len(that1.Include) {
		return false
	}
	for i := range this.Include {
		if this.Include[i] != that1.Include[i] {
			return false
		}
	}
	if len(this.Exclude) != len(that1.Exclude) {
		return false
	}
	for i := range this.Exclude {
		if this.Exclude[i] != that1.Exclude[i] {
			return false
		}
	}
	return true
}
func (this *KwArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KwArg)
	if !ok {
		that2, ok := that.(KwArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Val != that1.Val {
		return false
	}
	if !bytes.Equal(this.ValBuf, that1.ValBuf) {
		return false
	}
	return true
}
func (this *HandleURI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HandleURI)
	if !ok {
		that2, ok := that.(HandleURI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	return true
}
func (this *PinReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinReq)
	if !ok {
		that2, ok := that.(PinReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParentReqID != that1.ParentReqID {
		return false
	}
	if this.PinURI != that1.PinURI {
		return false
	}
	if this.PinCell != that1.PinCell {
		return false
	}
	if this.ParentAttrSelector != that1.ParentAttrSelector {
		return false
	}
	if this.ChildCellSelector != that1.ChildCellSelector {
		return false
	}
	if this.MaintainSync != that1.MaintainSync {
		return false
	}
	return true
}
func (this *AttrRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrRange)
	if !ok {
		that2, ok := that.(AttrRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SI_SeekTo != that1.SI_SeekTo {
		return false
	}
	if this.SI_StopAt != that1.SI_StopAt {
		return false
	}
	if this.SI_BatchLimit != that1.SI_BatchLimit {
		return false
	}
	return true
}
func (this *Txn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Txn)
	if !ok {
		that2, ok := that.(Txn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Msgs) != len(that1.Msgs) {
		return false
	}
	for i := range this.Msgs {
		if !this.Msgs[i].Equal(that1.Msgs[i]) {
			return false
		}
	}
	return true
}
func (this *GeoFix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFix)
	if !ok {
		that2, ok := that.(GeoFix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Lat != that1.Lat {
		return false
	}
	if this.Lng != that1.Lng {
		return false
	}
	if this.Alt != that1.Alt {
		return false
	}
	if this.AltROU != that1.AltROU {
		return false
	}
	if this.PosROU != that1.PosROU {
		return false
	}
	return true
}
func (this *AssetRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssetRef)
	if !ok {
		that2, ok := that.(AssetRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.MediaType != that1.MediaType {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	if this.PixWidth != that1.PixWidth {
		return false
	}
	if this.PixHeight != that1.PixHeight {
		return false
	}
	if this.PhysWidth != that1.PhysWidth {
		return false
	}
	if this.PhysHeight != that1.PhysHeight {
		return false
	}
	return true
}
func (this *Content) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Content)
	if !ok {
		that2, ok := that.(Content)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ContentData, that1.ContentData) {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.ContentTypeID != that1.ContentTypeID {
		return false
	}
	if this.LinksCellID != that1.LinksCellID {
		return false
	}
	if !this.Location.Equal(that1.Location) {
		return false
	}
	return true
}
func (this *CryptoKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptoKey)
	if !ok {
		that2, ok := that.(CryptoKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CryptoKitID != that1.CryptoKitID {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	return true
}
func (this *CellInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellInfo)
	if !ok {
		that2, ok := that.(CellInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CellDefID != that1.CellDefID {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Subtitle != that1.Subtitle {
		return false
	}
	if this.About != that1.About {
		return false
	}
	if !this.Glyph.Equal(that1.Glyph) {
		return false
	}
	if !this.GlyphLarge.Equal(that1.GlyphLarge) {
		return false
	}
	if !this.Link.Equal(that1.Link) {
		return false
	}
	if this.Created != that1.Created {
		return false
	}
	if this.Modified != that1.Modified {
		return false
	}
	return true
}
func (this *TRS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TRS)
	if !ok {
		that2, ok := that.(TRS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.X3 != that1.X3 {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.Scale3 != that1.Scale3 {
		return false
	}
	if this.Rotate1 != that1.Rotate1 {
		return false
	}
	if this.Rotate2 != that1.Rotate2 {
		return false
	}
	if this.Rotate3 != that1.Rotate3 {
		return false
	}
	return true
}
func (this *FeedParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeedParams)
	if !ok {
		that2, ok := that.(FeedParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpdateIntervalMin != that1.UpdateIntervalMin {
		return false
	}
	if this.UpdateIntervalMax != that1.UpdateIntervalMax {
		return false
	}
	return true
}
func (this *DataSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSegment)
	if !ok {
		that2, ok := that.(DataSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByteOfs != that1.ByteOfs {
		return false
	}
	if this.ByteSz != that1.ByteSz {
		return false
	}
	if !bytes.Equal(this.InlineData, that1.InlineData) {
		return false
	}
	if this.StreamURI != that1.StreamURI {
		return false
	}
	if this.BlobID != that1.BlobID {
		return false
	}
	return true
}
func (this *Err) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Err)
	if !ok {
		that2, ok := that.(Err)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&arc.Msg{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "ReqID: "+fmt.Sprintf("%#v", this.ReqID)+",\n")
	s = append(s, "CellID: "+fmt.Sprintf("%#v", this.CellID)+",\n")
	s = append(s, "AttrID: "+fmt.Sprintf("%#v", this.AttrID)+",\n")
	s = append(s, "SI: "+fmt.Sprintf("%#v", this.SI)+",\n")
	s = append(s, "ValBuf: "+fmt.Sprintf("%#v", this.ValBuf)+",\n")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanetEpoch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.PlanetEpoch{")
	s = append(s, "EpochTID: "+fmt.Sprintf("%#v", this.EpochTID)+",\n")
	if this.EpochEntries != nil {
		s = append(s, "EpochEntries: "+fmt.Sprintf("%#v", this.EpochEntries)+",\n")
	}
	s = append(s, "CommonName: "+fmt.Sprintf("%#v", this.CommonName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Login) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.Login{")
	s = append(s, "UserUID: "+fmt.Sprintf("%#v", this.UserUID)+",\n")
	s = append(s, "HostAddr: "+fmt.Sprintf("%#v", this.HostAddr)+",\n")
	s = append(s, "DeviceLabel: "+fmt.Sprintf("%#v", this.DeviceLabel)+",\n")
	s = append(s, "DeviceUID: "+fmt.Sprintf("%#v", this.DeviceUID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.LoginChallenge{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.LoginResponse{")
	s = append(s, "HashResp: "+fmt.Sprintf("%#v", this.HashResp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Symbol) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Symbol{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegisterDefs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.RegisterDefs{")
	if this.Symbols != nil {
		s = append(s, "Symbols: "+fmt.Sprintf("%#v", this.Symbols)+",\n")
	}
	if this.Attrs != nil {
		s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	}
	if this.Cells != nil {
		s = append(s, "Cells: "+fmt.Sprintf("%#v", this.Cells)+",\n")
	}
	if this.Selectors != nil {
		s = append(s, "Selectors: "+fmt.Sprintf("%#v", this.Selectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.AttrSpec{")
	s = append(s, "DefID: "+fmt.Sprintf("%#v", this.DefID)+",\n")
	s = append(s, "ElemType: "+fmt.Sprintf("%#v", this.ElemType)+",\n")
	s = append(s, "SeriesType: "+fmt.Sprintf("%#v", this.SeriesType)+",\n")
	s = append(s, "AttrName: "+fmt.Sprintf("%#v", this.AttrName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CellSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.CellSpec{")
	s = append(s, "DefID: "+fmt.Sprintf("%#v", this.DefID)+",\n")
	s = append(s, "CommonAttrs: "+fmt.Sprintf("%#v", this.CommonAttrs)+",\n")
	s = append(s, "PinnedAttrs: "+fmt.Sprintf("%#v", this.PinnedAttrs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.ItemSelector{")
	s = append(s, "DefID: "+fmt.Sprintf("%#v", this.DefID)+",\n")
	s = append(s, "Include: "+fmt.Sprintf("%#v", this.Include)+",\n")
	s = append(s, "Exclude: "+fmt.Sprintf("%#v", this.Exclude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KwArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.KwArg{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Val: "+fmt.Sprintf("%#v", this.Val)+",\n")
	s = append(s, "ValBuf: "+fmt.Sprintf("%#v", this.ValBuf)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HandleURI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.HandleURI{")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&arc.PinReq{")
	s = append(s, "ParentReqID: "+fmt.Sprintf("%#v", this.ParentReqID)+",\n")
	s = append(s, "PinURI: "+fmt.Sprintf("%#v", this.PinURI)+",\n")
	s = append(s, "PinCell: "+fmt.Sprintf("%#v", this.PinCell)+",\n")
	s = append(s, "ParentAttrSelector: "+fmt.Sprintf("%#v", this.ParentAttrSelector)+",\n")
	s = append(s, "ChildCellSelector: "+fmt.Sprintf("%#v", this.ChildCellSelector)+",\n")
	s = append(s, "MaintainSync: "+fmt.Sprintf("%#v", this.MaintainSync)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.AttrRange{")
	s = append(s, "SI_SeekTo: "+fmt.Sprintf("%#v", this.SI_SeekTo)+",\n")
	s = append(s, "SI_StopAt: "+fmt.Sprintf("%#v", this.SI_StopAt)+",\n")
	s = append(s, "SI_BatchLimit: "+fmt.Sprintf("%#v", this.SI_BatchLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Txn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.Txn{")
	if this.Msgs != nil {
		s = append(s, "Msgs: "+fmt.Sprintf("%#v", this.Msgs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoFix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&arc.GeoFix{")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	s = append(s, "Lng: "+fmt.Sprintf("%#v", this.Lng)+",\n")
	s = append(s, "Alt: "+fmt.Sprintf("%#v", this.Alt)+",\n")
	s = append(s, "AltROU: "+fmt.Sprintf("%#v", this.AltROU)+",\n")
	s = append(s, "PosROU: "+fmt.Sprintf("%#v", this.PosROU)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AssetRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&arc.AssetRef{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "MediaType: "+fmt.Sprintf("%#v", this.MediaType)+",\n")
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "PixWidth: "+fmt.Sprintf("%#v", this.PixWidth)+",\n")
	s = append(s, "PixHeight: "+fmt.Sprintf("%#v", this.PixHeight)+",\n")
	s = append(s, "PhysWidth: "+fmt.Sprintf("%#v", this.PhysWidth)+",\n")
	s = append(s, "PhysHeight: "+fmt.Sprintf("%#v", this.PhysHeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Content) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.Content{")
	s = append(s, "ContentData: "+fmt.Sprintf("%#v", this.ContentData)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "ContentTypeID: "+fmt.Sprintf("%#v", this.ContentTypeID)+",\n")
	s = append(s, "LinksCellID: "+fmt.Sprintf("%#v", this.LinksCellID)+",\n")
	if this.Location != nil {
		s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CryptoKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.CryptoKey{")
	s = append(s, "CryptoKitID: "+fmt.Sprintf("%#v", this.CryptoKitID)+",\n")
	s = append(s, "KeyBytes: "+fmt.Sprintf("%#v", this.KeyBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CellInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&arc.CellInfo{")
	s = append(s, "CellDefID: "+fmt.Sprintf("%#v", this.CellDefID)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Subtitle: "+fmt.Sprintf("%#v", this.Subtitle)+",\n")
	s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	if this.Glyph != nil {
		s = append(s, "Glyph: "+fmt.Sprintf("%#v", this.Glyph)+",\n")
	}
	if this.GlyphLarge != nil {
		s = append(s, "GlyphLarge: "+fmt.Sprintf("%#v", this.GlyphLarge)+",\n")
	}
	if this.Link != nil {
		s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	}
	s = append(s, "Created: "+fmt.Sprintf("%#v", this.Created)+",\n")
	s = append(s, "Modified: "+fmt.Sprintf("%#v", this.Modified)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TRS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&arc.TRS{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "X3: "+fmt.Sprintf("%#v", this.X3)+",\n")
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "Scale3: "+fmt.Sprintf("%#v", this.Scale3)+",\n")
	s = append(s, "Rotate1: "+fmt.Sprintf("%#v", this.Rotate1)+",\n")
	s = append(s, "Rotate2: "+fmt.Sprintf("%#v", this.Rotate2)+",\n")
	s = append(s, "Rotate3: "+fmt.Sprintf("%#v", this.Rotate3)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeedParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.FeedParams{")
	s = append(s, "UpdateIntervalMin: "+fmt.Sprintf("%#v", this.UpdateIntervalMin)+",\n")
	s = append(s, "UpdateIntervalMax: "+fmt.Sprintf("%#v", this.UpdateIntervalMax)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.DataSegment{")
	s = append(s, "ByteOfs: "+fmt.Sprintf("%#v", this.ByteOfs)+",\n")
	s = append(s, "ByteSz: "+fmt.Sprintf("%#v", this.ByteSz)+",\n")
	s = append(s, "InlineData: "+fmt.Sprintf("%#v", this.InlineData)+",\n")
	s = append(s, "StreamURI: "+fmt.Sprintf("%#v", this.StreamURI)+",\n")
	s = append(s, "BlobID: "+fmt.Sprintf("%#v", this.BlobID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Err) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Err{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringArc(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HostGrpcClient is the client API for HostGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HostGrpcClient interface {
	// HostSession is full duplex connected between two Planet hosts.
	// The return stream reports completion or status of active requests and will remain open as long as the client stream remains open.
	HostSession(ctx context.Context, opts ...grpc.CallOption) (HostGrpc_HostSessionClient, error)
}

type hostGrpcClient struct {
	cc *grpc.ClientConn
}

func NewHostGrpcClient(cc *grpc.ClientConn) HostGrpcClient {
	return &hostGrpcClient{cc}
}

func (c *hostGrpcClient) HostSession(ctx context.Context, opts ...grpc.CallOption) (HostGrpc_HostSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_HostGrpc_serviceDesc.Streams[0], "/arc.HostGrpc/HostSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &hostGrpcHostSessionClient{stream}
	return x, nil
}

type HostGrpc_HostSessionClient interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ClientStream
}

type hostGrpcHostSessionClient struct {
	grpc.ClientStream
}

func (x *hostGrpcHostSessionClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hostGrpcHostSessionClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HostGrpcServer is the server API for HostGrpc service.
type HostGrpcServer interface {
	// HostSession is full duplex connected between two Planet hosts.
	// The return stream reports completion or status of active requests and will remain open as long as the client stream remains open.
	HostSession(HostGrpc_HostSessionServer) error
}

// UnimplementedHostGrpcServer can be embedded to have forward compatible implementations.
type UnimplementedHostGrpcServer struct {
}

func (*UnimplementedHostGrpcServer) HostSession(srv HostGrpc_HostSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method HostSession not implemented")
}

func RegisterHostGrpcServer(s *grpc.Server, srv HostGrpcServer) {
	s.RegisterService(&_HostGrpc_serviceDesc, srv)
}

func _HostGrpc_HostSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HostGrpcServer).HostSession(&hostGrpcHostSessionServer{stream})
}

type HostGrpc_HostSessionServer interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type hostGrpcHostSessionServer struct {
	grpc.ServerStream
}

func (x *hostGrpcHostSessionServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hostGrpcHostSessionServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _HostGrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arc.HostGrpc",
	HandlerType: (*HostGrpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HostSession",
			Handler:       _HostGrpc_HostSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "apis/arc/arc.proto",
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ValBuf) > 0 {
		i -= len(m.ValBuf)
		copy(dAtA[i:], m.ValBuf)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ValBuf)))
		i--
		dAtA[i] = 0x52
	}
	if m.SI != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI))
		i--
		dAtA[i] = 0x40
	}
	if m.AttrID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrID))
		i--
		dAtA[i] = 0x30
	}
	if m.CellID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CellID))
		i--
		dAtA[i] = 0x20
	}
	if m.ReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlanetEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanetEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanetEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintArc(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EpochEntries) > 0 {
		for iNdEx := len(m.EpochEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EpochEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.EpochTID) > 0 {
		i -= len(m.EpochTID)
		copy(dAtA[i:], m.EpochTID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.EpochTID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceUID) > 0 {
		i -= len(m.DeviceUID)
		copy(dAtA[i:], m.DeviceUID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.DeviceUID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DeviceLabel) > 0 {
		i -= len(m.DeviceLabel)
		copy(dAtA[i:], m.DeviceLabel)
		i = encodeVarintArc(dAtA, i, uint64(len(m.DeviceLabel)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.HostAddr) > 0 {
		i -= len(m.HostAddr)
		copy(dAtA[i:], m.HostAddr)
		i = encodeVarintArc(dAtA, i, uint64(len(m.HostAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserUID) > 0 {
		i -= len(m.UserUID)
		copy(dAtA[i:], m.UserUID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.UserUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashResp) > 0 {
		i -= len(m.HashResp)
		copy(dAtA[i:], m.HashResp)
		i = encodeVarintArc(dAtA, i, uint64(len(m.HashResp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Symbol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterDefs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterDefs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterDefs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for iNdEx := len(m.Selectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Symbols) > 0 {
		for iNdEx := len(m.Symbols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Symbols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttrSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttrName != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrName))
		i--
		dAtA[i] = 0x30
	}
	if m.SeriesType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SeriesType))
		i--
		dAtA[i] = 0x28
	}
	if m.ElemType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ElemType))
		i--
		dAtA[i] = 0x18
	}
	if m.DefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.DefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PinnedAttrs) > 0 {
		dAtA2 := make([]byte, len(m.PinnedAttrs)*10)
		var j1 int
		for _, num := range m.PinnedAttrs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintArc(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CommonAttrs) > 0 {
		dAtA4 := make([]byte, len(m.CommonAttrs)*10)
		var j3 int
		for _, num := range m.CommonAttrs {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintArc(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.DefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.DefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ItemSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exclude) > 0 {
		dAtA6 := make([]byte, len(m.Exclude)*10)
		var j5 int
		for _, num := range m.Exclude {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintArc(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Include) > 0 {
		dAtA8 := make([]byte, len(m.Include)*10)
		var j7 int
		for _, num := range m.Include {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintArc(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.DefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.DefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KwArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KwArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KwArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValBuf) > 0 {
		i -= len(m.ValBuf)
		copy(dAtA[i:], m.ValBuf)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ValBuf)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HandleURI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleURI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleURI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaintainSync {
		i--
		if m.MaintainSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ChildCellSelector != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ChildCellSelector))
		i--
		dAtA[i] = 0x30
	}
	if m.ParentAttrSelector != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ParentAttrSelector))
		i--
		dAtA[i] = 0x28
	}
	if m.PinCell != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PinCell))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PinURI) > 0 {
		i -= len(m.PinURI)
		copy(dAtA[i:], m.PinURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.PinURI)))
		i--
		dAtA[i] = 0x12
	}
	if m.ParentReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ParentReqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttrRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SI_BatchLimit != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_BatchLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.SI_StopAt != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_StopAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.SI_SeekTo != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_SeekTo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	return len(dAtA) - i, nil
}

func (m *Txn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Txn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Txn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoFix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoFix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PosROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosROU))))
		i--
		dAtA[i] = 0x5d
	}
	if m.AltROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AltROU))))
		i--
		dAtA[i] = 0x55
	}
	if m.Alt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Alt))))
		i--
		dAtA[i] = 0x31
	}
	if m.Lng != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lng))))
		i--
		dAtA[i] = 0x29
	}
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x21
	}
	if m.Model != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssetRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhysHeight != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhysHeight))))
		i--
		dAtA[i] = 0x6d
	}
	if m.PhysWidth != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhysWidth))))
		i--
		dAtA[i] = 0x65
	}
	if m.PixHeight != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PixHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.PixWidth != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PixWidth))
		i--
		dAtA[i] = 0x50
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x32
	}
	if m.Scheme != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Scheme))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MediaType) > 0 {
		i -= len(m.MediaType)
		copy(dAtA[i:], m.MediaType)
		i = encodeVarintArc(dAtA, i, uint64(len(m.MediaType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Content) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Content) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LinksCellID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.LinksCellID))
		i--
		dAtA[i] = 0x50
	}
	if m.ContentTypeID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ContentTypeID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentData) > 0 {
		i -= len(m.ContentData)
		copy(dAtA[i:], m.ContentData)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ContentData)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CryptoKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintArc(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modified != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Modified))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Created != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.GlyphLarge != nil {
		{
			size, err := m.GlyphLarge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Glyph != nil {
		{
			size, err := m.Glyph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.About) > 0 {
		i -= len(m.About)
		copy(dAtA[i:], m.About)
		i = encodeVarintArc(dAtA, i, uint64(len(m.About)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x22
	}
	if m.CellDefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CellDefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TRS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TRS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TRS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfd
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.ScaleMode != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	return len(dAtA) - i, nil
}

func (m *FeedParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateIntervalMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMax))))
		i--
		dAtA[i] = 0x1d
	}
	if m.UpdateIntervalMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMin))))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *DataSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.BlobID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StreamURI) > 0 {
		i -= len(m.StreamURI)
		copy(dAtA[i:], m.StreamURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.StreamURI)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintArc(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ByteSz != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteSz))
		i--
		dAtA[i] = 0x30
	}
	if m.ByteOfs != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteOfs))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintArc(dAtA []byte, offset int, v uint64) int {
	offset -= sovArc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovArc(uint64(m.Op))
	}
	if m.ReqID != 0 {
		n += 1 + sovArc(uint64(m.ReqID))
	}
	if m.CellID != 0 {
		n += 1 + sovArc(uint64(m.CellID))
	}
	if m.AttrID != 0 {
		n += 1 + sovArc(uint64(m.AttrID))
	}
	if m.SI != 0 {
		n += 1 + sovArc(uint64(m.SI))
	}
	l = len(m.ValBuf)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovArc(uint64(m.Flags))
	}
	return n
}

func (m *PlanetEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EpochTID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if len(m.EpochEntries) > 0 {
		for _, e := range m.EpochEntries {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserUID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.HostAddr)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.DeviceLabel)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.DeviceUID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *LoginChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashResp)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Symbol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArc(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *RegisterDefs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Symbols) > 0 {
		for _, e := range m.Symbols {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *AttrSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefID != 0 {
		n += 1 + sovArc(uint64(m.DefID))
	}
	if m.ElemType != 0 {
		n += 1 + sovArc(uint64(m.ElemType))
	}
	if m.SeriesType != 0 {
		n += 1 + sovArc(uint64(m.SeriesType))
	}
	if m.AttrName != 0 {
		n += 1 + sovArc(uint64(m.AttrName))
	}
	return n
}

func (m *CellSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefID != 0 {
		n += 1 + sovArc(uint64(m.DefID))
	}
	if len(m.CommonAttrs) > 0 {
		l = 0
		for _, e := range m.CommonAttrs {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	if len(m.PinnedAttrs) > 0 {
		l = 0
		for _, e := range m.PinnedAttrs {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	return n
}

func (m *ItemSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefID != 0 {
		n += 1 + sovArc(uint64(m.DefID))
	}
	if len(m.Include) > 0 {
		l = 0
		for _, e := range m.Include {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	if len(m.Exclude) > 0 {
		l = 0
		for _, e := range m.Exclude {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	return n
}

func (m *KwArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.ValBuf)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *HandleURI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *PinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParentReqID != 0 {
		n += 1 + sovArc(uint64(m.ParentReqID))
	}
	l = len(m.PinURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.PinCell != 0 {
		n += 1 + sovArc(uint64(m.PinCell))
	}
	if m.ParentAttrSelector != 0 {
		n += 1 + sovArc(uint64(m.ParentAttrSelector))
	}
	if m.ChildCellSelector != 0 {
		n += 1 + sovArc(uint64(m.ChildCellSelector))
	}
	if m.MaintainSync {
		n += 2
	}
	return n
}

func (m *AttrRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SI_SeekTo != 0 {
		n += 2 + sovArc(uint64(m.SI_SeekTo))
	}
	if m.SI_StopAt != 0 {
		n += 2 + sovArc(uint64(m.SI_StopAt))
	}
	if m.SI_BatchLimit != 0 {
		n += 2 + sovArc(uint64(m.SI_BatchLimit))
	}
	return n
}

func (m *Txn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *GeoFix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != 0 {
		n += 1 + sovArc(uint64(m.Model))
	}
	if m.Lat != 0 {
		n += 9
	}
	if m.Lng != 0 {
		n += 9
	}
	if m.Alt != 0 {
		n += 9
	}
	if m.AltROU != 0 {
		n += 5
	}
	if m.PosROU != 0 {
		n += 5
	}
	return n
}

func (m *AssetRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.MediaType)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Scheme != 0 {
		n += 1 + sovArc(uint64(m.Scheme))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.PixWidth != 0 {
		n += 1 + sovArc(uint64(m.PixWidth))
	}
	if m.PixHeight != 0 {
		n += 1 + sovArc(uint64(m.PixHeight))
	}
	if m.PhysWidth != 0 {
		n += 5
	}
	if m.PhysHeight != 0 {
		n += 5
	}
	return n
}

func (m *Content) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentData)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.ContentTypeID != 0 {
		n += 1 + sovArc(uint64(m.ContentTypeID))
	}
	if m.LinksCellID != 0 {
		n += 1 + sovArc(uint64(m.LinksCellID))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *CryptoKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptoKitID != 0 {
		n += 1 + sovArc(uint64(m.CryptoKitID))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *CellInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CellDefID != 0 {
		n += 1 + sovArc(uint64(m.CellDefID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Glyph != nil {
		l = m.Glyph.Size()
		n += 1 + l + sovArc(uint64(l))
	}
	if m.GlyphLarge != nil {
		l = m.GlyphLarge.Size()
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Created != 0 {
		n += 2 + sovArc(uint64(m.Created))
	}
	if m.Modified != 0 {
		n += 2 + sovArc(uint64(m.Modified))
	}
	return n
}

func (m *TRS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.ScaleMode != 0 {
		n += 2 + sovArc(uint64(m.ScaleMode))
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	return n
}

func (m *FeedParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateIntervalMin != 0 {
		n += 5
	}
	if m.UpdateIntervalMax != 0 {
		n += 5
	}
	return n
}

func (m *DataSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteOfs != 0 {
		n += 1 + sovArc(uint64(m.ByteOfs))
	}
	if m.ByteSz != 0 {
		n += 1 + sovArc(uint64(m.ByteSz))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.StreamURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.BlobID != 0 {
		n += 1 + sovArc(uint64(m.BlobID))
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovArc(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func sovArc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArc(x uint64) (n int) {
	return sovArc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`ReqID:` + fmt.Sprintf("%v", this.ReqID) + `,`,
		`CellID:` + fmt.Sprintf("%v", this.CellID) + `,`,
		`AttrID:` + fmt.Sprintf("%v", this.AttrID) + `,`,
		`SI:` + fmt.Sprintf("%v", this.SI) + `,`,
		`ValBuf:` + fmt.Sprintf("%v", this.ValBuf) + `,`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanetEpoch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEpochEntries := "[]*Msg{"
	for _, f := range this.EpochEntries {
		repeatedStringForEpochEntries += strings.Replace(f.String(), "Msg", "Msg", 1) + ","
	}
	repeatedStringForEpochEntries += "}"
	s := strings.Join([]string{`&PlanetEpoch{`,
		`EpochTID:` + fmt.Sprintf("%v", this.EpochTID) + `,`,
		`EpochEntries:` + repeatedStringForEpochEntries + `,`,
		`CommonName:` + fmt.Sprintf("%v", this.CommonName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Login) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Login{`,
		`UserUID:` + fmt.Sprintf("%v", this.UserUID) + `,`,
		`HostAddr:` + fmt.Sprintf("%v", this.HostAddr) + `,`,
		`DeviceLabel:` + fmt.Sprintf("%v", this.DeviceLabel) + `,`,
		`DeviceUID:` + fmt.Sprintf("%v", this.DeviceUID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginChallenge{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginResponse{`,
		`HashResp:` + fmt.Sprintf("%v", this.HashResp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Symbol) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Symbol{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegisterDefs) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSymbols := "[]*Symbol{"
	for _, f := range this.Symbols {
		repeatedStringForSymbols += strings.Replace(f.String(), "Symbol", "Symbol", 1) + ","
	}
	repeatedStringForSymbols += "}"
	repeatedStringForAttrs := "[]*AttrSpec{"
	for _, f := range this.Attrs {
		repeatedStringForAttrs += strings.Replace(f.String(), "AttrSpec", "AttrSpec", 1) + ","
	}
	repeatedStringForAttrs += "}"
	repeatedStringForCells := "[]*CellSpec{"
	for _, f := range this.Cells {
		repeatedStringForCells += strings.Replace(f.String(), "CellSpec", "CellSpec", 1) + ","
	}
	repeatedStringForCells += "}"
	repeatedStringForSelectors := "[]*ItemSelector{"
	for _, f := range this.Selectors {
		repeatedStringForSelectors += strings.Replace(f.String(), "ItemSelector", "ItemSelector", 1) + ","
	}
	repeatedStringForSelectors += "}"
	s := strings.Join([]string{`&RegisterDefs{`,
		`Symbols:` + repeatedStringForSymbols + `,`,
		`Attrs:` + repeatedStringForAttrs + `,`,
		`Cells:` + repeatedStringForCells + `,`,
		`Selectors:` + repeatedStringForSelectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrSpec{`,
		`DefID:` + fmt.Sprintf("%v", this.DefID) + `,`,
		`ElemType:` + fmt.Sprintf("%v", this.ElemType) + `,`,
		`SeriesType:` + fmt.Sprintf("%v", this.SeriesType) + `,`,
		`AttrName:` + fmt.Sprintf("%v", this.AttrName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CellSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CellSpec{`,
		`DefID:` + fmt.Sprintf("%v", this.DefID) + `,`,
		`CommonAttrs:` + fmt.Sprintf("%v", this.CommonAttrs) + `,`,
		`PinnedAttrs:` + fmt.Sprintf("%v", this.PinnedAttrs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ItemSelector{`,
		`DefID:` + fmt.Sprintf("%v", this.DefID) + `,`,
		`Include:` + fmt.Sprintf("%v", this.Include) + `,`,
		`Exclude:` + fmt.Sprintf("%v", this.Exclude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KwArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KwArg{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Val:` + fmt.Sprintf("%v", this.Val) + `,`,
		`ValBuf:` + fmt.Sprintf("%v", this.ValBuf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HandleURI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HandleURI{`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PinReq{`,
		`ParentReqID:` + fmt.Sprintf("%v", this.ParentReqID) + `,`,
		`PinURI:` + fmt.Sprintf("%v", this.PinURI) + `,`,
		`PinCell:` + fmt.Sprintf("%v", this.PinCell) + `,`,
		`ParentAttrSelector:` + fmt.Sprintf("%v", this.ParentAttrSelector) + `,`,
		`ChildCellSelector:` + fmt.Sprintf("%v", this.ChildCellSelector) + `,`,
		`MaintainSync:` + fmt.Sprintf("%v", this.MaintainSync) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrRange{`,
		`SI_SeekTo:` + fmt.Sprintf("%v", this.SI_SeekTo) + `,`,
		`SI_StopAt:` + fmt.Sprintf("%v", this.SI_StopAt) + `,`,
		`SI_BatchLimit:` + fmt.Sprintf("%v", this.SI_BatchLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Txn) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMsgs := "[]*Msg{"
	for _, f := range this.Msgs {
		repeatedStringForMsgs += strings.Replace(f.String(), "Msg", "Msg", 1) + ","
	}
	repeatedStringForMsgs += "}"
	s := strings.Join([]string{`&Txn{`,
		`Msgs:` + repeatedStringForMsgs + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFix{`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Lat:` + fmt.Sprintf("%v", this.Lat) + `,`,
		`Lng:` + fmt.Sprintf("%v", this.Lng) + `,`,
		`Alt:` + fmt.Sprintf("%v", this.Alt) + `,`,
		`AltROU:` + fmt.Sprintf("%v", this.AltROU) + `,`,
		`PosROU:` + fmt.Sprintf("%v", this.PosROU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AssetRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssetRef{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`MediaType:` + fmt.Sprintf("%v", this.MediaType) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`PixWidth:` + fmt.Sprintf("%v", this.PixWidth) + `,`,
		`PixHeight:` + fmt.Sprintf("%v", this.PixHeight) + `,`,
		`PhysWidth:` + fmt.Sprintf("%v", this.PhysWidth) + `,`,
		`PhysHeight:` + fmt.Sprintf("%v", this.PhysHeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Content) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Content{`,
		`ContentData:` + fmt.Sprintf("%v", this.ContentData) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`ContentTypeID:` + fmt.Sprintf("%v", this.ContentTypeID) + `,`,
		`LinksCellID:` + fmt.Sprintf("%v", this.LinksCellID) + `,`,
		`Location:` + strings.Replace(this.Location.String(), "GeoFix", "GeoFix", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CryptoKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptoKey{`,
		`CryptoKitID:` + fmt.Sprintf("%v", this.CryptoKitID) + `,`,
		`KeyBytes:` + fmt.Sprintf("%v", this.KeyBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CellInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CellInfo{`,
		`CellDefID:` + fmt.Sprintf("%v", this.CellDefID) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Subtitle:` + fmt.Sprintf("%v", this.Subtitle) + `,`,
		`About:` + fmt.Sprintf("%v", this.About) + `,`,
		`Glyph:` + strings.Replace(this.Glyph.String(), "AssetRef", "AssetRef", 1) + `,`,
		`GlyphLarge:` + strings.Replace(this.GlyphLarge.String(), "AssetRef", "AssetRef", 1) + `,`,
		`Link:` + strings.Replace(this.Link.String(), "AssetRef", "AssetRef", 1) + `,`,
		`Created:` + fmt.Sprintf("%v", this.Created) + `,`,
		`Modified:` + fmt.Sprintf("%v", this.Modified) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TRS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TRS{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`X3:` + fmt.Sprintf("%v", this.X3) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`Scale3:` + fmt.Sprintf("%v", this.Scale3) + `,`,
		`Rotate1:` + fmt.Sprintf("%v", this.Rotate1) + `,`,
		`Rotate2:` + fmt.Sprintf("%v", this.Rotate2) + `,`,
		`Rotate3:` + fmt.Sprintf("%v", this.Rotate3) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeedParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeedParams{`,
		`UpdateIntervalMin:` + fmt.Sprintf("%v", this.UpdateIntervalMin) + `,`,
		`UpdateIntervalMax:` + fmt.Sprintf("%v", this.UpdateIntervalMax) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSegment{`,
		`ByteOfs:` + fmt.Sprintf("%v", this.ByteOfs) + `,`,
		`ByteSz:` + fmt.Sprintf("%v", this.ByteSz) + `,`,
		`InlineData:` + fmt.Sprintf("%v", this.InlineData) + `,`,
		`StreamURI:` + fmt.Sprintf("%v", this.StreamURI) + `,`,
		`BlobID:` + fmt.Sprintf("%v", this.BlobID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Err) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Err{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringArc(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= MsgOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrID", wireType)
			}
			m.AttrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI", wireType)
			}
			m.SI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValBuf = append(m.ValBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ValBuf == nil {
				m.ValBuf = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= MsgFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanetEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanetEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanetEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochTID = append(m.EpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.EpochTID == nil {
				m.EpochTID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochEntries = append(m.EpochEntries, &Msg{})
			if err := m.EpochEntries[len(m.EpochEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashResp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashResp = append(m.HashResp[:0], dAtA[iNdEx:postIndex]...)
			if m.HashResp == nil {
				m.HashResp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterDefs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterDefs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterDefs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbols = append(m.Symbols, &Symbol{})
			if err := m.Symbols[len(m.Symbols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &AttrSpec{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &CellSpec{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &ItemSelector{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefID", wireType)
			}
			m.DefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemType", wireType)
			}
			m.ElemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElemType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesType", wireType)
			}
			m.SeriesType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			m.AttrName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrName |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefID", wireType)
			}
			m.DefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CommonAttrs = append(m.CommonAttrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CommonAttrs) == 0 {
					m.CommonAttrs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CommonAttrs = append(m.CommonAttrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonAttrs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PinnedAttrs = append(m.PinnedAttrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PinnedAttrs) == 0 {
					m.PinnedAttrs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PinnedAttrs = append(m.PinnedAttrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedAttrs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefID", wireType)
			}
			m.DefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Include = append(m.Include, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Include) == 0 {
					m.Include = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Include = append(m.Include, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Exclude = append(m.Exclude, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Exclude) == 0 {
					m.Exclude = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Exclude = append(m.Exclude, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KwArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KwArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KwArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValBuf = append(m.ValBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ValBuf == nil {
				m.ValBuf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleURI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleURI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleURI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentReqID", wireType)
			}
			m.ParentReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinCell", wireType)
			}
			m.PinCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinCell |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAttrSelector", wireType)
			}
			m.ParentAttrSelector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentAttrSelector |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildCellSelector", wireType)
			}
			m.ChildCellSelector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildCellSelector |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainSync = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_SeekTo", wireType)
			}
			m.SI_SeekTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_SeekTo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_StopAt", wireType)
			}
			m.SI_StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_StopAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_BatchLimit", wireType)
			}
			m.SI_BatchLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_BatchLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Txn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Txn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Txn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &Msg{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoFix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoFix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoFix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= GeoModel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lng = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Alt = float64(math.Float64frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AltROU = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosROU = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= URIScheme(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PixWidth", wireType)
			}
			m.PixWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PixWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PixHeight", wireType)
			}
			m.PixHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PixHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysWidth", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhysWidth = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysHeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhysHeight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentData = append(m.ContentData[:0], dAtA[iNdEx:postIndex]...)
			if m.ContentData == nil {
				m.ContentData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentTypeID", wireType)
			}
			m.ContentTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentTypeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinksCellID", wireType)
			}
			m.LinksCellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinksCellID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &GeoFix{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellDefID", wireType)
			}
			m.CellDefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellDefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glyph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Glyph == nil {
				m.Glyph = &AssetRef{}
			}
			if err := m.Glyph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlyphLarge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlyphLarge == nil {
				m.GlyphLarge = &AssetRef{}
			}
			if err := m.GlyphLarge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &AssetRef{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			m.Modified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TRS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TRS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TRS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= TRS_VisualScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 63:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMin = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOfs", wireType)
			}
			m.ByteOfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteOfs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSz", wireType)
			}
			m.ByteSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobID", wireType)
			}
			m.BlobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArc = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: apis/arc/arc.proto

// package arc is an implementation-independent API for a pluggable client-server UI/UX system,
// featuring support and integration for files, media, and communication.

package arc

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_Defs Const = 0
	// TIDBinaryLen is the byte size of a Tx ID ("TID"), a hash with a leading big endian binary time index.
	//
	// This allows TIDs to be naturally sorted chronologically naturally.
	// This facilitates Tx storage and Tx syndication (time-ordered Tx playback).
	// Importantly, a TxID (32 bytes) is has a UTC16 prefix, allowing efficient LSM storage to scale to billions of Txs.
	//
	// Byte layout is designed so that TIDs are sortable by their embedded timestamp:
	//    0:6   - Standard UTC timestamp in unix seconds (big endian)
	//    6:8   - Timestamp fraction (big endian)
	//    8:32  - Signature/hash suffix.
	Const_TIDBinaryLen Const = 32
	// TIDStringLen is the ASCII-compatible string length of a (binary) TID encoded into its base32 form.
	// The encoding used is the geo-hash base32 alphabet, so that even ascii ordinal string comparisons will correctly sort encoded TIDs by time.
	Const_TIDStringLen Const = 52
	// DefaultServicePort  is the default TCP port used to expose arc.Host service.
	Const_DefaultServicePort Const = 5192
)

var Const_name = map[int32]string{
	0:    "Const_Defs",
	32:   "Const_TIDBinaryLen",
	52:   "Const_TIDStringLen",
	5192: "Const_DefaultServicePort",
}

var Const_value = map[string]int32{
	"Const_Defs":               0,
	"Const_TIDBinaryLen":       32,
	"Const_TIDStringLen":       52,
	"Const_DefaultServicePort": 5192,
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{0}
}

type TxHeader int32

const (
	TxHeader_0 TxHeader = 0
	// TxHeader heads a MsgTx serialized data store
	//   Bytes 00:03 -- Reserved (3 bytes)
	//   Bytes 03:07 -- big endian total byte size, including header (4 bytes)
	//   Bytes 07:08 -- TxMsg op code (1 byte)
	TxHeader_Size     TxHeader = 8
	TxHeader_OpOfs    TxHeader = 7
	TxHeader_OpRecvTx TxHeader = 20
	TxHeader_OpEOS    TxHeader = 24
)

var TxHeader_name = map[int32]string{
	0:  "TxHeader_0",
	8:  "TxHeader_Size",
	7:  "TxHeader_OpOfs",
	20: "TxHeader_OpRecvTx",
	24: "TxHeader_OpEOS",
}

var TxHeader_value = map[string]int32{
	"TxHeader_0":        0,
	"TxHeader_Size":     8,
	"TxHeader_OpOfs":    7,
	"TxHeader_OpRecvTx": 20,
	"TxHeader_OpEOS":    24,
}

func (TxHeader) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{1}
}

// These are hard-wired symbol IDs are required to bootstrap a new connection.
// After bootstrapping, the client uses RegisterDefs to register its symbols.
type ConstSymbol int32

const (
	ConstSymbol_nil            ConstSymbol = 0
	ConstSymbol_Err            ConstSymbol = 10
	ConstSymbol_RegisterDefs   ConstSymbol = 11
	ConstSymbol_HandleURI      ConstSymbol = 12
	ConstSymbol_PinRequest     ConstSymbol = 13
	ConstSymbol_Login          ConstSymbol = 20
	ConstSymbol_LoginChallenge ConstSymbol = 21
	ConstSymbol_LoginResponse  ConstSymbol = 22
	// Minimum symbol ID that a client is allowed to issue
	// This value sets a ceiling for the above hard-wired symbol IDs.
	ConstSymbol_IssuerInitsAt ConstSymbol = 256
)

var ConstSymbol_name = map[int32]string{
	0:   "ConstSymbol_nil",
	10:  "ConstSymbol_Err",
	11:  "ConstSymbol_RegisterDefs",
	12:  "ConstSymbol_HandleURI",
	13:  "ConstSymbol_PinRequest",
	20:  "ConstSymbol_Login",
	21:  "ConstSymbol_LoginChallenge",
	22:  "ConstSymbol_LoginResponse",
	256: "ConstSymbol_IssuerInitsAt",
}

var ConstSymbol_value = map[string]int32{
	"ConstSymbol_nil":            0,
	"ConstSymbol_Err":            10,
	"ConstSymbol_RegisterDefs":   11,
	"ConstSymbol_HandleURI":      12,
	"ConstSymbol_PinRequest":     13,
	"ConstSymbol_Login":          20,
	"ConstSymbol_LoginChallenge": 21,
	"ConstSymbol_LoginResponse":  22,
	"ConstSymbol_IssuerInitsAt":  256,
}

func (ConstSymbol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{2}
}

// ReqStatus allows a sender to express the status of a request.
type ReqStatus int32

const (
	// The request is in the process of being formed
	ReqStatus_NotStarted ReqStatus = 0
	// Denotes that the request is in progress.
	ReqStatus_Syncing ReqStatus = 1
	// Sent by the host to signal that this ReqID up to date and the client state is stable / synchronized.
	// This generally drives UI updates or other aggregate cell dependencies.
	ReqStatus_Synced ReqStatus = 2
	// From the client to host, this signals to close / cancel the op associated with ReqID.
	// From the host to client, this signals that the given request ID has been closed / discarded.
	ReqStatus_Closed ReqStatus = 3
)

var ReqStatus_name = map[int32]string{
	0: "ReqStatus_NotStarted",
	1: "ReqStatus_Syncing",
	2: "ReqStatus_Synced",
	3: "ReqStatus_Closed",
}

var ReqStatus_value = map[string]int32{
	"ReqStatus_NotStarted": 0,
	"ReqStatus_Syncing":    1,
	"ReqStatus_Synced":     2,
	"ReqStatus_Closed":     3,
}

func (ReqStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{3}
}

// CellTxOp specifies a cell transaction operation.
type CellTxOp int32

const (
	CellTxOp_MetaAttr   CellTxOp = 0
	CellTxOp_UpsertCell CellTxOp = 1
	CellTxOp_RemoveCell CellTxOp = 3
)

var CellTxOp_name = map[int32]string{
	0: "CellTxOp_MetaAttr",
	1: "CellTxOp_UpsertCell",
	3: "CellTxOp_RemoveCell",
}

var CellTxOp_value = map[string]int32{
	"CellTxOp_MetaAttr":   0,
	"CellTxOp_UpsertCell": 1,
	"CellTxOp_RemoveCell": 3,
}

func (CellTxOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{4}
}

type SeriesIndexType int32

const (
	SeriesIndexType_Literal SeriesIndexType = 0
	SeriesIndexType_Name    SeriesIndexType = 1
)

var SeriesIndexType_name = map[int32]string{
	0: "SeriesIndexType_Literal",
	1: "SeriesIndexType_Name",
}

var SeriesIndexType_value = map[string]int32{
	"SeriesIndexType_Literal": 0,
	"SeriesIndexType_Name":    1,
}

func (SeriesIndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{5}
}

type PinFlags int32

const (
	PinFlags_None PinFlags = 0
	// If set, all symbol / attr ID are native symbol IDs.
	// This is used for apps pinning cells and so are using native (not client) IDs.
	PinFlags_UseNativeSymbols PinFlags = 1
	// If set, PinnedCell.ServeState() causes this request (PinContext) to automatically close once state is pushed and synchronized.
	// Otherwise, the request remains open and the client will receive any state updates until closed.
	// This is useful when only a snapshot of the cell is needed.
	PinFlags_CloseOnSync PinFlags = 4
	// If set, a pinned cell will not send any state updates to the client.
	// This is useful when only writing to a cell and no state updates are needed.
	PinFlags_NoSync PinFlags = 8
)

var PinFlags_name = map[int32]string{
	0: "PinFlags_None",
	1: "PinFlags_UseNativeSymbols",
	4: "PinFlags_CloseOnSync",
	8: "PinFlags_NoSync",
}

var PinFlags_value = map[string]int32{
	"PinFlags_None":             0,
	"PinFlags_UseNativeSymbols": 1,
	"PinFlags_CloseOnSync":      4,
	"PinFlags_NoSync":           8,
}

func (PinFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{6}
}

// CordType describes how to interpret coordinates contained in a Position.
type CordType int32

const (
	CordType_Unspecified     CordType = 0
	CordType_Ordered         CordType = 1
	CordType_Plane_Cartesian CordType = 5
	CordType_Plane_HexEvenR  CordType = 6
	CordType_Geoid_Sphere    CordType = 10
	CordType_Geoid_WGS84     CordType = 11
)

var CordType_name = map[int32]string{
	0:  "CordType_Unspecified",
	1:  "CordType_Ordered",
	5:  "CordType_Plane_Cartesian",
	6:  "CordType_Plane_HexEvenR",
	10: "CordType_Geoid_Sphere",
	11: "CordType_Geoid_WGS84",
}

var CordType_value = map[string]int32{
	"CordType_Unspecified":     0,
	"CordType_Ordered":         1,
	"CordType_Plane_Cartesian": 5,
	"CordType_Plane_HexEvenR":  6,
	"CordType_Geoid_Sphere":    10,
	"CordType_Geoid_WGS84":     11,
}

func (CordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{7}
}

type QuadState int32

const (
	QuadState_LatentOff QuadState = 0
	QuadState_LatentOn  QuadState = 1
	QuadState_ActiveOff QuadState = 16
	QuadState_ActiveOn  QuadState = 17
)

var QuadState_name = map[int32]string{
	0:  "QuadState_LatentOff",
	1:  "QuadState_LatentOn",
	16: "QuadState_ActiveOff",
	17: "QuadState_ActiveOn",
}

var QuadState_value = map[string]int32{
	"QuadState_LatentOff": 0,
	"QuadState_LatentOn":  1,
	"QuadState_ActiveOff": 16,
	"QuadState_ActiveOn":  17,
}

func (QuadState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{8}
}

type UrlScheme int32

const (
	UrlScheme_Nil  UrlScheme = 0
	UrlScheme_Data UrlScheme = 1
	UrlScheme_Amp  UrlScheme = 2
	UrlScheme_File UrlScheme = 3
	UrlScheme_Http UrlScheme = 4
)

var UrlScheme_name = map[int32]string{
	0: "UrlScheme_Nil",
	1: "UrlScheme_Data",
	2: "UrlScheme_Amp",
	3: "UrlScheme_File",
	4: "UrlScheme_Http",
}

var UrlScheme_value = map[string]int32{
	"UrlScheme_Nil":  0,
	"UrlScheme_Data": 1,
	"UrlScheme_Amp":  2,
	"UrlScheme_File": 3,
	"UrlScheme_Http": 4,
}

func (UrlScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{9}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKit_Nil             CryptoKitID = 0
	CryptoKit_SecretBox_NaCl  CryptoKitID = 100
	CryptoKit_AsymMsg_NaCl    CryptoKitID = 101
	CryptoKit_Signing_NaCl    CryptoKitID = 102
	CryptoKit_Signing_ED25519 CryptoKitID = 202
)

var CryptoKitID_name = map[int32]string{
	0:   "CryptoKit_Nil",
	100: "CryptoKit_SecretBox_NaCl",
	101: "CryptoKit_AsymMsg_NaCl",
	102: "CryptoKit_Signing_NaCl",
	202: "CryptoKit_Signing_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKit_Nil":             0,
	"CryptoKit_SecretBox_NaCl":  100,
	"CryptoKit_AsymMsg_NaCl":    101,
	"CryptoKit_Signing_NaCl":    102,
	"CryptoKit_Signing_ED25519": 202,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{10}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_InternalErr             ErrCode = 5001
	ErrCode_UnsupportedOp           ErrCode = 5002
	ErrCode_Unimplemented           ErrCode = 5003
	ErrCode_Timeout                 ErrCode = 5004
	ErrCode_ShuttingDown            ErrCode = 5005
	ErrCode_NotConnected            ErrCode = 5006
	ErrCode_AuthFailed              ErrCode = 5007
	ErrCode_LoginFailed             ErrCode = 5008
	ErrCode_SessionExpired          ErrCode = 5009
	ErrCode_ReqNotFound             ErrCode = 5010
	ErrCode_InvalidReq              ErrCode = 5020
	ErrCode_InvalidURI              ErrCode = 5021
	ErrCode_BadValue                ErrCode = 5022
	ErrCode_NothingToCommit         ErrCode = 5030
	ErrCode_CommitFailed            ErrCode = 5031
	ErrCode_PlanetNotFound          ErrCode = 5032
	ErrCode_PlanetFailure           ErrCode = 5033
	ErrCode_AppNotFound             ErrCode = 5034
	ErrCode_DefNotFound             ErrCode = 5036
	ErrCode_MalformedTx             ErrCode = 5040
	ErrCode_TypeNotFound            ErrCode = 5050
	ErrCode_TypeNotRegistered       ErrCode = 5051
	ErrCode_BadSchema               ErrCode = 5052
	ErrCode_DataFailure             ErrCode = 5053
	ErrCode_ExportErr               ErrCode = 5054
	ErrCode_PinFailed               ErrCode = 5055
	ErrCode_PinContextClosed        ErrCode = 5056
	ErrCode_CellNotFound            ErrCode = 5058
	ErrCode_ProviderErr             ErrCode = 5059
	ErrCode_ViolatesAppendOnly      ErrCode = 5100
	ErrCode_InsufficientPermissions ErrCode = 5101
)

var ErrCode_name = map[int32]string{
	0:    "ErrCode_NoErr",
	5000: "ErrCode_UnnamedErr",
	5001: "ErrCode_InternalErr",
	5002: "ErrCode_UnsupportedOp",
	5003: "ErrCode_Unimplemented",
	5004: "ErrCode_Timeout",
	5005: "ErrCode_ShuttingDown",
	5006: "ErrCode_NotConnected",
	5007: "ErrCode_AuthFailed",
	5008: "ErrCode_LoginFailed",
	5009: "ErrCode_SessionExpired",
	5010: "ErrCode_ReqNotFound",
	5020: "ErrCode_InvalidReq",
	5021: "ErrCode_InvalidURI",
	5022: "ErrCode_BadValue",
	5030: "ErrCode_NothingToCommit",
	5031: "ErrCode_CommitFailed",
	5032: "ErrCode_PlanetNotFound",
	5033: "ErrCode_PlanetFailure",
	5034: "ErrCode_AppNotFound",
	5036: "ErrCode_DefNotFound",
	5040: "ErrCode_MalformedTx",
	5050: "ErrCode_TypeNotFound",
	5051: "ErrCode_TypeNotRegistered",
	5052: "ErrCode_BadSchema",
	5053: "ErrCode_DataFailure",
	5054: "ErrCode_ExportErr",
	5055: "ErrCode_PinFailed",
	5056: "ErrCode_PinContextClosed",
	5058: "ErrCode_CellNotFound",
	5059: "ErrCode_ProviderErr",
	5100: "ErrCode_ViolatesAppendOnly",
	5101: "ErrCode_InsufficientPermissions",
}

var ErrCode_value = map[string]int32{
	"ErrCode_NoErr":                   0,
	"ErrCode_UnnamedErr":              5000,
	"ErrCode_InternalErr":             5001,
	"ErrCode_UnsupportedOp":           5002,
	"ErrCode_Unimplemented":           5003,
	"ErrCode_Timeout":                 5004,
	"ErrCode_ShuttingDown":            5005,
	"ErrCode_NotConnected":            5006,
	"ErrCode_AuthFailed":              5007,
	"ErrCode_LoginFailed":             5008,
	"ErrCode_SessionExpired":          5009,
	"ErrCode_ReqNotFound":             5010,
	"ErrCode_InvalidReq":              5020,
	"ErrCode_InvalidURI":              5021,
	"ErrCode_BadValue":                5022,
	"ErrCode_NothingToCommit":         5030,
	"ErrCode_CommitFailed":            5031,
	"ErrCode_PlanetNotFound":          5032,
	"ErrCode_PlanetFailure":           5033,
	"ErrCode_AppNotFound":             5034,
	"ErrCode_DefNotFound":             5036,
	"ErrCode_MalformedTx":             5040,
	"ErrCode_TypeNotFound":            5050,
	"ErrCode_TypeNotRegistered":       5051,
	"ErrCode_BadSchema":               5052,
	"ErrCode_DataFailure":             5053,
	"ErrCode_ExportErr":               5054,
	"ErrCode_PinFailed":               5055,
	"ErrCode_PinContextClosed":        5056,
	"ErrCode_CellNotFound":            5058,
	"ErrCode_ProviderErr":             5059,
	"ErrCode_ViolatesAppendOnly":      5100,
	"ErrCode_InsufficientPermissions": 5101,
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{11}
}

type LogLevel int32

const (
	LogLevel_Error LogLevel = 0
	LogLevel_Warn  LogLevel = 2
	LogLevel_Info  LogLevel = 4
)

var LogLevel_name = map[int32]string{
	0: "LogLevel_Error",
	2: "LogLevel_Warn",
	4: "LogLevel_Info",
}

var LogLevel_value = map[string]int32{
	"LogLevel_Error": 0,
	"LogLevel_Warn":  2,
	"LogLevel_Info":  4,
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{12}
}

type TRS_VisualScaleMode int32

const (
	AutoScale  TRS_VisualScaleMode = 0
	FixedScale TRS_VisualScaleMode = 1
)

var TRS_VisualScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var TRS_VisualScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (TRS_VisualScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{19, 0}
}

// Msg is thw workhorse generic transport serialization sent between client and host.
type Msg struct {
	// ReqID names an originating request ID, issued by client using an atomic counter.
	//
	// For example, if a Msg is a reply to some request, ReqID identifies the originating request\.
	ReqID uint64 `protobuf:"varint,1,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// Status communicates request status / completion.
	Status ReqStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=arc.ReqStatus" json:"Status,omitempty"`
	// CellTxs is a Cell state update as well as session meta-messaging mechanism.
	CellTxs []*CellTxPb `protobuf:"bytes,5,rep,name=CellTxs,proto3" json:"CellTxs,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetReqID() uint64 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *Msg) GetStatus() ReqStatus {
	if m != nil {
		return m.Status
	}
	return ReqStatus_NotStarted
}

func (m *Msg) GetCellTxs() []*CellTxPb {
	if m != nil {
		return m.CellTxs
	}
	return nil
}

// CellTxPb is a cell transaction, a unit of change (or meta message) for a cell.
type CellTxPb struct {
	Op CellTxOp `protobuf:"varint,1,opt,name=Op,proto3,enum=arc.CellTxOp" json:"Op,omitempty"`
	// Target CellID
	// If CellID_1 == 0, then this cell is ephemeral (vs persistent).
	CellID_0 uint64        `protobuf:"fixed64,3,opt,name=CellID_0,json=CellID0,proto3" json:"CellID_0,omitempty"`
	CellID_1 uint64        `protobuf:"fixed64,4,opt,name=CellID_1,json=CellID1,proto3" json:"CellID_1,omitempty"`
	Elems    []*AttrElemPb `protobuf:"bytes,8,rep,name=Elems,proto3" json:"Elems,omitempty"`
}

func (m *CellTxPb) Reset()      { *m = CellTxPb{} }
func (*CellTxPb) ProtoMessage() {}
func (*CellTxPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{1}
}
func (m *CellTxPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellTxPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellTxPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellTxPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellTxPb.Merge(m, src)
}
func (m *CellTxPb) XXX_Size() int {
	return m.Size()
}
func (m *CellTxPb) XXX_DiscardUnknown() {
	xxx_messageInfo_CellTxPb.DiscardUnknown(m)
}

var xxx_messageInfo_CellTxPb proto.InternalMessageInfo

func (m *CellTxPb) GetOp() CellTxOp {
	if m != nil {
		return m.Op
	}
	return CellTxOp_MetaAttr
}

func (m *CellTxPb) GetCellID_0() uint64 {
	if m != nil {
		return m.CellID_0
	}
	return 0
}

func (m *CellTxPb) GetCellID_1() uint64 {
	if m != nil {
		return m.CellID_1
	}
	return 0
}

func (m *CellTxPb) GetElems() []*AttrElemPb {
	if m != nil {
		return m.Elems
	}
	return nil
}

// Serialization helper for AttrElem
type AttrElemPb struct {
	// AttrID of the attr being updated (64 bits for future proofing)
	AttrID uint64 `protobuf:"varint,1,opt,name=AttrID,proto3" json:"AttrID,omitempty"`
	// Serialized value of the attr element -- IAW AttrID
	ValBuf []byte `protobuf:"bytes,2,opt,name=ValBuf,proto3" json:"ValBuf,omitempty"`
	// Series index (if applicable)
	SI int64 `protobuf:"varint,3,opt,name=SI,proto3" json:"SI,omitempty"`
}

func (m *AttrElemPb) Reset()      { *m = AttrElemPb{} }
func (*AttrElemPb) ProtoMessage() {}
func (*AttrElemPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{2}
}
func (m *AttrElemPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrElemPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrElemPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrElemPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrElemPb.Merge(m, src)
}
func (m *AttrElemPb) XXX_Size() int {
	return m.Size()
}
func (m *AttrElemPb) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrElemPb.DiscardUnknown(m)
}

var xxx_messageInfo_AttrElemPb proto.InternalMessageInfo

func (m *AttrElemPb) GetAttrID() uint64 {
	if m != nil {
		return m.AttrID
	}
	return 0
}

func (m *AttrElemPb) GetValBuf() []byte {
	if m != nil {
		return m.ValBuf
	}
	return nil
}

func (m *AttrElemPb) GetSI() int64 {
	if m != nil {
		return m.SI
	}
	return 0
}

type Login struct {
	// A byte string identifying user who is logging in (lot limited to UTF8)
	// This is typically a username or a persistent UID issued by the device OS when the app is (re)installed.
	UserUID string `protobuf:"bytes,1,opt,name=UserUID,proto3" json:"UserUID,omitempty"`
	// HostAddr is network address of the server known to the client (e.g. IP address, localhost, domain name, etc)
	// Archost uses this to as the host name when serving URLs for the client to consume.
	HostAddr    string `protobuf:"bytes,2,opt,name=HostAddr,proto3" json:"HostAddr,omitempty"`
	DeviceLabel string `protobuf:"bytes,8,opt,name=DeviceLabel,proto3" json:"DeviceLabel,omitempty"`
	DeviceUID   string `protobuf:"bytes,9,opt,name=DeviceUID,proto3" json:"DeviceUID,omitempty"`
}

func (m *Login) Reset()      { *m = Login{} }
func (*Login) ProtoMessage() {}
func (*Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{3}
}
func (m *Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Login.Merge(m, src)
}
func (m *Login) XXX_Size() int {
	return m.Size()
}
func (m *Login) XXX_DiscardUnknown() {
	xxx_messageInfo_Login.DiscardUnknown(m)
}

var xxx_messageInfo_Login proto.InternalMessageInfo

func (m *Login) GetUserUID() string {
	if m != nil {
		return m.UserUID
	}
	return ""
}

func (m *Login) GetHostAddr() string {
	if m != nil {
		return m.HostAddr
	}
	return ""
}

func (m *Login) GetDeviceLabel() string {
	if m != nil {
		return m.DeviceLabel
	}
	return ""
}

func (m *Login) GetDeviceUID() string {
	if m != nil {
		return m.DeviceUID
	}
	return ""
}

// LoginChallenge is sent from host to client in response to a Login message
type LoginChallenge struct {
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
}

func (m *LoginChallenge) Reset()      { *m = LoginChallenge{} }
func (*LoginChallenge) ProtoMessage() {}
func (*LoginChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{4}
}
func (m *LoginChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginChallenge.Merge(m, src)
}
func (m *LoginChallenge) XXX_Size() int {
	return m.Size()
}
func (m *LoginChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_LoginChallenge proto.InternalMessageInfo

func (m *LoginChallenge) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// LoginChallenge is sent from client to host in response to a LoginChallenge message
type LoginResponse struct {
	HashResp []byte `protobuf:"bytes,1,opt,name=HashResp,proto3" json:"HashResp,omitempty"`
}

func (m *LoginResponse) Reset()      { *m = LoginResponse{} }
func (*LoginResponse) ProtoMessage() {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{5}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetHashResp() []byte {
	if m != nil {
		return m.HashResp
	}
	return nil
}

type Symbol struct {
	// A symbol ID is 32 bits and corresponds to a real-world const byte strings.
	// FUTURE: IDs are int64, where client symbols IDs are < 0 and native symbols are > 0.
	ID   uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name []byte `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *Symbol) Reset()      { *m = Symbol{} }
func (*Symbol) ProtoMessage() {}
func (*Symbol) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{6}
}
func (m *Symbol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Symbol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Symbol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Symbol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Symbol.Merge(m, src)
}
func (m *Symbol) XXX_Size() int {
	return m.Size()
}
func (m *Symbol) XXX_DiscardUnknown() {
	xxx_messageInfo_Symbol.DiscardUnknown(m)
}

var xxx_messageInfo_Symbol proto.InternalMessageInfo

func (m *Symbol) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Symbol) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// RegisterDefs is sent by a client to register its symbols and schemas during a session.
type RegisterDefs struct {
	Symbols   []*Symbol       `protobuf:"bytes,1,rep,name=Symbols,proto3" json:"Symbols,omitempty"`
	Attrs     []*AttrSpec     `protobuf:"bytes,2,rep,name=Attrs,proto3" json:"Attrs,omitempty"`
	Selectors []*ItemSelector `protobuf:"bytes,4,rep,name=Selectors,proto3" json:"Selectors,omitempty"`
}

func (m *RegisterDefs) Reset()      { *m = RegisterDefs{} }
func (*RegisterDefs) ProtoMessage() {}
func (*RegisterDefs) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{7}
}
func (m *RegisterDefs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterDefs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterDefs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterDefs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterDefs.Merge(m, src)
}
func (m *RegisterDefs) XXX_Size() int {
	return m.Size()
}
func (m *RegisterDefs) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterDefs.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterDefs proto.InternalMessageInfo

func (m *RegisterDefs) GetSymbols() []*Symbol {
	if m != nil {
		return m.Symbols
	}
	return nil
}

func (m *RegisterDefs) GetAttrs() []*AttrSpec {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *RegisterDefs) GetSelectors() []*ItemSelector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

// AttrSpec fully describes a cell attribute, specifying a name, element type, and series element type.
type AttrSpec struct {
	// Composite expression / invocation of this AttrSpec in the form:
	//      "[{SeriesSpec}]{ElemType}:{AttrName}"
	//
	// This the value is used for Msg.AttrID -- it references an AttrSpec.
	// e.g. "AmpTag", "AmpTag:promo", "[UTC16]Position:past-promo-shoots",
	DefID uint32 `protobuf:"varint,1,opt,name=DefID,proto3" json:"DefID,omitempty"`
	// ElemType identifies this attr's element type and has a form like a subdomain:
	//    "({subTypeName}.)*<typeName>"
	//
	// A particular ElemType corresponds to a serializable data type (typically a protobuf or capnp message)
	// Valid chars are [A-Za-z0-9_-] in addition to '.' that separates identifiers..
	//
	// e.g.
	//    "AmpTag",
	//    "GreetingAttr.tutorial_06.hello-world.learn.arcspace.systems",
	ElemType uint32 `protobuf:"varint,3,opt,name=ElemType,proto3" json:"ElemType,omitempty"`
	// SeriesSpec specifies how to interpret an attr's SeriesIndex int64 value ("SI") and has the form:
	//    "{SeriesName}[.{SeriesIndexType}]"
	//
	// A SeriesSpec includes its underlying SeriesType as a suffix, telling the host to perform necessary handling.
	// If SeriesSpec is omitted, this attr is a scalar value (and SI is 0 assumed).
	//
	// UTC16 and Secs16 are 48.16 fixed signed fractional seconds (one second == 0x10000 ticks), naming a time duration or timestamp.
	// When naming an absolute timestamp, unix UTC is assumed (0x10000 corresponds to 00:00:01, Jan 1 1970 GMT)
	//
	// e.g. "", "UTC16", "Secs16", "Int64", "Locale.Name" -- FUTURE "GeoHash", "NodeID", "TID"
	SeriesSpec uint32 `protobuf:"varint,4,opt,name=SeriesSpec,proto3" json:"SeriesSpec,omitempty"`
	// SeriesIndexType tells the host how to handle and process attr series index values.
	// If SeriesSpec is omitted (SeriesSpec = 0), SI index values are considered literals (SeriesIndexType_Literal).
	SeriesIndexType SeriesIndexType `protobuf:"varint,5,opt,name=SeriesIndexType,proto3,enum=arc.SeriesIndexType" json:"SeriesIndexType,omitempty"`
	// AttrName differentiates an attribute from others having the same ElemType and SeriesSpec
	//   - Unnamed attrs are common and typically are used to denote a characterizing cell attribute.
	//   - By convention, attr names of series are plural, and reflects that the attr is intended to contain multiple entries (e.g. "[Locale.Name]Labels")
	//   - Valid chars consist of [A-Za-z0-9_-] ('.' is not allowed)
	//
	// e.g. "", "playable", "mini", "1440p"
	AttrName uint32 `protobuf:"varint,6,opt,name=AttrName,proto3" json:"AttrName,omitempty"`
}

func (m *AttrSpec) Reset()      { *m = AttrSpec{} }
func (*AttrSpec) ProtoMessage() {}
func (*AttrSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{8}
}
func (m *AttrSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrSpec.Merge(m, src)
}
func (m *AttrSpec) XXX_Size() int {
	return m.Size()
}
func (m *AttrSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AttrSpec proto.InternalMessageInfo

func (m *AttrSpec) GetDefID() uint32 {
	if m != nil {
		return m.DefID
	}
	return 0
}

func (m *AttrSpec) GetElemType() uint32 {
	if m != nil {
		return m.ElemType
	}
	return 0
}

func (m *AttrSpec) GetSeriesSpec() uint32 {
	if m != nil {
		return m.SeriesSpec
	}
	return 0
}

func (m *AttrSpec) GetSeriesIndexType() SeriesIndexType {
	if m != nil {
		return m.SeriesIndexType
	}
	return SeriesIndexType_Literal
}

func (m *AttrSpec) GetAttrName() uint32 {
	if m != nil {
		return m.AttrName
	}
	return 0
}

// ItemSelector selects / filters a srt of items (AttrSpec descriptors)
type ItemSelector struct {
	// Composite expression of this ItemSelector in the form:
	//      "(Include[0],Include[1],..)~(Exclude[0],Exclude[1],..)"
	//
	DefID uint32 `protobuf:"varint,1,opt,name=DefID,proto3" json:"DefID,omitempty"`
	// A set of descriptor IDs explicitly included
	Include []uint32 `protobuf:"varint,4,rep,packed,name=Include,proto3" json:"Include,omitempty"`
	// A set of descriptor IDs explicitly excluded
	Exclude []uint32 `protobuf:"varint,5,rep,packed,name=Exclude,proto3" json:"Exclude,omitempty"`
}

func (m *ItemSelector) Reset()      { *m = ItemSelector{} }
func (*ItemSelector) ProtoMessage() {}
func (*ItemSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{9}
}
func (m *ItemSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemSelector.Merge(m, src)
}
func (m *ItemSelector) XXX_Size() int {
	return m.Size()
}
func (m *ItemSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemSelector.DiscardUnknown(m)
}

var xxx_messageInfo_ItemSelector proto.InternalMessageInfo

func (m *ItemSelector) GetDefID() uint32 {
	if m != nil {
		return m.DefID
	}
	return 0
}

func (m *ItemSelector) GetInclude() []uint32 {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *ItemSelector) GetExclude() []uint32 {
	if m != nil {
		return m.Exclude
	}
	return nil
}

// HandleURI is used as a meta attribute to request a URI is handled, such as an oauth request (host to client) or an oauth response (client to host).
type HandleURI struct {
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
}

func (m *HandleURI) Reset()      { *m = HandleURI{} }
func (*HandleURI) ProtoMessage() {}
func (*HandleURI) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{10}
}
func (m *HandleURI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleURI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleURI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleURI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleURI.Merge(m, src)
}
func (m *HandleURI) XXX_Size() int {
	return m.Size()
}
func (m *HandleURI) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleURI.DiscardUnknown(m)
}

var xxx_messageInfo_HandleURI proto.InternalMessageInfo

func (m *HandleURI) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// PinRequest is a client request to "pin" a cell, meaning selected attrs and child cells will be pushed to the client.
type PinRequest struct {
	// ParentReqID, if set, provides context for this request and is typically needed when pinning a cell by ID alone.
	// Not set if PinURL and/or PinCellID implies that no parent req exists.
	ParentReqID uint64 `protobuf:"varint,1,opt,name=ParentReqID,proto3" json:"ParentReqID,omitempty"`
	// URL specifying the cell to be pinned and whose child cells are to be pushed.
	// Typically: [[arc://]arc-app-uri/]cell-uri..
	PinURL string `protobuf:"bytes,2,opt,name=PinURL,proto3" json:"PinURL,omitempty"`
	// Pins a cell specified by its 16 byte ID and is typically a child cell of a pinned cell implied by ParentReqID.
	// These values are 0 if PinURL is nil or does not require a CellID.
	PinCellIDx0 uint64 `protobuf:"varint,3,opt,name=PinCellIDx0,proto3" json:"PinCellIDx0,omitempty"`
	PinCellIDx1 uint64 `protobuf:"varint,4,opt,name=PinCellIDx1,proto3" json:"PinCellIDx1,omitempty"`
	// If set, specifies an ItemSelector that filters which attrs of the pinned cell are pushed to the client.
	ParentAttrSelector uint32 `protobuf:"varint,5,opt,name=ParentAttrSelector,proto3" json:"ParentAttrSelector,omitempty"`
	// If set, specifies an ItemSelector that filters which child cells are pushed to the client.
	ChildCellSelector uint32 `protobuf:"varint,6,opt,name=ChildCellSelector,proto3" json:"ChildCellSelector,omitempty"`
	// Flags specifies options.
	Flags PinFlags `protobuf:"varint,7,opt,name=Flags,proto3,enum=arc.PinFlags" json:"Flags,omitempty"`
}

func (m *PinRequest) Reset()      { *m = PinRequest{} }
func (*PinRequest) ProtoMessage() {}
func (*PinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{11}
}
func (m *PinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinRequest.Merge(m, src)
}
func (m *PinRequest) XXX_Size() int {
	return m.Size()
}
func (m *PinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PinRequest proto.InternalMessageInfo

func (m *PinRequest) GetParentReqID() uint64 {
	if m != nil {
		return m.ParentReqID
	}
	return 0
}

func (m *PinRequest) GetPinURL() string {
	if m != nil {
		return m.PinURL
	}
	return ""
}

func (m *PinRequest) GetPinCellIDx0() uint64 {
	if m != nil {
		return m.PinCellIDx0
	}
	return 0
}

func (m *PinRequest) GetPinCellIDx1() uint64 {
	if m != nil {
		return m.PinCellIDx1
	}
	return 0
}

func (m *PinRequest) GetParentAttrSelector() uint32 {
	if m != nil {
		return m.ParentAttrSelector
	}
	return 0
}

func (m *PinRequest) GetChildCellSelector() uint32 {
	if m != nil {
		return m.ChildCellSelector
	}
	return 0
}

func (m *PinRequest) GetFlags() PinFlags {
	if m != nil {
		return m.Flags
	}
	return PinFlags_None
}

// Position describes a position in space and/or time using a given coordinate system.
type Position struct {
	CordType CordType `protobuf:"varint,1,opt,name=CordType,proto3,enum=arc.CordType" json:"CordType,omitempty"`
	U        float64  `protobuf:"fixed64,3,opt,name=U,proto3" json:"U,omitempty"`
	V        float64  `protobuf:"fixed64,4,opt,name=V,proto3" json:"V,omitempty"`
	W        float64  `protobuf:"fixed64,5,opt,name=W,proto3" json:"W,omitempty"`
	ROU      float32  `protobuf:"fixed32,6,opt,name=ROU,proto3" json:"ROU,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{12}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetCordType() CordType {
	if m != nil {
		return m.CordType
	}
	return CordType_Unspecified
}

func (m *Position) GetU() float64 {
	if m != nil {
		return m.U
	}
	return 0
}

func (m *Position) GetV() float64 {
	if m != nil {
		return m.V
	}
	return 0
}

func (m *Position) GetW() float64 {
	if m != nil {
		return m.W
	}
	return 0
}

func (m *Position) GetROU() float32 {
	if m != nil {
		return m.ROU
	}
	return 0
}

type AmpTag struct {
	State       QuadState `protobuf:"varint,3,opt,name=State,proto3,enum=arc.QuadState" json:"State,omitempty"`
	ContentType string    `protobuf:"bytes,5,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	URI         string    `protobuf:"bytes,7,opt,name=URI,proto3" json:"URI,omitempty"`
	UIDx0       uint64    `protobuf:"fixed64,16,opt,name=UIDx0,proto3" json:"UIDx0,omitempty"`
	UIDx1       uint64    `protobuf:"fixed64,17,opt,name=UIDx1,proto3" json:"UIDx1,omitempty"`
	UIDx2       uint64    `protobuf:"fixed64,18,opt,name=UIDx2,proto3" json:"UIDx2,omitempty"`
	Rx0         float32   `protobuf:"fixed32,20,opt,name=Rx0,proto3" json:"Rx0,omitempty"`
	Rx1         float32   `protobuf:"fixed32,21,opt,name=Rx1,proto3" json:"Rx1,omitempty"`
	Rx2         float32   `protobuf:"fixed32,22,opt,name=Rx2,proto3" json:"Rx2,omitempty"`
	PixelWidth  int32     `protobuf:"varint,28,opt,name=PixelWidth,proto3" json:"PixelWidth,omitempty"`
	PixelHeight int32     `protobuf:"varint,29,opt,name=PixelHeight,proto3" json:"PixelHeight,omitempty"`
	MeterScale  float32   `protobuf:"fixed32,30,opt,name=MeterScale,proto3" json:"MeterScale,omitempty"`
	SubTags     []*AmpTag `protobuf:"bytes,2,rep,name=SubTags,proto3" json:"SubTags,omitempty"`
}

func (m *AmpTag) Reset()      { *m = AmpTag{} }
func (*AmpTag) ProtoMessage() {}
func (*AmpTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{13}
}
func (m *AmpTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AmpTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AmpTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AmpTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmpTag.Merge(m, src)
}
func (m *AmpTag) XXX_Size() int {
	return m.Size()
}
func (m *AmpTag) XXX_DiscardUnknown() {
	xxx_messageInfo_AmpTag.DiscardUnknown(m)
}

var xxx_messageInfo_AmpTag proto.InternalMessageInfo

func (m *AmpTag) GetState() QuadState {
	if m != nil {
		return m.State
	}
	return QuadState_LatentOff
}

func (m *AmpTag) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *AmpTag) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *AmpTag) GetUIDx0() uint64 {
	if m != nil {
		return m.UIDx0
	}
	return 0
}

func (m *AmpTag) GetUIDx1() uint64 {
	if m != nil {
		return m.UIDx1
	}
	return 0
}

func (m *AmpTag) GetUIDx2() uint64 {
	if m != nil {
		return m.UIDx2
	}
	return 0
}

func (m *AmpTag) GetRx0() float32 {
	if m != nil {
		return m.Rx0
	}
	return 0
}

func (m *AmpTag) GetRx1() float32 {
	if m != nil {
		return m.Rx1
	}
	return 0
}

func (m *AmpTag) GetRx2() float32 {
	if m != nil {
		return m.Rx2
	}
	return 0
}

func (m *AmpTag) GetPixelWidth() int32 {
	if m != nil {
		return m.PixelWidth
	}
	return 0
}

func (m *AmpTag) GetPixelHeight() int32 {
	if m != nil {
		return m.PixelHeight
	}
	return 0
}

func (m *AmpTag) GetMeterScale() float32 {
	if m != nil {
		return m.MeterScale
	}
	return 0
}

func (m *AmpTag) GetSubTags() []*AmpTag {
	if m != nil {
		return m.SubTags
	}
	return nil
}

type SheetInfo struct {
	// Sheet.Series.AVPlaylist
	// Sheet.Series.AttrTuple           -- expects series with ElemType: .AttrSet
	// Sheet.Series.Spreadsheet         -- expects series with Addr.desc: .xy, ElemType.  ??
	// Sheet.Series.Surface.Geo         -- expects series with Addr.desc: .wsg84
	// Sheet.Series.Surface.Grid.Ortho  -- expects series with Addr.desc: .xy
	// Sheet.Series.Surface.Grid.Hex    -- expects series with Addr.desc: .qr
	// Sheet.WebBrowser                 -- expects series whose elements are URLs
	AppSheetURI string `protobuf:"bytes,1,opt,name=AppSheetURI,proto3" json:"AppSheetURI,omitempty"`
	// Bound attr series (e.g. a spreadsheet's columns)
	BoundSeries []*AttrSpec `protobuf:"bytes,3,rep,name=BoundSeries,proto3" json:"BoundSeries,omitempty"`
}

func (m *SheetInfo) Reset()      { *m = SheetInfo{} }
func (*SheetInfo) ProtoMessage() {}
func (*SheetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{14}
}
func (m *SheetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SheetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SheetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SheetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SheetInfo.Merge(m, src)
}
func (m *SheetInfo) XXX_Size() int {
	return m.Size()
}
func (m *SheetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SheetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SheetInfo proto.InternalMessageInfo

func (m *SheetInfo) GetAppSheetURI() string {
	if m != nil {
		return m.AppSheetURI
	}
	return ""
}

func (m *SheetInfo) GetBoundSeries() []*AttrSpec {
	if m != nil {
		return m.BoundSeries
	}
	return nil
}

type SheetGroup struct {
	SheetCatalog []*SheetInfo `protobuf:"bytes,1,rep,name=SheetCatalog,proto3" json:"SheetCatalog,omitempty"`
}

func (m *SheetGroup) Reset()      { *m = SheetGroup{} }
func (*SheetGroup) ProtoMessage() {}
func (*SheetGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{15}
}
func (m *SheetGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SheetGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SheetGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SheetGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SheetGroup.Merge(m, src)
}
func (m *SheetGroup) XXX_Size() int {
	return m.Size()
}
func (m *SheetGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SheetGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SheetGroup proto.InternalMessageInfo

func (m *SheetGroup) GetSheetCatalog() []*SheetInfo {
	if m != nil {
		return m.SheetCatalog
	}
	return nil
}

type CryptoKey struct {
	CryptoKitID CryptoKitID `protobuf:"varint,1,opt,name=CryptoKitID,proto3,enum=arc.CryptoKitID" json:"CryptoKitID,omitempty"`
	KeyBytes    []byte      `protobuf:"bytes,4,opt,name=KeyBytes,proto3" json:"KeyBytes,omitempty"`
}

func (m *CryptoKey) Reset()      { *m = CryptoKey{} }
func (*CryptoKey) ProtoMessage() {}
func (*CryptoKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{16}
}
func (m *CryptoKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoKey.Merge(m, src)
}
func (m *CryptoKey) XXX_Size() int {
	return m.Size()
}
func (m *CryptoKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoKey.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoKey proto.InternalMessageInfo

func (m *CryptoKey) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKit_Nil
}

func (m *CryptoKey) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

// CellHeader is a standard attribute for a cell that is presented .
// An arc.App fills in what is appropriate and leaves the rest blank.
type CellHeader struct {
	Title    string `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Subtitle string `protobuf:"bytes,3,opt,name=Subtitle,proto3" json:"Subtitle,omitempty"`
	About    string `protobuf:"bytes,4,opt,name=About,proto3" json:"About,omitempty"`
	// A Glyph is a representative image or 3D graphic similar to an icon in function.
	Glyphs   []*AmpTag `protobuf:"bytes,6,rep,name=Glyphs,proto3" json:"Glyphs,omitempty"`
	Created  int64     `protobuf:"varint,8,opt,name=Created,proto3" json:"Created,omitempty"`
	Modified int64     `protobuf:"varint,9,opt,name=Modified,proto3" json:"Modified,omitempty"`
	// If set, this (typically https:// or amp://) to reproduce this cell (with given archost session)
	CellURL string `protobuf:"bytes,20,opt,name=CellURL,proto3" json:"CellURL,omitempty"`
	// Extensible and persistent link, can be any URL -- typically passed to another application or shared with a another human.
	// E.g. if 'arc://...', this denotes a pinnable URI -- but could be any pinnable URL: ipfs://, https://, ...
	// But also UI button or settings URI.
	ExternalLink *AmpTag `protobuf:"bytes,22,opt,name=ExternalLink,proto3" json:"ExternalLink,omitempty"`
}

func (m *CellHeader) Reset()      { *m = CellHeader{} }
func (*CellHeader) ProtoMessage() {}
func (*CellHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{17}
}
func (m *CellHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellHeader.Merge(m, src)
}
func (m *CellHeader) XXX_Size() int {
	return m.Size()
}
func (m *CellHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_CellHeader.DiscardUnknown(m)
}

var xxx_messageInfo_CellHeader proto.InternalMessageInfo

func (m *CellHeader) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CellHeader) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *CellHeader) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *CellHeader) GetGlyphs() []*AmpTag {
	if m != nil {
		return m.Glyphs
	}
	return nil
}

func (m *CellHeader) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CellHeader) GetModified() int64 {
	if m != nil {
		return m.Modified
	}
	return 0
}

func (m *CellHeader) GetCellURL() string {
	if m != nil {
		return m.CellURL
	}
	return ""
}

func (m *CellHeader) GetExternalLink() *AmpTag {
	if m != nil {
		return m.ExternalLink
	}
	return nil
}

// AuthToken is an oauth token -- see oauth2.Token
type AuthToken struct {
	AccessToken  string `protobuf:"bytes,1,opt,name=AccessToken,proto3" json:"AccessToken,omitempty"`
	TokenType    string `protobuf:"bytes,2,opt,name=TokenType,proto3" json:"TokenType,omitempty"`
	RefreshToken string `protobuf:"bytes,3,opt,name=RefreshToken,proto3" json:"RefreshToken,omitempty"`
	Expiry       int64  `protobuf:"varint,4,opt,name=Expiry,proto3" json:"Expiry,omitempty"`
}

func (m *AuthToken) Reset()      { *m = AuthToken{} }
func (*AuthToken) ProtoMessage() {}
func (*AuthToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{18}
}
func (m *AuthToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthToken.Merge(m, src)
}
func (m *AuthToken) XXX_Size() int {
	return m.Size()
}
func (m *AuthToken) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthToken.DiscardUnknown(m)
}

var xxx_messageInfo_AuthToken proto.InternalMessageInfo

func (m *AuthToken) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *AuthToken) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *AuthToken) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *AuthToken) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type TRS struct {
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Specifies how scale dynamically changes based on observer position.
	ScaleMode TRS_VisualScaleMode `protobuf:"varint,50,opt,name=ScaleMode,proto3,enum=arc.TRS_VisualScaleMode" json:"ScaleMode,omitempty"`
	// Scale1..3 express the scale of this placement.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this placement using Euler angles.
	Rotate1 float32 `protobuf:"fixed32,61,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2 float32 `protobuf:"fixed32,62,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3 float32 `protobuf:"fixed32,63,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
}

func (m *TRS) Reset()      { *m = TRS{} }
func (*TRS) ProtoMessage() {}
func (*TRS) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{19}
}
func (m *TRS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TRS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TRS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TRS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TRS.Merge(m, src)
}
func (m *TRS) XXX_Size() int {
	return m.Size()
}
func (m *TRS) XXX_DiscardUnknown() {
	xxx_messageInfo_TRS.DiscardUnknown(m)
}

var xxx_messageInfo_TRS proto.InternalMessageInfo

func (m *TRS) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *TRS) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *TRS) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *TRS) GetScaleMode() TRS_VisualScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return AutoScale
}

func (m *TRS) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *TRS) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *TRS) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *TRS) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *TRS) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *TRS) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

type FeedParams struct {
	UpdateIntervalMin float32 `protobuf:"fixed32,2,opt,name=UpdateIntervalMin,proto3" json:"UpdateIntervalMin,omitempty"`
	UpdateIntervalMax float32 `protobuf:"fixed32,3,opt,name=UpdateIntervalMax,proto3" json:"UpdateIntervalMax,omitempty"`
}

func (m *FeedParams) Reset()      { *m = FeedParams{} }
func (*FeedParams) ProtoMessage() {}
func (*FeedParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{20}
}
func (m *FeedParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedParams.Merge(m, src)
}
func (m *FeedParams) XXX_Size() int {
	return m.Size()
}
func (m *FeedParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedParams.DiscardUnknown(m)
}

var xxx_messageInfo_FeedParams proto.InternalMessageInfo

func (m *FeedParams) GetUpdateIntervalMin() float32 {
	if m != nil {
		return m.UpdateIntervalMin
	}
	return 0
}

func (m *FeedParams) GetUpdateIntervalMax() float32 {
	if m != nil {
		return m.UpdateIntervalMax
	}
	return 0
}

type DataSegment struct {
	ByteOfs    uint64 `protobuf:"varint,5,opt,name=ByteOfs,proto3" json:"ByteOfs,omitempty"`
	ByteSz     uint64 `protobuf:"varint,6,opt,name=ByteSz,proto3" json:"ByteSz,omitempty"`
	InlineData []byte `protobuf:"bytes,7,opt,name=InlineData,proto3" json:"InlineData,omitempty"`
	StreamURI  string `protobuf:"bytes,9,opt,name=StreamURI,proto3" json:"StreamURI,omitempty"`
	BlobID     int64  `protobuf:"varint,10,opt,name=BlobID,proto3" json:"BlobID,omitempty"`
}

func (m *DataSegment) Reset()      { *m = DataSegment{} }
func (*DataSegment) ProtoMessage() {}
func (*DataSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{21}
}
func (m *DataSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSegment.Merge(m, src)
}
func (m *DataSegment) XXX_Size() int {
	return m.Size()
}
func (m *DataSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSegment.DiscardUnknown(m)
}

var xxx_messageInfo_DataSegment proto.InternalMessageInfo

func (m *DataSegment) GetByteOfs() uint64 {
	if m != nil {
		return m.ByteOfs
	}
	return 0
}

func (m *DataSegment) GetByteSz() uint64 {
	if m != nil {
		return m.ByteSz
	}
	return 0
}

func (m *DataSegment) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

func (m *DataSegment) GetStreamURI() string {
	if m != nil {
		return m.StreamURI
	}
	return ""
}

func (m *DataSegment) GetBlobID() int64 {
	if m != nil {
		return m.BlobID
	}
	return 0
}

// Err is a general purpose error / warning / log message.
type Err struct {
	// Identifies the type of error.
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=arc.ErrCode" json:"Code,omitempty"`
	// Severity level
	Level LogLevel `protobuf:"varint,2,opt,name=Level,proto3,enum=arc.LogLevel" json:"Level,omitempty"`
	// human-readable info
	Msg string `protobuf:"bytes,4,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *Err) Reset()      { *m = Err{} }
func (*Err) ProtoMessage() {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4a0eb974cf54c93, []int{22}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *Err) GetLevel() LogLevel {
	if m != nil {
		return m.Level
	}
	return LogLevel_Error
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("arc.Const", Const_name, Const_value)
	proto.RegisterEnum("arc.TxHeader", TxHeader_name, TxHeader_value)
	proto.RegisterEnum("arc.ConstSymbol", ConstSymbol_name, ConstSymbol_value)
	proto.RegisterEnum("arc.ReqStatus", ReqStatus_name, ReqStatus_value)
	proto.RegisterEnum("arc.CellTxOp", CellTxOp_name, CellTxOp_value)
	proto.RegisterEnum("arc.SeriesIndexType", SeriesIndexType_name, SeriesIndexType_value)
	proto.RegisterEnum("arc.PinFlags", PinFlags_name, PinFlags_value)
	proto.RegisterEnum("arc.CordType", CordType_name, CordType_value)
	proto.RegisterEnum("arc.QuadState", QuadState_name, QuadState_value)
	proto.RegisterEnum("arc.UrlScheme", UrlScheme_name, UrlScheme_value)
	proto.RegisterEnum("arc.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("arc.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("arc.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterEnum("arc.TRS_VisualScaleMode", TRS_VisualScaleMode_name, TRS_VisualScaleMode_value)
	proto.RegisterType((*Msg)(nil), "arc.Msg")
	proto.RegisterType((*CellTxPb)(nil), "arc.CellTxPb")
	proto.RegisterType((*AttrElemPb)(nil), "arc.AttrElemPb")
	proto.RegisterType((*Login)(nil), "arc.Login")
	proto.RegisterType((*LoginChallenge)(nil), "arc.LoginChallenge")
	proto.RegisterType((*LoginResponse)(nil), "arc.LoginResponse")
	proto.RegisterType((*Symbol)(nil), "arc.Symbol")
	proto.RegisterType((*RegisterDefs)(nil), "arc.RegisterDefs")
	proto.RegisterType((*AttrSpec)(nil), "arc.AttrSpec")
	proto.RegisterType((*ItemSelector)(nil), "arc.ItemSelector")
	proto.RegisterType((*HandleURI)(nil), "arc.HandleURI")
	proto.RegisterType((*PinRequest)(nil), "arc.PinRequest")
	proto.RegisterType((*Position)(nil), "arc.Position")
	proto.RegisterType((*AmpTag)(nil), "arc.AmpTag")
	proto.RegisterType((*SheetInfo)(nil), "arc.SheetInfo")
	proto.RegisterType((*SheetGroup)(nil), "arc.SheetGroup")
	proto.RegisterType((*CryptoKey)(nil), "arc.CryptoKey")
	proto.RegisterType((*CellHeader)(nil), "arc.CellHeader")
	proto.RegisterType((*AuthToken)(nil), "arc.AuthToken")
	proto.RegisterType((*TRS)(nil), "arc.TRS")
	proto.RegisterType((*FeedParams)(nil), "arc.FeedParams")
	proto.RegisterType((*DataSegment)(nil), "arc.DataSegment")
	proto.RegisterType((*Err)(nil), "arc.Err")
}

func init() { proto.RegisterFile("apis/arc/arc.proto", fileDescriptor_e4a0eb974cf54c93) }

var fileDescriptor_e4a0eb974cf54c93 = []byte{
	// 2605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x58, 0x4d, 0x6c, 0x1b, 0xc7,
	0xd9, 0xd6, 0x92, 0xfa, 0xe3, 0xe8, 0xc7, 0xe3, 0x89, 0xec, 0xac, 0x1d, 0x9b, 0x31, 0x98, 0xe4,
	0xa3, 0xa3, 0x24, 0xb6, 0x45, 0x25, 0x1f, 0xbe, 0xef, 0xf0, 0xe5, 0xab, 0x4c, 0xca, 0x16, 0x11,
	0x49, 0x64, 0x67, 0x49, 0x3b, 0x68, 0x81, 0x10, 0x23, 0xee, 0x4b, 0x72, 0xe1, 0xe5, 0xec, 0x7a,
	0x77, 0xa8, 0x52, 0x01, 0x0a, 0x04, 0x3d, 0xf4, 0x2f, 0x4d, 0x9b, 0x16, 0x68, 0x4f, 0x6d, 0x8f,
	0x6d, 0x1a, 0xf4, 0xd0, 0x4b, 0x81, 0xa2, 0xff, 0x68, 0x2f, 0x41, 0x4f, 0x39, 0xe6, 0xd8, 0xd8,
	0x97, 0x1e, 0x5a, 0x20, 0xe7, 0x1e, 0x8a, 0xe2, 0x9d, 0xfd, 0xe1, 0xae, 0xe4, 0x1e, 0x04, 0xcc,
	0xf3, 0x3c, 0x33, 0xb3, 0xef, 0xcc, 0xfb, 0x33, 0x2f, 0x45, 0x98, 0xf0, 0x9d, 0xf0, 0xa6, 0x08,
	0xfa, 0xf8, 0x77, 0xc3, 0x0f, 0x3c, 0xe5, 0xb1, 0xa2, 0x08, 0xfa, 0x15, 0x97, 0x14, 0x0f, 0xc2,
	0x21, 0xdb, 0x20, 0x0b, 0x1c, 0x1e, 0x36, 0x1b, 0xa6, 0x71, 0xcd, 0xb8, 0x3e, 0xcf, 0x23, 0xc0,
	0xfe, 0x8b, 0x2c, 0x5a, 0x4a, 0xa8, 0x49, 0x68, 0x16, 0xae, 0x19, 0xd7, 0xd7, 0x6b, 0xeb, 0x37,
	0x70, 0x35, 0x87, 0x87, 0x11, 0xcb, 0x63, 0x95, 0x55, 0xc9, 0x52, 0x1d, 0x5c, 0xb7, 0x33, 0x0d,
	0xcd, 0x85, 0x6b, 0xc5, 0xeb, 0x2b, 0xb5, 0x35, 0x3d, 0x31, 0xe2, 0xda, 0x47, 0x3c, 0x51, 0x2b,
	0x5f, 0x35, 0xc8, 0x72, 0xc2, 0xb2, 0xab, 0xa4, 0xd0, 0xf2, 0xf5, 0x07, 0xd7, 0x73, 0x0b, 0x5a,
	0x3e, 0x2f, 0xb4, 0x7c, 0x76, 0x29, 0x9a, 0xda, 0x6c, 0xf4, 0x6e, 0x99, 0xc5, 0x6b, 0xc6, 0xf5,
	0xc5, 0x68, 0x9b, 0x66, 0xe3, 0x56, 0x46, 0xda, 0x32, 0xe7, 0xb3, 0xd2, 0x16, 0x7b, 0x81, 0x2c,
	0xec, 0xba, 0x30, 0x0e, 0xcd, 0x65, 0x6d, 0xc8, 0x39, 0xbd, 0xef, 0x8e, 0x52, 0x01, 0xb2, 0xed,
	0x23, 0x1e, 0xa9, 0x95, 0x7d, 0x42, 0x66, 0x24, 0xbb, 0x48, 0x16, 0x11, 0xa5, 0xc7, 0x8f, 0x11,
	0xf2, 0xf7, 0x84, 0x7b, 0x7b, 0x32, 0xd0, 0xe7, 0x5f, 0xe5, 0x31, 0x62, 0xeb, 0xa4, 0x60, 0x35,
	0xb5, 0x51, 0x45, 0x5e, 0xb0, 0x9a, 0x95, 0x2f, 0x93, 0x85, 0x7d, 0x6f, 0xe8, 0x48, 0x66, 0x92,
	0xa5, 0x6e, 0x08, 0x41, 0x37, 0xde, 0xa9, 0xc4, 0x13, 0xc8, 0x2e, 0x93, 0xe5, 0x3d, 0x2f, 0x54,
	0x3b, 0xb6, 0x1d, 0xe8, 0xcd, 0x4a, 0x3c, 0xc5, 0xec, 0x1a, 0x59, 0x69, 0xc0, 0xb1, 0xd3, 0x87,
	0x7d, 0x71, 0x04, 0xae, 0xb9, 0xac, 0xe5, 0x2c, 0xc5, 0xae, 0x90, 0x52, 0x04, 0x71, 0xe7, 0x92,
	0xd6, 0x67, 0x44, 0xe5, 0x79, 0xb2, 0xae, 0x3f, 0x5f, 0x1f, 0x09, 0xd7, 0x05, 0x39, 0x04, 0xc6,
	0xc8, 0xfc, 0x9e, 0x08, 0x47, 0xda, 0x88, 0x55, 0xae, 0xc7, 0x95, 0x97, 0xc8, 0x9a, 0x9e, 0xc5,
	0x21, 0xf4, 0x3d, 0x19, 0x82, 0x36, 0x49, 0x84, 0x23, 0xc4, 0xf1, 0xc4, 0x14, 0x57, 0x5e, 0x26,
	0x8b, 0xd6, 0xc9, 0xf8, 0xc8, 0x73, 0xf1, 0xac, 0xf1, 0x69, 0xd6, 0x78, 0xa1, 0xd9, 0xc0, 0xad,
	0x0f, 0xc5, 0x18, 0xe2, 0x1b, 0xd1, 0xe3, 0xca, 0xbb, 0x06, 0x59, 0xe5, 0x30, 0x74, 0x42, 0x05,
	0x41, 0x03, 0x06, 0x21, 0x7b, 0x81, 0x2c, 0x45, 0xcb, 0x43, 0xd3, 0xd0, 0x7e, 0x58, 0xd1, 0x7e,
	0x88, 0x38, 0x9e, 0x68, 0xec, 0x39, 0xb2, 0x80, 0x37, 0x8d, 0xe1, 0x35, 0x8b, 0x1a, 0x64, 0x2c,
	0x1f, 0xfa, 0x3c, 0xd2, 0xd8, 0x4d, 0x52, 0xb2, 0xc0, 0x85, 0xbe, 0xf2, 0x82, 0xd0, 0x9c, 0xd7,
	0x13, 0xcf, 0xeb, 0x89, 0x4d, 0x05, 0xe3, 0x44, 0xe1, 0xb3, 0x39, 0x95, 0x5f, 0x19, 0x64, 0x39,
	0xd9, 0x04, 0x03, 0xbb, 0x01, 0x83, 0xf4, 0x04, 0x11, 0xc0, 0xa3, 0xa3, 0xeb, 0x3b, 0x27, 0x3e,
	0x68, 0x37, 0xae, 0xf1, 0x14, 0xb3, 0x32, 0x21, 0x16, 0x04, 0x0e, 0x84, 0xb8, 0x5e, 0x87, 0xd7,
	0x1a, 0xcf, 0x30, 0xec, 0x75, 0x72, 0x2e, 0x42, 0x4d, 0x69, 0xc3, 0x54, 0x6f, 0xb1, 0xa0, 0x63,
	0x78, 0x23, 0x3a, 0x63, 0x5e, 0xe3, 0xa7, 0x27, 0xe3, 0xb7, 0xd1, 0x3a, 0x7d, 0x89, 0x8b, 0xd1,
	0xb7, 0x13, 0x5c, 0x79, 0x93, 0xac, 0x66, 0x4f, 0xf5, 0x1f, 0xac, 0x37, 0xc9, 0x52, 0x53, 0xf6,
	0xdd, 0x89, 0x0d, 0xfa, 0x3e, 0xd6, 0x78, 0x02, 0x51, 0xd9, 0x9d, 0x46, 0xca, 0x42, 0xa4, 0xc4,
	0xb0, 0x72, 0x95, 0x94, 0xf6, 0x84, 0xb4, 0x5d, 0xe8, 0xf2, 0x26, 0xa3, 0xa4, 0xd8, 0xe5, 0xcd,
	0x38, 0x44, 0x71, 0x58, 0x79, 0xaf, 0x40, 0x48, 0x1b, 0x63, 0xe3, 0xe1, 0x04, 0x42, 0x85, 0x11,
	0xd9, 0x16, 0x01, 0x48, 0x95, 0x2d, 0x0a, 0x59, 0x0a, 0x53, 0xa3, 0xed, 0xc8, 0x2e, 0xdf, 0x8f,
	0xa3, 0x39, 0x46, 0x7a, 0xa5, 0x23, 0xa3, 0x6c, 0x9c, 0x46, 0x89, 0x8b, 0x2b, 0x67, 0x54, 0x7e,
	0x46, 0x94, 0xbf, 0xb9, 0x19, 0x5b, 0xec, 0x06, 0x61, 0xd1, 0xa7, 0xb4, 0x17, 0xe3, 0xbb, 0xd0,
	0x97, 0xbc, 0xc6, 0x9f, 0xa0, 0xb0, 0x97, 0xc9, 0xf9, 0xfa, 0xc8, 0x71, 0x6d, 0xdc, 0x20, 0x9d,
	0x1e, 0x5d, 0xed, 0x59, 0x01, 0x83, 0xee, 0x8e, 0x2b, 0x86, 0xa1, 0xb9, 0x94, 0xa9, 0x3c, 0x6d,
	0x47, 0x6a, 0x92, 0x47, 0x5a, 0xe5, 0x21, 0x59, 0x6e, 0x7b, 0xa1, 0xa3, 0x1c, 0x4f, 0xb2, 0x17,
	0xc9, 0x72, 0xdd, 0x0b, 0x6c, 0xed, 0xe9, 0x5c, 0xb5, 0x8a, 0x49, 0x9e, 0xca, 0x6c, 0x95, 0x18,
	0x5d, 0x7d, 0x66, 0x83, 0x1b, 0x5d, 0x44, 0xf7, 0xf4, 0xf9, 0x0c, 0x6e, 0xdc, 0x43, 0x74, 0x5f,
	0x1f, 0xc2, 0xe0, 0xc6, 0x7d, 0x74, 0x01, 0x6f, 0x75, 0xb5, 0x95, 0x05, 0x8e, 0xc3, 0xca, 0xe3,
	0x02, 0x59, 0xdc, 0x19, 0xfb, 0x1d, 0x31, 0x64, 0xcf, 0x93, 0x05, 0xac, 0xac, 0x51, 0x6c, 0x26,
	0x65, 0xf7, 0xf3, 0x13, 0x61, 0x6b, 0x96, 0x47, 0x22, 0x5e, 0x64, 0xdd, 0x93, 0x0a, 0xa4, 0x4a,
	0x83, 0xb0, 0xc4, 0xb3, 0x54, 0xe2, 0xe7, 0xa5, 0xd4, 0xcf, 0x18, 0x50, 0x5d, 0xed, 0x18, 0xaa,
	0xcb, 0x66, 0x04, 0x12, 0x76, 0xcb, 0x3c, 0x3f, 0x63, 0xb7, 0x12, 0xb6, 0x66, 0xb2, 0x19, 0x5b,
	0xd3, 0x86, 0x4f, 0x6f, 0x99, 0x1b, 0xb1, 0xe1, 0xd3, 0x5b, 0x11, 0xb3, 0x65, 0x5e, 0x48, 0x98,
	0xad, 0x88, 0xa9, 0x99, 0x17, 0x13, 0xa6, 0x86, 0x49, 0xd5, 0x76, 0xa6, 0xe0, 0xde, 0x77, 0x6c,
	0x35, 0x32, 0xaf, 0x5c, 0x33, 0xae, 0x2f, 0xf0, 0x0c, 0x13, 0x05, 0xc5, 0x14, 0xdc, 0x3d, 0x70,
	0x86, 0x23, 0x65, 0x5e, 0xd5, 0x13, 0xb2, 0x14, 0xee, 0x70, 0x00, 0x0a, 0x02, 0xab, 0x2f, 0x5c,
	0x30, 0xcb, 0x7a, 0xeb, 0x0c, 0xa3, 0x4b, 0xce, 0xe4, 0xa8, 0x83, 0x8e, 0x2d, 0x64, 0x4a, 0x4e,
	0x74, 0xa3, 0x3c, 0xd1, 0x2a, 0x6f, 0x91, 0x92, 0x35, 0x02, 0x50, 0x4d, 0x39, 0xf0, 0xf0, 0xab,
	0x3b, 0xbe, 0xaf, 0xf1, 0x2c, 0x1f, 0xb2, 0x14, 0xbb, 0x49, 0x56, 0x6e, 0x7b, 0x13, 0x69, 0x47,
	0x49, 0x6c, 0x16, 0x9f, 0x54, 0xa7, 0xb2, 0x33, 0x2a, 0x9f, 0x23, 0x44, 0x2f, 0xbe, 0x1b, 0x78,
	0x13, 0x9f, 0xd5, 0xc8, 0xaa, 0x46, 0x75, 0xa1, 0x84, 0xeb, 0x0d, 0xe3, 0x62, 0x18, 0xf9, 0x33,
	0x35, 0x83, 0xe7, 0xe6, 0x54, 0xbe, 0x48, 0x4a, 0xf5, 0xe0, 0xc4, 0x57, 0xde, 0x1b, 0x70, 0xc2,
	0x6a, 0x64, 0x25, 0x06, 0x8e, 0x8a, 0x13, 0x71, 0xbd, 0x46, 0xa3, 0xf0, 0x9b, 0xf1, 0x3c, 0x3b,
	0x09, 0x0b, 0xcc, 0x1b, 0x70, 0x72, 0xfb, 0x44, 0x41, 0xa8, 0xa3, 0x6f, 0x95, 0xa7, 0xb8, 0xf2,
	0x4f, 0x83, 0x10, 0xcc, 0x86, 0x3d, 0x10, 0x36, 0xe8, 0xfa, 0xd2, 0x71, 0x94, 0x0b, 0x71, 0x12,
	0x47, 0x00, 0x37, 0xb0, 0x26, 0x47, 0x4a, 0x0b, 0xc5, 0xe8, 0xad, 0x4a, 0x30, 0xae, 0xd8, 0x39,
	0xf2, 0x26, 0x4a, 0xef, 0x5c, 0xe2, 0x11, 0x60, 0xcf, 0x91, 0xc5, 0xbb, 0xee, 0x89, 0x3f, 0x0a,
	0xcd, 0xc5, 0xb3, 0x77, 0x1f, 0x4b, 0x58, 0x9c, 0xea, 0x01, 0x08, 0x05, 0xb6, 0x7e, 0xe2, 0x8a,
	0x3c, 0x81, 0xf8, 0xc1, 0x03, 0xcf, 0x76, 0x06, 0x0e, 0xd8, 0xfa, 0x75, 0x2b, 0xf2, 0x14, 0xeb,
	0x55, 0xe0, 0xba, 0x58, 0x69, 0x36, 0xa2, 0x27, 0x35, 0x86, 0xec, 0x26, 0x59, 0xdd, 0x9d, 0x2a,
	0x08, 0xa4, 0x70, 0xf7, 0x1d, 0xf9, 0x40, 0x87, 0xdb, 0xa9, 0x4f, 0xe7, 0x26, 0x54, 0xbe, 0x66,
	0x90, 0xd2, 0xce, 0x44, 0x8d, 0x3a, 0xde, 0x03, 0x90, 0xda, 0xf9, 0xfd, 0x3e, 0x84, 0xa1, 0x86,
	0xa9, 0xf3, 0x67, 0x14, 0xbe, 0xba, 0x7a, 0xa0, 0xd3, 0x2b, 0xba, 0xa1, 0x19, 0xc1, 0x2a, 0xf8,
	0xe6, 0x0d, 0x02, 0x08, 0xa3, 0xfd, 0xe2, 0x9b, 0xca, 0x71, 0x58, 0x25, 0x77, 0xa7, 0xbe, 0x13,
	0x9c, 0xe8, 0xeb, 0x2a, 0xf2, 0x18, 0x55, 0x7e, 0x59, 0x20, 0xc5, 0x0e, 0xb7, 0xf0, 0x71, 0x7d,
	0x73, 0xcb, 0x7c, 0x51, 0x17, 0x85, 0xc2, 0x9b, 0x5b, 0x1a, 0xd7, 0xcc, 0xcd, 0x18, 0xd7, 0x34,
	0xde, 0x36, 0x5f, 0x8a, 0xf1, 0x36, 0xfb, 0x6f, 0x52, 0xd2, 0xd1, 0x7e, 0xe0, 0xd9, 0x60, 0xd6,
	0x74, 0x30, 0x98, 0xfa, 0xbc, 0x1d, 0x6e, 0xdd, 0xb8, 0xe7, 0x84, 0x13, 0xe1, 0xa6, 0x3a, 0x9f,
	0x4d, 0x45, 0x3b, 0x34, 0xd8, 0x32, 0xb7, 0x75, 0xe2, 0xc4, 0x28, 0xe5, 0x6b, 0xe6, 0xab, 0x19,
	0xbe, 0x96, 0xf2, 0xdb, 0xe6, 0x6b, 0x19, 0x7e, 0x1b, 0x9d, 0xc1, 0x3d, 0x2c, 0x3e, 0x5b, 0xe6,
	0xff, 0x69, 0x21, 0x81, 0x33, 0xa5, 0x66, 0xbe, 0x9e, 0x55, 0x6a, 0x33, 0x65, 0xdb, 0xfc, 0xff,
	0xac, 0xb2, 0x5d, 0xb9, 0x45, 0xce, 0x9d, 0xb2, 0x99, 0xad, 0x69, 0x0f, 0x79, 0x9a, 0xa0, 0x73,
	0x6c, 0x9d, 0x90, 0x3b, 0xce, 0x14, 0xec, 0x08, 0x1b, 0x95, 0x11, 0x21, 0x77, 0x00, 0xec, 0xb6,
	0x08, 0xc4, 0x38, 0xc4, 0xba, 0xdf, 0xf5, 0x6d, 0xa1, 0xa0, 0x29, 0x15, 0x04, 0xc7, 0xc2, 0x3d,
	0x70, 0xa4, 0xf6, 0x53, 0x81, 0x9f, 0x15, 0x9e, 0x30, 0x5b, 0x4c, 0xb5, 0xd3, 0xce, 0xce, 0x16,
	0xd3, 0xca, 0xf7, 0x0d, 0xb2, 0xd2, 0x10, 0x4a, 0x58, 0x30, 0x1c, 0x83, 0x54, 0x78, 0x0a, 0xcc,
	0xa0, 0xd6, 0x20, 0xd4, 0x85, 0x76, 0x9e, 0x27, 0x10, 0xef, 0x0a, 0x87, 0xd6, 0xdb, 0xba, 0x98,
	0xcf, 0xf3, 0x18, 0x61, 0xc1, 0x6a, 0x4a, 0xd7, 0x91, 0x80, 0xdb, 0xe8, 0x1a, 0xbc, 0xca, 0x33,
	0x0c, 0x46, 0x97, 0xa5, 0x02, 0x10, 0x63, 0x2c, 0x3d, 0x71, 0x4f, 0x97, 0x12, 0x7a, 0x57, 0xd7,
	0x3b, 0x6a, 0x36, 0x4c, 0x12, 0x45, 0x4e, 0x84, 0x2a, 0x6f, 0x91, 0xe2, 0x6e, 0x80, 0x2d, 0xe3,
	0x7c, 0x1d, 0x63, 0x20, 0x2a, 0x08, 0xab, 0x3a, 0x06, 0x76, 0x83, 0x00, 0x39, 0xae, 0x15, 0x7c,
	0xe6, 0xf6, 0xe1, 0x18, 0xdc, 0xb8, 0x75, 0x8f, 0x6a, 0xd6, 0xbe, 0x37, 0xd4, 0x24, 0x8f, 0x34,
	0x2c, 0xd4, 0x07, 0xe1, 0x30, 0xce, 0x65, 0x1c, 0x6e, 0x0e, 0xc8, 0x42, 0xdd, 0x93, 0xa1, 0xc2,
	0xab, 0xd7, 0x83, 0x1e, 0x36, 0x74, 0x74, 0x8e, 0x5d, 0x24, 0x2c, 0xc2, 0x9d, 0x66, 0xe3, 0xb6,
	0x23, 0x45, 0x70, 0xb2, 0x0f, 0x92, 0x5e, 0xcb, 0xf1, 0x96, 0x0a, 0x1c, 0x39, 0x44, 0xfe, 0x55,
	0x76, 0x95, 0x98, 0xe9, 0x7a, 0x31, 0x71, 0x95, 0x05, 0x01, 0xf6, 0xab, 0x6d, 0x2f, 0x50, 0xf4,
	0xa3, 0xeb, 0x9b, 0x2e, 0x59, 0xee, 0x4c, 0xe3, 0x2a, 0xb4, 0x4e, 0x48, 0x32, 0xee, 0xdd, 0xa2,
	0x73, 0xec, 0x3c, 0x59, 0x4b, 0xb1, 0xe5, 0xbc, 0x0d, 0x74, 0x99, 0x31, 0xb2, 0x9e, 0x52, 0x2d,
	0xbf, 0x35, 0x08, 0xe9, 0x12, 0xbb, 0x40, 0xce, 0x67, 0x38, 0x0e, 0xfd, 0xe3, 0xce, 0x94, 0x6e,
	0x9c, 0x9a, 0xba, 0xdb, 0xb2, 0xa8, 0xb9, 0xf9, 0x95, 0x82, 0x7e, 0x2b, 0x43, 0x15, 0x37, 0xb5,
	0x4f, 0x91, 0x73, 0x19, 0xd8, 0x93, 0x8e, 0x4b, 0xe7, 0x4e, 0x93, 0xbb, 0x41, 0x40, 0x09, 0xbb,
	0x12, 0x1f, 0x23, 0x26, 0xb3, 0x5d, 0x2e, 0x5d, 0x61, 0x97, 0xc8, 0x85, 0xac, 0x9a, 0x76, 0x58,
	0x74, 0x95, 0x5d, 0x26, 0x17, 0xb3, 0xd2, 0xac, 0xb9, 0xa2, 0x6b, 0x68, 0x79, 0x56, 0xd3, 0x6d,
	0x39, 0xdd, 0x60, 0x65, 0x72, 0xf9, 0x0c, 0x9d, 0xf6, 0xf4, 0xf4, 0x02, 0xbb, 0x4a, 0x2e, 0x9d,
	0xd1, 0x93, 0x6e, 0x9e, 0x5e, 0x64, 0xe5, 0xbc, 0xdc, 0x0c, 0xc3, 0x09, 0x04, 0x4d, 0xe9, 0xa8,
	0x70, 0x47, 0xd1, 0x77, 0x0a, 0x9b, 0x23, 0x52, 0x4a, 0x7f, 0xba, 0x31, 0x93, 0x6c, 0xa4, 0xa0,
	0x77, 0xe8, 0x29, 0x4b, 0x89, 0x40, 0x81, 0x4d, 0xe7, 0xd0, 0xb8, 0x99, 0x62, 0x9d, 0xc8, 0xbe,
	0x23, 0x87, 0xd4, 0x60, 0x1b, 0x84, 0xe6, 0x69, 0xb0, 0x69, 0x21, 0xcf, 0xd6, 0x5d, 0x2f, 0x04,
	0x9b, 0x16, 0x37, 0xad, 0xe4, 0x57, 0x5e, 0xcb, 0xd7, 0x67, 0x8d, 0xc7, 0xbd, 0x03, 0x50, 0x02,
	0x9f, 0x4d, 0x3a, 0xc7, 0x9e, 0x26, 0x4f, 0xa5, 0x74, 0xd7, 0x0f, 0x21, 0x50, 0x08, 0xa9, 0x91,
	0x13, 0x38, 0x8c, 0xbd, 0x63, 0xd0, 0x42, 0x71, 0x73, 0xef, 0x4c, 0xdf, 0xcd, 0x9e, 0x21, 0x4f,
	0x9f, 0xa2, 0x7a, 0xfb, 0x8e, 0x82, 0x40, 0xa0, 0x3b, 0x4d, 0xb2, 0x71, 0x5a, 0xc4, 0x1e, 0x9b,
	0x1a, 0x9b, 0x0f, 0xc8, 0x72, 0xd2, 0xef, 0x61, 0xac, 0x25, 0xe3, 0xde, 0xa1, 0x27, 0xb1, 0xe8,
	0x5c, 0x25, 0x97, 0x52, 0xaa, 0x1b, 0xc2, 0xa1, 0x50, 0xce, 0x31, 0xc4, 0x3f, 0x59, 0xa8, 0x81,
	0xfb, 0xa6, 0xb2, 0x3e, 0x71, 0x4b, 0xe2, 0x75, 0xd0, 0x79, 0x0c, 0xa0, 0xcc, 0x5e, 0x9a, 0x5c,
	0xde, 0xfc, 0xd0, 0x98, 0xb5, 0x8f, 0xb8, 0x36, 0x19, 0xf7, 0xba, 0x32, 0xf4, 0xa1, 0xaf, 0x1f,
	0x39, 0x3a, 0x87, 0x17, 0x99, 0x2a, 0xad, 0xc0, 0x86, 0x00, 0x6c, 0x6a, 0x44, 0xd1, 0x17, 0xb3,
	0x6d, 0x57, 0x48, 0xe8, 0xd5, 0xd1, 0x4d, 0xa1, 0x23, 0x24, 0x5d, 0xc0, 0xe3, 0x9f, 0x52, 0xf7,
	0x60, 0xba, 0x7b, 0x0c, 0x92, 0xd3, 0xc5, 0x28, 0x34, 0x63, 0xf1, 0x2e, 0x78, 0x8e, 0xdd, 0xb3,
	0xfc, 0x11, 0x04, 0x40, 0x49, 0xce, 0x8a, 0x48, 0xba, 0x7f, 0xd7, 0xfa, 0x9f, 0x57, 0xe9, 0xca,
	0xe6, 0x98, 0x94, 0xd2, 0x36, 0x13, 0x3d, 0x91, 0x82, 0xde, 0xbe, 0xc0, 0xae, 0xb2, 0x35, 0x18,
	0x44, 0xa5, 0xe0, 0x8c, 0x20, 0x23, 0xd7, 0xcd, 0xf8, 0x9d, 0x3e, 0x5e, 0x1b, 0x2e, 0xa0, 0xf9,
	0x05, 0xb1, 0x20, 0xe9, 0x79, 0xfc, 0x5c, 0x37, 0x70, 0xad, 0xfe, 0x08, 0xc6, 0x80, 0x9e, 0x48,
	0x41, 0xef, 0x50, 0x67, 0x24, 0x23, 0xeb, 0x33, 0x0a, 0x8b, 0x26, 0x35, 0xf2, 0xd3, 0x76, 0xc6,
	0x3e, 0x2d, 0xe4, 0xa7, 0xdd, 0x71, 0x5c, 0xa0, 0xc5, 0x3c, 0xb7, 0xa7, 0x94, 0x4f, 0xe7, 0x37,
	0x7f, 0x60, 0xe4, 0xba, 0x29, 0xdc, 0x2a, 0x85, 0xf1, 0x17, 0xf1, 0xc2, 0x53, 0xca, 0x82, 0x7e,
	0x00, 0xea, 0xb6, 0x37, 0xed, 0x1d, 0x8a, 0xba, 0x4b, 0x6d, 0x9d, 0xd3, 0xa9, 0xba, 0x13, 0x9e,
	0x8c, 0x0f, 0xc2, 0x61, 0xa4, 0x41, 0x5e, 0xb3, 0x9c, 0xa1, 0x74, 0x64, 0xac, 0x0d, 0x74, 0x66,
	0x9e, 0xd1, 0x76, 0x1b, 0xb5, 0xd7, 0x5e, 0xdb, 0xfa, 0x5f, 0xfa, 0x17, 0x63, 0xf3, 0x5f, 0x8b,
	0x64, 0x29, 0xae, 0xde, 0x68, 0x54, 0x3c, 0xec, 0x1d, 0x7a, 0x58, 0x83, 0x30, 0x57, 0x58, 0x42,
	0x75, 0xa5, 0x14, 0x63, 0xb0, 0x91, 0xff, 0x7a, 0x95, 0x99, 0xe4, 0xa9, 0x44, 0xd0, 0x6f, 0x97,
	0x14, 0x2e, 0x2a, 0xdf, 0xa8, 0xb2, 0xcb, 0xe4, 0xc2, 0x6c, 0x49, 0x38, 0xf1, 0x7d, 0x0f, 0xb3,
	0xbb, 0xe5, 0xd3, 0x6f, 0x9e, 0xd2, 0x9c, 0xb1, 0xef, 0x02, 0xbe, 0x70, 0x60, 0xd3, 0x77, 0xab,
	0x6c, 0x83, 0x9c, 0x4b, 0xb4, 0x8e, 0x33, 0x06, 0x6f, 0xa2, 0xe8, 0xb7, 0xaa, 0xec, 0x12, 0xd9,
	0x48, 0x58, 0x6b, 0x34, 0x51, 0xca, 0x91, 0xc3, 0x86, 0xf7, 0x25, 0x49, 0xdf, 0xcb, 0x49, 0x87,
	0x9e, 0xaa, 0x7b, 0x52, 0x42, 0x1f, 0xf7, 0xfa, 0x76, 0x35, 0x6b, 0x36, 0x76, 0x5d, 0x77, 0x84,
	0xe3, 0x82, 0x4d, 0xbf, 0x93, 0x33, 0x5b, 0xd7, 0xb0, 0x58, 0x79, 0xbf, 0xca, 0x9e, 0x21, 0x17,
	0xd3, 0x0f, 0x41, 0x18, 0x3a, 0x9e, 0xd4, 0x0d, 0x13, 0xd8, 0xf4, 0xbb, 0xb9, 0x65, 0x1c, 0x1e,
	0x1e, 0x7a, 0xea, 0x0e, 0xf6, 0xdd, 0xf4, 0x7b, 0xb9, 0x2f, 0x35, 0xe5, 0xb1, 0x70, 0x1d, 0x9b,
	0xc3, 0x43, 0xfa, 0xc3, 0x27, 0x09, 0x58, 0x9c, 0x7f, 0x54, 0x65, 0x17, 0x08, 0x4d, 0x84, 0xdb,
	0xc2, 0xbe, 0x27, 0xdc, 0x09, 0xd0, 0x1f, 0x57, 0xd9, 0x15, 0xf2, 0x74, 0xe6, 0x34, 0x23, 0x47,
	0x0e, 0x3b, 0x5e, 0xdd, 0x1b, 0x8f, 0x1d, 0x45, 0x7f, 0x92, 0x3b, 0x6b, 0x44, 0xc6, 0x86, 0xff,
	0x34, 0x67, 0xb8, 0xce, 0x44, 0x95, 0x9a, 0xf7, 0x41, 0xee, 0xc2, 0x23, 0x11, 0xd7, 0x4d, 0x02,
	0xa0, 0x3f, 0xcb, 0x1d, 0x6a, 0xc7, 0xf7, 0xd3, 0x55, 0x1f, 0xe6, 0x94, 0x06, 0x0c, 0x52, 0xe5,
	0xe7, 0x39, 0xe5, 0x40, 0xb8, 0x03, 0x2f, 0x18, 0x83, 0xdd, 0x99, 0xd2, 0x5f, 0xe4, 0x2c, 0xc4,
	0xec, 0x4e, 0x17, 0xfd, 0xba, 0x8a, 0x31, 0x78, 0x4a, 0x4a, 0xde, 0x32, 0xb0, 0xe9, 0x6f, 0xaa,
	0xec, 0x22, 0x39, 0x9f, 0xb9, 0x11, 0x9d, 0x38, 0x82, 0xfe, 0x36, 0x6f, 0x86, 0x50, 0x22, 0x31,
	0xfd, 0x77, 0xb9, 0x15, 0xbb, 0x53, 0x0c, 0x30, 0x8c, 0xbd, 0xdf, 0xe7, 0xf8, 0x76, 0xea, 0xdc,
	0x3f, 0x54, 0xb1, 0x23, 0xc8, 0xf0, 0xfa, 0x77, 0xea, 0x54, 0xc5, 0x6f, 0xc6, 0x1f, 0xf3, 0xb7,
	0x0b, 0xae, 0x9b, 0xda, 0xfe, 0xa7, 0x9c, 0x0d, 0xed, 0xc0, 0x3b, 0x76, 0x6c, 0x08, 0xf0, 0x5b,
	0x7f, 0xae, 0xb2, 0x67, 0xc9, 0xe5, 0x44, 0xb9, 0xe7, 0x78, 0xae, 0x50, 0x10, 0xee, 0xf8, 0x3e,
	0x48, 0xbb, 0x25, 0xdd, 0x13, 0xfa, 0xf7, 0x2a, 0x7b, 0x9e, 0x3c, 0x3b, 0x8b, 0x80, 0x70, 0x32,
	0x18, 0x38, 0x7d, 0x07, 0xa4, 0x6a, 0x43, 0x30, 0x76, 0x74, 0x80, 0x85, 0xf4, 0x1f, 0xd5, 0xcd,
	0x06, 0x59, 0x4e, 0x5a, 0x23, 0xac, 0x1c, 0xc9, 0x18, 0x7b, 0x00, 0x2f, 0x88, 0x3a, 0x92, 0x94,
	0xbb, 0x2f, 0x02, 0x49, 0x0b, 0x39, 0x0a, 0x7f, 0xc5, 0xd1, 0xf9, 0xdb, 0xfd, 0x8f, 0x3f, 0x2d,
	0xcf, 0x7d, 0xf2, 0x69, 0x79, 0xee, 0xb3, 0x4f, 0xcb, 0xc6, 0x3b, 0x8f, 0xca, 0xc6, 0x07, 0x8f,
	0xca, 0xc6, 0x47, 0x8f, 0xca, 0xc6, 0xc7, 0x8f, 0xca, 0xc6, 0x5f, 0x1f, 0x95, 0x8d, 0xbf, 0x3d,
	0x2a, 0xcf, 0x7d, 0xf6, 0xa8, 0x6c, 0xbc, 0xff, 0xb8, 0x3c, 0xf7, 0xf1, 0xe3, 0xf2, 0xdc, 0x27,
	0x8f, 0xcb, 0x73, 0x5f, 0xa8, 0x0e, 0x1d, 0x35, 0x9a, 0x1c, 0xdd, 0xe8, 0x7b, 0xe3, 0x9b, 0x22,
	0xe8, 0x87, 0xbe, 0xe8, 0xc3, 0xcd, 0xa1, 0xf7, 0x8a, 0x08, 0xfa, 0xaf, 0x84, 0xf6, 0x83, 0x9b,
	0xc9, 0x7f, 0x6e, 0x3f, 0x2c, 0x14, 0x77, 0x0e, 0xda, 0x47, 0x8b, 0xfa, 0x9f, 0xb7, 0xdb, 0xff,
	0x0e, 0x00, 0x00, 0xff, 0xff, 0x96, 0x5b, 0x48, 0xe8, 0xd2, 0x15, 0x00, 0x00,
}

func (x Const) String() string {
	s, ok := Const_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TxHeader) String() string {
	s, ok := TxHeader_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ConstSymbol) String() string {
	s, ok := ConstSymbol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ReqStatus) String() string {
	s, ok := ReqStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CellTxOp) String() string {
	s, ok := CellTxOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SeriesIndexType) String() string {
	s, ok := SeriesIndexType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PinFlags) String() string {
	s, ok := PinFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CordType) String() string {
	s, ok := CordType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x QuadState) String() string {
	s, ok := QuadState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UrlScheme) String() string {
	s, ok := UrlScheme_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrCode) String() string {
	s, ok := ErrCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LogLevel) String() string {
	s, ok := LogLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TRS_VisualScaleMode) String() string {
	s, ok := TRS_VisualScaleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReqID != that1.ReqID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.CellTxs) != len(that1.CellTxs) {
		return false
	}
	for i := range this.CellTxs {
		if !this.CellTxs[i].Equal(that1.CellTxs[i]) {
			return false
		}
	}
	return true
}
func (this *CellTxPb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellTxPb)
	if !ok {
		that2, ok := that.(CellTxPb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.CellID_0 != that1.CellID_0 {
		return false
	}
	if this.CellID_1 != that1.CellID_1 {
		return false
	}
	if len(this.Elems) != len(that1.Elems) {
		return false
	}
	for i := range this.Elems {
		if !this.Elems[i].Equal(that1.Elems[i]) {
			return false
		}
	}
	return true
}
func (this *AttrElemPb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrElemPb)
	if !ok {
		that2, ok := that.(AttrElemPb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AttrID != that1.AttrID {
		return false
	}
	if !bytes.Equal(this.ValBuf, that1.ValBuf) {
		return false
	}
	if this.SI != that1.SI {
		return false
	}
	return true
}
func (this *Login) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Login)
	if !ok {
		that2, ok := that.(Login)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserUID != that1.UserUID {
		return false
	}
	if this.HostAddr != that1.HostAddr {
		return false
	}
	if this.DeviceLabel != that1.DeviceLabel {
		return false
	}
	if this.DeviceUID != that1.DeviceUID {
		return false
	}
	return true
}
func (this *LoginChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginChallenge)
	if !ok {
		that2, ok := that.(LoginChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *LoginResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginResponse)
	if !ok {
		that2, ok := that.(LoginResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashResp, that1.HashResp) {
		return false
	}
	return true
}
func (this *Symbol) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Symbol)
	if !ok {
		that2, ok := that.(Symbol)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !bytes.Equal(this.Name, that1.Name) {
		return false
	}
	return true
}
func (this *RegisterDefs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegisterDefs)
	if !ok {
		that2, ok := that.(RegisterDefs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Symbols) != len(that1.Symbols) {
		return false
	}
	for i := range this.Symbols {
		if !this.Symbols[i].Equal(that1.Symbols[i]) {
			return false
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !this.Attrs[i].Equal(that1.Attrs[i]) {
			return false
		}
	}
	if len(this.Selectors) != len(that1.Selectors) {
		return false
	}
	for i := range this.Selectors {
		if !this.Selectors[i].Equal(that1.Selectors[i]) {
			return false
		}
	}
	return true
}
func (this *AttrSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrSpec)
	if !ok {
		that2, ok := that.(AttrSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefID != that1.DefID {
		return false
	}
	if this.ElemType != that1.ElemType {
		return false
	}
	if this.SeriesSpec != that1.SeriesSpec {
		return false
	}
	if this.SeriesIndexType != that1.SeriesIndexType {
		return false
	}
	if this.AttrName != that1.AttrName {
		return false
	}
	return true
}
func (this *ItemSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemSelector)
	if !ok {
		that2, ok := that.(ItemSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefID != that1.DefID {
		return false
	}
	if len(this.Include) != len(that1.Include) {
		return false
	}
	for i := range this.Include {
		if this.Include[i] != that1.Include[i] {
			return false
		}
	}
	if len(this.Exclude) != len(that1.Exclude) {
		return false
	}
	for i := range this.Exclude {
		if this.Exclude[i] != that1.Exclude[i] {
			return false
		}
	}
	return true
}
func (this *HandleURI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HandleURI)
	if !ok {
		that2, ok := that.(HandleURI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	return true
}
func (this *PinRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinRequest)
	if !ok {
		that2, ok := that.(PinRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParentReqID != that1.ParentReqID {
		return false
	}
	if this.PinURL != that1.PinURL {
		return false
	}
	if this.PinCellIDx0 != that1.PinCellIDx0 {
		return false
	}
	if this.PinCellIDx1 != that1.PinCellIDx1 {
		return false
	}
	if this.ParentAttrSelector != that1.ParentAttrSelector {
		return false
	}
	if this.ChildCellSelector != that1.ChildCellSelector {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	return true
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CordType != that1.CordType {
		return false
	}
	if this.U != that1.U {
		return false
	}
	if this.V != that1.V {
		return false
	}
	if this.W != that1.W {
		return false
	}
	if this.ROU != that1.ROU {
		return false
	}
	return true
}
func (this *AmpTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AmpTag)
	if !ok {
		that2, ok := that.(AmpTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	if this.UIDx0 != that1.UIDx0 {
		return false
	}
	if this.UIDx1 != that1.UIDx1 {
		return false
	}
	if this.UIDx2 != that1.UIDx2 {
		return false
	}
	if this.Rx0 != that1.Rx0 {
		return false
	}
	if this.Rx1 != that1.Rx1 {
		return false
	}
	if this.Rx2 != that1.Rx2 {
		return false
	}
	if this.PixelWidth != that1.PixelWidth {
		return false
	}
	if this.PixelHeight != that1.PixelHeight {
		return false
	}
	if this.MeterScale != that1.MeterScale {
		return false
	}
	if len(this.SubTags) != len(that1.SubTags) {
		return false
	}
	for i := range this.SubTags {
		if !this.SubTags[i].Equal(that1.SubTags[i]) {
			return false
		}
	}
	return true
}
func (this *SheetInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SheetInfo)
	if !ok {
		that2, ok := that.(SheetInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppSheetURI != that1.AppSheetURI {
		return false
	}
	if len(this.BoundSeries) != len(that1.BoundSeries) {
		return false
	}
	for i := range this.BoundSeries {
		if !this.BoundSeries[i].Equal(that1.BoundSeries[i]) {
			return false
		}
	}
	return true
}
func (this *SheetGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SheetGroup)
	if !ok {
		that2, ok := that.(SheetGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SheetCatalog) != len(that1.SheetCatalog) {
		return false
	}
	for i := range this.SheetCatalog {
		if !this.SheetCatalog[i].Equal(that1.SheetCatalog[i]) {
			return false
		}
	}
	return true
}
func (this *CryptoKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptoKey)
	if !ok {
		that2, ok := that.(CryptoKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CryptoKitID != that1.CryptoKitID {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	return true
}
func (this *CellHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellHeader)
	if !ok {
		that2, ok := that.(CellHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Subtitle != that1.Subtitle {
		return false
	}
	if this.About != that1.About {
		return false
	}
	if len(this.Glyphs) != len(that1.Glyphs) {
		return false
	}
	for i := range this.Glyphs {
		if !this.Glyphs[i].Equal(that1.Glyphs[i]) {
			return false
		}
	}
	if this.Created != that1.Created {
		return false
	}
	if this.Modified != that1.Modified {
		return false
	}
	if this.CellURL != that1.CellURL {
		return false
	}
	if !this.ExternalLink.Equal(that1.ExternalLink) {
		return false
	}
	return true
}
func (this *AuthToken) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthToken)
	if !ok {
		that2, ok := that.(AuthToken)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessToken != that1.AccessToken {
		return false
	}
	if this.TokenType != that1.TokenType {
		return false
	}
	if this.RefreshToken != that1.RefreshToken {
		return false
	}
	if this.Expiry != that1.Expiry {
		return false
	}
	return true
}
func (this *TRS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TRS)
	if !ok {
		that2, ok := that.(TRS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.X3 != that1.X3 {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.Scale3 != that1.Scale3 {
		return false
	}
	if this.Rotate1 != that1.Rotate1 {
		return false
	}
	if this.Rotate2 != that1.Rotate2 {
		return false
	}
	if this.Rotate3 != that1.Rotate3 {
		return false
	}
	return true
}
func (this *FeedParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeedParams)
	if !ok {
		that2, ok := that.(FeedParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpdateIntervalMin != that1.UpdateIntervalMin {
		return false
	}
	if this.UpdateIntervalMax != that1.UpdateIntervalMax {
		return false
	}
	return true
}
func (this *DataSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSegment)
	if !ok {
		that2, ok := that.(DataSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByteOfs != that1.ByteOfs {
		return false
	}
	if this.ByteSz != that1.ByteSz {
		return false
	}
	if !bytes.Equal(this.InlineData, that1.InlineData) {
		return false
	}
	if this.StreamURI != that1.StreamURI {
		return false
	}
	if this.BlobID != that1.BlobID {
		return false
	}
	return true
}
func (this *Err) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Err)
	if !ok {
		that2, ok := that.(Err)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.Msg{")
	s = append(s, "ReqID: "+fmt.Sprintf("%#v", this.ReqID)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.CellTxs != nil {
		s = append(s, "CellTxs: "+fmt.Sprintf("%#v", this.CellTxs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CellTxPb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.CellTxPb{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "CellID_0: "+fmt.Sprintf("%#v", this.CellID_0)+",\n")
	s = append(s, "CellID_1: "+fmt.Sprintf("%#v", this.CellID_1)+",\n")
	if this.Elems != nil {
		s = append(s, "Elems: "+fmt.Sprintf("%#v", this.Elems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrElemPb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.AttrElemPb{")
	s = append(s, "AttrID: "+fmt.Sprintf("%#v", this.AttrID)+",\n")
	s = append(s, "ValBuf: "+fmt.Sprintf("%#v", this.ValBuf)+",\n")
	s = append(s, "SI: "+fmt.Sprintf("%#v", this.SI)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Login) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.Login{")
	s = append(s, "UserUID: "+fmt.Sprintf("%#v", this.UserUID)+",\n")
	s = append(s, "HostAddr: "+fmt.Sprintf("%#v", this.HostAddr)+",\n")
	s = append(s, "DeviceLabel: "+fmt.Sprintf("%#v", this.DeviceLabel)+",\n")
	s = append(s, "DeviceUID: "+fmt.Sprintf("%#v", this.DeviceUID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.LoginChallenge{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.LoginResponse{")
	s = append(s, "HashResp: "+fmt.Sprintf("%#v", this.HashResp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Symbol) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Symbol{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegisterDefs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.RegisterDefs{")
	if this.Symbols != nil {
		s = append(s, "Symbols: "+fmt.Sprintf("%#v", this.Symbols)+",\n")
	}
	if this.Attrs != nil {
		s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	}
	if this.Selectors != nil {
		s = append(s, "Selectors: "+fmt.Sprintf("%#v", this.Selectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.AttrSpec{")
	s = append(s, "DefID: "+fmt.Sprintf("%#v", this.DefID)+",\n")
	s = append(s, "ElemType: "+fmt.Sprintf("%#v", this.ElemType)+",\n")
	s = append(s, "SeriesSpec: "+fmt.Sprintf("%#v", this.SeriesSpec)+",\n")
	s = append(s, "SeriesIndexType: "+fmt.Sprintf("%#v", this.SeriesIndexType)+",\n")
	s = append(s, "AttrName: "+fmt.Sprintf("%#v", this.AttrName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.ItemSelector{")
	s = append(s, "DefID: "+fmt.Sprintf("%#v", this.DefID)+",\n")
	s = append(s, "Include: "+fmt.Sprintf("%#v", this.Include)+",\n")
	s = append(s, "Exclude: "+fmt.Sprintf("%#v", this.Exclude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HandleURI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.HandleURI{")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&arc.PinRequest{")
	s = append(s, "ParentReqID: "+fmt.Sprintf("%#v", this.ParentReqID)+",\n")
	s = append(s, "PinURL: "+fmt.Sprintf("%#v", this.PinURL)+",\n")
	s = append(s, "PinCellIDx0: "+fmt.Sprintf("%#v", this.PinCellIDx0)+",\n")
	s = append(s, "PinCellIDx1: "+fmt.Sprintf("%#v", this.PinCellIDx1)+",\n")
	s = append(s, "ParentAttrSelector: "+fmt.Sprintf("%#v", this.ParentAttrSelector)+",\n")
	s = append(s, "ChildCellSelector: "+fmt.Sprintf("%#v", this.ChildCellSelector)+",\n")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.Position{")
	s = append(s, "CordType: "+fmt.Sprintf("%#v", this.CordType)+",\n")
	s = append(s, "U: "+fmt.Sprintf("%#v", this.U)+",\n")
	s = append(s, "V: "+fmt.Sprintf("%#v", this.V)+",\n")
	s = append(s, "W: "+fmt.Sprintf("%#v", this.W)+",\n")
	s = append(s, "ROU: "+fmt.Sprintf("%#v", this.ROU)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AmpTag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&arc.AmpTag{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "URI: "+fmt.Sprintf("%#v", this.URI)+",\n")
	s = append(s, "UIDx0: "+fmt.Sprintf("%#v", this.UIDx0)+",\n")
	s = append(s, "UIDx1: "+fmt.Sprintf("%#v", this.UIDx1)+",\n")
	s = append(s, "UIDx2: "+fmt.Sprintf("%#v", this.UIDx2)+",\n")
	s = append(s, "Rx0: "+fmt.Sprintf("%#v", this.Rx0)+",\n")
	s = append(s, "Rx1: "+fmt.Sprintf("%#v", this.Rx1)+",\n")
	s = append(s, "Rx2: "+fmt.Sprintf("%#v", this.Rx2)+",\n")
	s = append(s, "PixelWidth: "+fmt.Sprintf("%#v", this.PixelWidth)+",\n")
	s = append(s, "PixelHeight: "+fmt.Sprintf("%#v", this.PixelHeight)+",\n")
	s = append(s, "MeterScale: "+fmt.Sprintf("%#v", this.MeterScale)+",\n")
	if this.SubTags != nil {
		s = append(s, "SubTags: "+fmt.Sprintf("%#v", this.SubTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SheetInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.SheetInfo{")
	s = append(s, "AppSheetURI: "+fmt.Sprintf("%#v", this.AppSheetURI)+",\n")
	if this.BoundSeries != nil {
		s = append(s, "BoundSeries: "+fmt.Sprintf("%#v", this.BoundSeries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SheetGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.SheetGroup{")
	if this.SheetCatalog != nil {
		s = append(s, "SheetCatalog: "+fmt.Sprintf("%#v", this.SheetCatalog)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CryptoKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.CryptoKey{")
	s = append(s, "CryptoKitID: "+fmt.Sprintf("%#v", this.CryptoKitID)+",\n")
	s = append(s, "KeyBytes: "+fmt.Sprintf("%#v", this.KeyBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CellHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&arc.CellHeader{")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Subtitle: "+fmt.Sprintf("%#v", this.Subtitle)+",\n")
	s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	if this.Glyphs != nil {
		s = append(s, "Glyphs: "+fmt.Sprintf("%#v", this.Glyphs)+",\n")
	}
	s = append(s, "Created: "+fmt.Sprintf("%#v", this.Created)+",\n")
	s = append(s, "Modified: "+fmt.Sprintf("%#v", this.Modified)+",\n")
	s = append(s, "CellURL: "+fmt.Sprintf("%#v", this.CellURL)+",\n")
	if this.ExternalLink != nil {
		s = append(s, "ExternalLink: "+fmt.Sprintf("%#v", this.ExternalLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthToken) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&arc.AuthToken{")
	s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	s = append(s, "RefreshToken: "+fmt.Sprintf("%#v", this.RefreshToken)+",\n")
	s = append(s, "Expiry: "+fmt.Sprintf("%#v", this.Expiry)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TRS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&arc.TRS{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "X3: "+fmt.Sprintf("%#v", this.X3)+",\n")
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "Scale3: "+fmt.Sprintf("%#v", this.Scale3)+",\n")
	s = append(s, "Rotate1: "+fmt.Sprintf("%#v", this.Rotate1)+",\n")
	s = append(s, "Rotate2: "+fmt.Sprintf("%#v", this.Rotate2)+",\n")
	s = append(s, "Rotate3: "+fmt.Sprintf("%#v", this.Rotate3)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeedParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.FeedParams{")
	s = append(s, "UpdateIntervalMin: "+fmt.Sprintf("%#v", this.UpdateIntervalMin)+",\n")
	s = append(s, "UpdateIntervalMax: "+fmt.Sprintf("%#v", this.UpdateIntervalMax)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.DataSegment{")
	s = append(s, "ByteOfs: "+fmt.Sprintf("%#v", this.ByteOfs)+",\n")
	s = append(s, "ByteSz: "+fmt.Sprintf("%#v", this.ByteSz)+",\n")
	s = append(s, "InlineData: "+fmt.Sprintf("%#v", this.InlineData)+",\n")
	s = append(s, "StreamURI: "+fmt.Sprintf("%#v", this.StreamURI)+",\n")
	s = append(s, "BlobID: "+fmt.Sprintf("%#v", this.BlobID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Err) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.Err{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringArc(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CellTxs) > 0 {
		for iNdEx := len(m.CellTxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CellTxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Status != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.ReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellTxPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellTxPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellTxPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CellID_1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CellID_1))
		i--
		dAtA[i] = 0x21
	}
	if m.CellID_0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CellID_0))
		i--
		dAtA[i] = 0x19
	}
	if m.Op != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttrElemPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrElemPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrElemPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SI != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ValBuf) > 0 {
		i -= len(m.ValBuf)
		copy(dAtA[i:], m.ValBuf)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ValBuf)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttrID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceUID) > 0 {
		i -= len(m.DeviceUID)
		copy(dAtA[i:], m.DeviceUID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.DeviceUID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DeviceLabel) > 0 {
		i -= len(m.DeviceLabel)
		copy(dAtA[i:], m.DeviceLabel)
		i = encodeVarintArc(dAtA, i, uint64(len(m.DeviceLabel)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.HostAddr) > 0 {
		i -= len(m.HostAddr)
		copy(dAtA[i:], m.HostAddr)
		i = encodeVarintArc(dAtA, i, uint64(len(m.HostAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserUID) > 0 {
		i -= len(m.UserUID)
		copy(dAtA[i:], m.UserUID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.UserUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashResp) > 0 {
		i -= len(m.HashResp)
		copy(dAtA[i:], m.HashResp)
		i = encodeVarintArc(dAtA, i, uint64(len(m.HashResp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Symbol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterDefs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterDefs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterDefs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for iNdEx := len(m.Selectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Symbols) > 0 {
		for iNdEx := len(m.Symbols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Symbols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttrSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttrName != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrName))
		i--
		dAtA[i] = 0x30
	}
	if m.SeriesIndexType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SeriesIndexType))
		i--
		dAtA[i] = 0x28
	}
	if m.SeriesSpec != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SeriesSpec))
		i--
		dAtA[i] = 0x20
	}
	if m.ElemType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ElemType))
		i--
		dAtA[i] = 0x18
	}
	if m.DefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.DefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ItemSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exclude) > 0 {
		dAtA2 := make([]byte, len(m.Exclude)*10)
		var j1 int
		for _, num := range m.Exclude {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintArc(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Include) > 0 {
		dAtA4 := make([]byte, len(m.Include)*10)
		var j3 int
		for _, num := range m.Include {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintArc(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.DefID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.DefID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HandleURI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleURI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleURI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x38
	}
	if m.ChildCellSelector != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ChildCellSelector))
		i--
		dAtA[i] = 0x30
	}
	if m.ParentAttrSelector != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ParentAttrSelector))
		i--
		dAtA[i] = 0x28
	}
	if m.PinCellIDx1 != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PinCellIDx1))
		i--
		dAtA[i] = 0x20
	}
	if m.PinCellIDx0 != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PinCellIDx0))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PinURL) > 0 {
		i -= len(m.PinURL)
		copy(dAtA[i:], m.PinURL)
		i = encodeVarintArc(dAtA, i, uint64(len(m.PinURL)))
		i--
		dAtA[i] = 0x12
	}
	if m.ParentReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ParentReqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ROU))))
		i--
		dAtA[i] = 0x35
	}
	if m.W != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.W))))
		i--
		dAtA[i] = 0x29
	}
	if m.V != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.V))))
		i--
		dAtA[i] = 0x21
	}
	if m.U != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.U))))
		i--
		dAtA[i] = 0x19
	}
	if m.CordType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CordType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AmpTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmpTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AmpTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MeterScale != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MeterScale))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.PixelHeight != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PixelHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.PixelWidth != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PixelWidth))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Rx2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rx2))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.Rx1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rx1))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.Rx0 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rx0))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.UIDx2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UIDx2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.UIDx1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UIDx1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.UIDx0 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UIDx0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubTags) > 0 {
		for iNdEx := len(m.SubTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *SheetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SheetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SheetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BoundSeries) > 0 {
		for iNdEx := len(m.BoundSeries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BoundSeries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AppSheetURI) > 0 {
		i -= len(m.AppSheetURI)
		copy(dAtA[i:], m.AppSheetURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.AppSheetURI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SheetGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SheetGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SheetGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SheetCatalog) > 0 {
		for iNdEx := len(m.SheetCatalog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SheetCatalog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CryptoKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintArc(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExternalLink != nil {
		{
			size, err := m.ExternalLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.CellURL) > 0 {
		i -= len(m.CellURL)
		copy(dAtA[i:], m.CellURL)
		i = encodeVarintArc(dAtA, i, uint64(len(m.CellURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Modified != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Modified))
		i--
		dAtA[i] = 0x48
	}
	if m.Created != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Glyphs) > 0 {
		for iNdEx := len(m.Glyphs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Glyphs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.About) > 0 {
		i -= len(m.About)
		copy(dAtA[i:], m.About)
		i = encodeVarintArc(dAtA, i, uint64(len(m.About)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AuthToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiry != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintArc(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintArc(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintArc(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TRS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TRS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TRS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfd
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.ScaleMode != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	return len(dAtA) - i, nil
}

func (m *FeedParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateIntervalMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMax))))
		i--
		dAtA[i] = 0x1d
	}
	if m.UpdateIntervalMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMin))))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *DataSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.BlobID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StreamURI) > 0 {
		i -= len(m.StreamURI)
		copy(dAtA[i:], m.StreamURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.StreamURI)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintArc(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ByteSz != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteSz))
		i--
		dAtA[i] = 0x30
	}
	if m.ByteOfs != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteOfs))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintArc(dAtA []byte, offset int, v uint64) int {
	offset -= sovArc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqID != 0 {
		n += 1 + sovArc(uint64(m.ReqID))
	}
	if m.Status != 0 {
		n += 1 + sovArc(uint64(m.Status))
	}
	if len(m.CellTxs) > 0 {
		for _, e := range m.CellTxs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *CellTxPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovArc(uint64(m.Op))
	}
	if m.CellID_0 != 0 {
		n += 9
	}
	if m.CellID_1 != 0 {
		n += 9
	}
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *AttrElemPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttrID != 0 {
		n += 1 + sovArc(uint64(m.AttrID))
	}
	l = len(m.ValBuf)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.SI != 0 {
		n += 1 + sovArc(uint64(m.SI))
	}
	return n
}

func (m *Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserUID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.HostAddr)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.DeviceLabel)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.DeviceUID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *LoginChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashResp)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Symbol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArc(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *RegisterDefs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Symbols) > 0 {
		for _, e := range m.Symbols {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *AttrSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefID != 0 {
		n += 1 + sovArc(uint64(m.DefID))
	}
	if m.ElemType != 0 {
		n += 1 + sovArc(uint64(m.ElemType))
	}
	if m.SeriesSpec != 0 {
		n += 1 + sovArc(uint64(m.SeriesSpec))
	}
	if m.SeriesIndexType != 0 {
		n += 1 + sovArc(uint64(m.SeriesIndexType))
	}
	if m.AttrName != 0 {
		n += 1 + sovArc(uint64(m.AttrName))
	}
	return n
}

func (m *ItemSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefID != 0 {
		n += 1 + sovArc(uint64(m.DefID))
	}
	if len(m.Include) > 0 {
		l = 0
		for _, e := range m.Include {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	if len(m.Exclude) > 0 {
		l = 0
		for _, e := range m.Exclude {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	return n
}

func (m *HandleURI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *PinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParentReqID != 0 {
		n += 1 + sovArc(uint64(m.ParentReqID))
	}
	l = len(m.PinURL)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.PinCellIDx0 != 0 {
		n += 1 + sovArc(uint64(m.PinCellIDx0))
	}
	if m.PinCellIDx1 != 0 {
		n += 1 + sovArc(uint64(m.PinCellIDx1))
	}
	if m.ParentAttrSelector != 0 {
		n += 1 + sovArc(uint64(m.ParentAttrSelector))
	}
	if m.ChildCellSelector != 0 {
		n += 1 + sovArc(uint64(m.ChildCellSelector))
	}
	if m.Flags != 0 {
		n += 1 + sovArc(uint64(m.Flags))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CordType != 0 {
		n += 1 + sovArc(uint64(m.CordType))
	}
	if m.U != 0 {
		n += 9
	}
	if m.V != 0 {
		n += 9
	}
	if m.W != 0 {
		n += 9
	}
	if m.ROU != 0 {
		n += 5
	}
	return n
}

func (m *AmpTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubTags) > 0 {
		for _, e := range m.SubTags {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovArc(uint64(m.State))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.UIDx0 != 0 {
		n += 10
	}
	if m.UIDx1 != 0 {
		n += 10
	}
	if m.UIDx2 != 0 {
		n += 10
	}
	if m.Rx0 != 0 {
		n += 6
	}
	if m.Rx1 != 0 {
		n += 6
	}
	if m.Rx2 != 0 {
		n += 6
	}
	if m.PixelWidth != 0 {
		n += 2 + sovArc(uint64(m.PixelWidth))
	}
	if m.PixelHeight != 0 {
		n += 2 + sovArc(uint64(m.PixelHeight))
	}
	if m.MeterScale != 0 {
		n += 6
	}
	return n
}

func (m *SheetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppSheetURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if len(m.BoundSeries) > 0 {
		for _, e := range m.BoundSeries {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *SheetGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SheetCatalog) > 0 {
		for _, e := range m.SheetCatalog {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *CryptoKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptoKitID != 0 {
		n += 1 + sovArc(uint64(m.CryptoKitID))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *CellHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if len(m.Glyphs) > 0 {
		for _, e := range m.Glyphs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if m.Created != 0 {
		n += 1 + sovArc(uint64(m.Created))
	}
	if m.Modified != 0 {
		n += 1 + sovArc(uint64(m.Modified))
	}
	l = len(m.CellURL)
	if l > 0 {
		n += 2 + l + sovArc(uint64(l))
	}
	if m.ExternalLink != nil {
		l = m.ExternalLink.Size()
		n += 2 + l + sovArc(uint64(l))
	}
	return n
}

func (m *AuthToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovArc(uint64(m.Expiry))
	}
	return n
}

func (m *TRS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.ScaleMode != 0 {
		n += 2 + sovArc(uint64(m.ScaleMode))
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	return n
}

func (m *FeedParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateIntervalMin != 0 {
		n += 5
	}
	if m.UpdateIntervalMax != 0 {
		n += 5
	}
	return n
}

func (m *DataSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteOfs != 0 {
		n += 1 + sovArc(uint64(m.ByteOfs))
	}
	if m.ByteSz != 0 {
		n += 1 + sovArc(uint64(m.ByteSz))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.StreamURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.BlobID != 0 {
		n += 1 + sovArc(uint64(m.BlobID))
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovArc(uint64(m.Code))
	}
	if m.Level != 0 {
		n += 1 + sovArc(uint64(m.Level))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func sovArc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArc(x uint64) (n int) {
	return sovArc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCellTxs := "[]*CellTxPb{"
	for _, f := range this.CellTxs {
		repeatedStringForCellTxs += strings.Replace(f.String(), "CellTxPb", "CellTxPb", 1) + ","
	}
	repeatedStringForCellTxs += "}"
	s := strings.Join([]string{`&Msg{`,
		`ReqID:` + fmt.Sprintf("%v", this.ReqID) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`CellTxs:` + repeatedStringForCellTxs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CellTxPb) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForElems := "[]*AttrElemPb{"
	for _, f := range this.Elems {
		repeatedStringForElems += strings.Replace(f.String(), "AttrElemPb", "AttrElemPb", 1) + ","
	}
	repeatedStringForElems += "}"
	s := strings.Join([]string{`&CellTxPb{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`CellID_0:` + fmt.Sprintf("%v", this.CellID_0) + `,`,
		`CellID_1:` + fmt.Sprintf("%v", this.CellID_1) + `,`,
		`Elems:` + repeatedStringForElems + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrElemPb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrElemPb{`,
		`AttrID:` + fmt.Sprintf("%v", this.AttrID) + `,`,
		`ValBuf:` + fmt.Sprintf("%v", this.ValBuf) + `,`,
		`SI:` + fmt.Sprintf("%v", this.SI) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Login) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Login{`,
		`UserUID:` + fmt.Sprintf("%v", this.UserUID) + `,`,
		`HostAddr:` + fmt.Sprintf("%v", this.HostAddr) + `,`,
		`DeviceLabel:` + fmt.Sprintf("%v", this.DeviceLabel) + `,`,
		`DeviceUID:` + fmt.Sprintf("%v", this.DeviceUID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginChallenge{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginResponse{`,
		`HashResp:` + fmt.Sprintf("%v", this.HashResp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Symbol) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Symbol{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegisterDefs) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSymbols := "[]*Symbol{"
	for _, f := range this.Symbols {
		repeatedStringForSymbols += strings.Replace(f.String(), "Symbol", "Symbol", 1) + ","
	}
	repeatedStringForSymbols += "}"
	repeatedStringForAttrs := "[]*AttrSpec{"
	for _, f := range this.Attrs {
		repeatedStringForAttrs += strings.Replace(f.String(), "AttrSpec", "AttrSpec", 1) + ","
	}
	repeatedStringForAttrs += "}"
	repeatedStringForSelectors := "[]*ItemSelector{"
	for _, f := range this.Selectors {
		repeatedStringForSelectors += strings.Replace(f.String(), "ItemSelector", "ItemSelector", 1) + ","
	}
	repeatedStringForSelectors += "}"
	s := strings.Join([]string{`&RegisterDefs{`,
		`Symbols:` + repeatedStringForSymbols + `,`,
		`Attrs:` + repeatedStringForAttrs + `,`,
		`Selectors:` + repeatedStringForSelectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrSpec{`,
		`DefID:` + fmt.Sprintf("%v", this.DefID) + `,`,
		`ElemType:` + fmt.Sprintf("%v", this.ElemType) + `,`,
		`SeriesSpec:` + fmt.Sprintf("%v", this.SeriesSpec) + `,`,
		`SeriesIndexType:` + fmt.Sprintf("%v", this.SeriesIndexType) + `,`,
		`AttrName:` + fmt.Sprintf("%v", this.AttrName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ItemSelector{`,
		`DefID:` + fmt.Sprintf("%v", this.DefID) + `,`,
		`Include:` + fmt.Sprintf("%v", this.Include) + `,`,
		`Exclude:` + fmt.Sprintf("%v", this.Exclude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HandleURI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HandleURI{`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PinRequest{`,
		`ParentReqID:` + fmt.Sprintf("%v", this.ParentReqID) + `,`,
		`PinURL:` + fmt.Sprintf("%v", this.PinURL) + `,`,
		`PinCellIDx0:` + fmt.Sprintf("%v", this.PinCellIDx0) + `,`,
		`PinCellIDx1:` + fmt.Sprintf("%v", this.PinCellIDx1) + `,`,
		`ParentAttrSelector:` + fmt.Sprintf("%v", this.ParentAttrSelector) + `,`,
		`ChildCellSelector:` + fmt.Sprintf("%v", this.ChildCellSelector) + `,`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`CordType:` + fmt.Sprintf("%v", this.CordType) + `,`,
		`U:` + fmt.Sprintf("%v", this.U) + `,`,
		`V:` + fmt.Sprintf("%v", this.V) + `,`,
		`W:` + fmt.Sprintf("%v", this.W) + `,`,
		`ROU:` + fmt.Sprintf("%v", this.ROU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AmpTag) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubTags := "[]*AmpTag{"
	for _, f := range this.SubTags {
		repeatedStringForSubTags += strings.Replace(f.String(), "AmpTag", "AmpTag", 1) + ","
	}
	repeatedStringForSubTags += "}"
	s := strings.Join([]string{`&AmpTag{`,
		`SubTags:` + repeatedStringForSubTags + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`URI:` + fmt.Sprintf("%v", this.URI) + `,`,
		`UIDx0:` + fmt.Sprintf("%v", this.UIDx0) + `,`,
		`UIDx1:` + fmt.Sprintf("%v", this.UIDx1) + `,`,
		`UIDx2:` + fmt.Sprintf("%v", this.UIDx2) + `,`,
		`Rx0:` + fmt.Sprintf("%v", this.Rx0) + `,`,
		`Rx1:` + fmt.Sprintf("%v", this.Rx1) + `,`,
		`Rx2:` + fmt.Sprintf("%v", this.Rx2) + `,`,
		`PixelWidth:` + fmt.Sprintf("%v", this.PixelWidth) + `,`,
		`PixelHeight:` + fmt.Sprintf("%v", this.PixelHeight) + `,`,
		`MeterScale:` + fmt.Sprintf("%v", this.MeterScale) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SheetInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBoundSeries := "[]*AttrSpec{"
	for _, f := range this.BoundSeries {
		repeatedStringForBoundSeries += strings.Replace(f.String(), "AttrSpec", "AttrSpec", 1) + ","
	}
	repeatedStringForBoundSeries += "}"
	s := strings.Join([]string{`&SheetInfo{`,
		`AppSheetURI:` + fmt.Sprintf("%v", this.AppSheetURI) + `,`,
		`BoundSeries:` + repeatedStringForBoundSeries + `,`,
		`}`,
	}, "")
	return s
}
func (this *SheetGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSheetCatalog := "[]*SheetInfo{"
	for _, f := range this.SheetCatalog {
		repeatedStringForSheetCatalog += strings.Replace(f.String(), "SheetInfo", "SheetInfo", 1) + ","
	}
	repeatedStringForSheetCatalog += "}"
	s := strings.Join([]string{`&SheetGroup{`,
		`SheetCatalog:` + repeatedStringForSheetCatalog + `,`,
		`}`,
	}, "")
	return s
}
func (this *CryptoKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptoKey{`,
		`CryptoKitID:` + fmt.Sprintf("%v", this.CryptoKitID) + `,`,
		`KeyBytes:` + fmt.Sprintf("%v", this.KeyBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CellHeader) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGlyphs := "[]*AmpTag{"
	for _, f := range this.Glyphs {
		repeatedStringForGlyphs += strings.Replace(f.String(), "AmpTag", "AmpTag", 1) + ","
	}
	repeatedStringForGlyphs += "}"
	s := strings.Join([]string{`&CellHeader{`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Subtitle:` + fmt.Sprintf("%v", this.Subtitle) + `,`,
		`About:` + fmt.Sprintf("%v", this.About) + `,`,
		`Glyphs:` + repeatedStringForGlyphs + `,`,
		`Created:` + fmt.Sprintf("%v", this.Created) + `,`,
		`Modified:` + fmt.Sprintf("%v", this.Modified) + `,`,
		`CellURL:` + fmt.Sprintf("%v", this.CellURL) + `,`,
		`ExternalLink:` + strings.Replace(this.ExternalLink.String(), "AmpTag", "AmpTag", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthToken) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthToken{`,
		`AccessToken:` + fmt.Sprintf("%v", this.AccessToken) + `,`,
		`TokenType:` + fmt.Sprintf("%v", this.TokenType) + `,`,
		`RefreshToken:` + fmt.Sprintf("%v", this.RefreshToken) + `,`,
		`Expiry:` + fmt.Sprintf("%v", this.Expiry) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TRS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TRS{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`X3:` + fmt.Sprintf("%v", this.X3) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`Scale3:` + fmt.Sprintf("%v", this.Scale3) + `,`,
		`Rotate1:` + fmt.Sprintf("%v", this.Rotate1) + `,`,
		`Rotate2:` + fmt.Sprintf("%v", this.Rotate2) + `,`,
		`Rotate3:` + fmt.Sprintf("%v", this.Rotate3) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeedParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeedParams{`,
		`UpdateIntervalMin:` + fmt.Sprintf("%v", this.UpdateIntervalMin) + `,`,
		`UpdateIntervalMax:` + fmt.Sprintf("%v", this.UpdateIntervalMax) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSegment{`,
		`ByteOfs:` + fmt.Sprintf("%v", this.ByteOfs) + `,`,
		`ByteSz:` + fmt.Sprintf("%v", this.ByteSz) + `,`,
		`InlineData:` + fmt.Sprintf("%v", this.InlineData) + `,`,
		`StreamURI:` + fmt.Sprintf("%v", this.StreamURI) + `,`,
		`BlobID:` + fmt.Sprintf("%v", this.BlobID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Err) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Err{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringArc(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReqStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellTxs = append(m.CellTxs, &CellTxPb{})
			if err := m.CellTxs[len(m.CellTxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellTxPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellTxPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellTxPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= CellTxOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID_0", wireType)
			}
			m.CellID_0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CellID_0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID_1", wireType)
			}
			m.CellID_1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CellID_1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &AttrElemPb{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrElemPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrElemPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrElemPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrID", wireType)
			}
			m.AttrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValBuf = append(m.ValBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ValBuf == nil {
				m.ValBuf = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI", wireType)
			}
			m.SI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashResp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashResp = append(m.HashResp[:0], dAtA[iNdEx:postIndex]...)
			if m.HashResp == nil {
				m.HashResp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterDefs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterDefs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterDefs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbols = append(m.Symbols, &Symbol{})
			if err := m.Symbols[len(m.Symbols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &AttrSpec{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &ItemSelector{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefID", wireType)
			}
			m.DefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemType", wireType)
			}
			m.ElemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElemType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesSpec", wireType)
			}
			m.SeriesSpec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesSpec |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesIndexType", wireType)
			}
			m.SeriesIndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesIndexType |= SeriesIndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			m.AttrName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrName |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefID", wireType)
			}
			m.DefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Include = append(m.Include, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Include) == 0 {
					m.Include = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Include = append(m.Include, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Exclude = append(m.Exclude, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Exclude) == 0 {
					m.Exclude = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Exclude = append(m.Exclude, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleURI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleURI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleURI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentReqID", wireType)
			}
			m.ParentReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinCellIDx0", wireType)
			}
			m.PinCellIDx0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinCellIDx0 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinCellIDx1", wireType)
			}
			m.PinCellIDx1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinCellIDx1 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAttrSelector", wireType)
			}
			m.ParentAttrSelector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentAttrSelector |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildCellSelector", wireType)
			}
			m.ChildCellSelector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildCellSelector |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= PinFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CordType", wireType)
			}
			m.CordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CordType |= CordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.U = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.V = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.W = float64(math.Float64frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ROU = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmpTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmpTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmpTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubTags = append(m.SubTags, &AmpTag{})
			if err := m.SubTags[len(m.SubTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= QuadState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UIDx0", wireType)
			}
			m.UIDx0 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.UIDx0 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UIDx1", wireType)
			}
			m.UIDx1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.UIDx1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UIDx2", wireType)
			}
			m.UIDx2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.UIDx2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rx0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rx0 = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rx1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rx1 = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rx2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rx2 = float32(math.Float32frombits(v))
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PixelWidth", wireType)
			}
			m.PixelWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PixelWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PixelHeight", wireType)
			}
			m.PixelHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PixelHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MeterScale = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SheetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SheetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SheetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppSheetURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppSheetURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundSeries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BoundSeries = append(m.BoundSeries, &AttrSpec{})
			if err := m.BoundSeries[len(m.BoundSeries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SheetGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SheetGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SheetGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SheetCatalog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SheetCatalog = append(m.SheetCatalog, &SheetInfo{})
			if err := m.SheetCatalog[len(m.SheetCatalog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glyphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glyphs = append(m.Glyphs, &AmpTag{})
			if err := m.Glyphs[len(m.Glyphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			m.Modified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalLink == nil {
				m.ExternalLink = &AmpTag{}
			}
			if err := m.ExternalLink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TRS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TRS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TRS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= TRS_VisualScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 63:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMin = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOfs", wireType)
			}
			m.ByteOfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteOfs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSz", wireType)
			}
			m.ByteSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobID", wireType)
			}
			m.BlobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArc = fmt.Errorf("proto: unexpected end of group")
)
